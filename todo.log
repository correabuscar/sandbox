------------
* get 0-clause BSD (0BSD) license too  src: https://crates.io/crates/smoltcp#license
* get more licenses like MIT and apache2 too
------------


------------
* concept: allow/disallow something in a tree of calls
for example:
main call()
allow dnsout to 1.1.1.1
for each host do
  dnslookup host
  add to firewall
done
disallow dnsout to 1.1.1.1

where dnslookup host also calls:
allow dnsout to 1.1.1.1
 actual dns lookup using 1.1.1.1 here
disallow dnsout to 1.1.1.1

So, if the allow/disallow would actually use a counter and only allow/disallow first/last time, and all other subsequent times just inc/dec counter, then the allow/disallow would only happen in main call, and yet, dnslookup itself would also work by itself(aka independently) if needed that way!

so now imagine the main call is fwadd and dnslookup is dnslookuponline, as bash scripts, or just rust exes...

the allow can detect whether it was allowed or not, but it can't detect the counter!

hmm, so maybe more generically, if something is to be done globally(such as that temporary allow/disallow dns out) then, it must have a counter, to speed up things, instead of actually allow/disallow every time dnslookuponline is called, if done for say digyoutube (script) which has hundreds of hosts!


now, if the host-to-IP mapping would be stored temporarily in memory(needed so the counter isn't modified on disk causing unneeded writes!), and accessed by anyone(process) needing it, then we could add a counter with the allow/disallow. Maybe it could even be persisted on disk, but the counter would only be stored in RAM. In other words, have a counter + host-to-IP in RAM, and persist to disk(ie. as /etc/hosts) only the host-to-IP list, if it changes!

Ok so now the question is, how do we have a rust process(executable) act like a server (actix?) so that other executables could talk to it? and some kind of atomicity so they don't step on eachother's toes!?

I guess the problem is that the actions that I need to do should be dynamic: generated whenever I want them, instead of being already compiled into a rust program then executed (which would guarantee all kinds of race conditions wouldn't happen, for example)

But if I split them into one server and multiple clients, then rust can't guarantee they won't somehow hit race conditions, if atomicity is wanted, or what? some kind of locking would be employed and not allow multiple clients to do things with the server concurrently? I don't think so... hmmm..


ok so let's see concretely:
dnslookuponline(host):
  fwallow temp https to 1.1.1.1
  performdnslookup(host)
  fwdisallow temp https to 1.1.1.1

fwadd(hosts...):
  fwallow temp https to 1.1.1.1
  for each host in hosts
    ips=dnslookuponline(host)
    addtofirewall(host, ips) //simplified, because this needs to know if temp and which ports too!
  endfor
  fwdisallow temp https to 1.1.1.1


ok, attempting to use/learn some openmpi
------------
https://mpitutorial.com/tutorials/dynamic-receiving-with-mpi-probe-and-mpi-status/
https://github.com/bsteinb/rsmpi/blob/master/examples/broadcast.rs
https://bsteinb.github.io/rsmpi/mpi/index.html
https://hpc-wiki.info/hpc/MPI
------------
license related reading:
https://github.com/github/choosealicense.com/issues/413
https://landley.net/toybox/license.html
https://en.wikipedia.org/wiki/Public-domain_software
https://crates.io/crates/smoltcp#license
------------
iptables/nft related stuff:
https://crates.io/crates/nftnl
https://crates.io/crates/nftnl-sys
https://crates.io/crates/netfilter_queue
https://github.com/vtsingaras/libiptc-sys
https://github.com/vtsingaras/libiptc-sys/network
https://crates.io/crates/riptables
https://crates.io/crates/iptables

what was this for?
https://crates.io/crates/mount_status_monitor
------------
rustls for communicating?
https://github.com/ctz/rustls/issues
https://github.com/kpcyrd
------------
actix?
https://github.com/actix/examples
------------
------------
------------
