use std::ffi::{CStr, CString};
use libc::{dlopen, RTLD_LAZY, dlsym, dlerror};
//
//this code was generated by a large language model (it's how it wanted to be credited, even though it said it was optional :) )

fn main() {
// Load the library
//let lib_name = CString::new("/nix/store/xav6z6xz0n9bb9zvvvivsjyzyzx4lh9q-libGL-1.7.0/lib/libEGL.so.1").unwrap(); //nixos
let lib_name = CString::new("/usr/lib64/libEGL.so.1.1.0").unwrap(); //gentoo
let library = unsafe { dlopen(lib_name.as_ptr(), RTLD_LAZY) };

if library.is_null() {
    panic!("Failed to load library: {}", unsafe { CStr::from_ptr(dlerror()) }.to_string_lossy());
}

// Obtain the symbol address
let symbol_name = CString::new("eglCreatePlatformWindowSurfaceEXT").unwrap();
let symbol_ptr = unsafe { dlsym(library, symbol_name.as_ptr()) };

if symbol_ptr.is_null() {
    panic!("Failed to find symbol: {}", unsafe { CStr::from_ptr(dlerror()) }.to_string_lossy());
}

// Cast the symbol pointer to the correct function type
// (Assuming a typical EGL function signature with 5 arguments here, adjust as needed)
//let egl_create_platform_window_surface_ext:
//    unsafe extern "C" fn(*mut EGLDisplay, EGLConfig, *mut NativeWindowType, EGLint *, EGLSurface *) -> EGLBoolean =
//    std::mem::transmute(symbol_ptr);

// Now you can call the function using the `egl_create_platform_window_surface_ext` variable
// Example:
// let display: *mut EGLDisplay = ...; // Your EGLDisplay value
// let config: EGLConfig = ...; // Your EGLConfig value
// let native_window: *mut NativeWindowType = ...; // Your NativeWindowType value
// let attrib_list: *const EGLint = ...; // Your EGL attribute list
// let surface: *mut EGLSurface = ...; // Output variable for the created surface
//
// let result = egl_create_platform_window_surface_ext(display, config, native_window, attrib_list, surface);
// if result == EGL_TRUE {
//     // Surface creation successful
// } else {
//     // Handle surface creation failure
//     println!("Surface creation failed: {}", result);
// }
    }
