From 836e81f265f7563ffaa44b7eea0748c619277221 Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Thu, 11 Apr 2024 00:22:18 +0200
Subject: [PATCH 01/54] .gitignore rustc ice .txt files

files like: rustc-ice-2024-04-10T18_21_42-154961.txt
made due to using rust flags: -Z treat-err-as-bug=5
---
 .gitignore | 1 +
 1 file changed, 1 insertion(+)

diff --git a/.gitignore b/.gitignore
index d1338731..c53cd369 100644
--- a/.gitignore
+++ b/.gitignore
@@ -3,3 +3,4 @@ bin
 Cargo.lock
 .*
 *.swp
+rustc-ice-*.txt

From 34310c5546a27b822552ee9b37f6727405ffaac2 Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Thu, 11 Apr 2024 00:25:43 +0200
Subject: [PATCH 02/54] make KEY_F() function a const fn

so that it can be used like this:
pub const KEY_F15: i32 = ncurses::KEY_F(15);
which is what pancurses uses.
---
 src/lib.rs | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/lib.rs b/src/lib.rs
index 06facdee..5cb0c952 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -1769,7 +1769,8 @@ pub fn setsyx(y: &mut i32, x: &mut i32)
   }
 }
 
-pub fn KEY_F(n: u8) -> i32
+#[inline]
+pub const fn KEY_F(n: u8) -> i32
 {
   assert!(n < 16);
   KEY_F0 + n as i32

From ab8fd269fd37ce8e8970406bbc7d803b5be2e8bc Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Thu, 11 Apr 2024 00:29:05 +0200
Subject: [PATCH 03/54] prefix with KEY_ the keypad keys A1,A3,B2,C1,C3

or else they aren't defined.
(regression)
---
 src/genconstants.c | 20 ++++++++++----------
 1 file changed, 10 insertions(+), 10 deletions(-)

diff --git a/src/genconstants.c b/src/genconstants.c
index f79e2d16..b3a7160e 100644
--- a/src/genconstants.c
+++ b/src/genconstants.c
@@ -107,20 +107,20 @@ int main() {
 	PCONST(i32, KEY_ENTER);
 	PCONST(i32, KEY_PRINT);
 	PCONST(i32, KEY_LL);
-#ifdef A1
-	PCONST(i32, A1);
+#ifdef KEY_A1
+	PCONST(i32, KEY_A1);
 #endif
-#ifdef A3
-	PCONST(i32, A3);
+#ifdef KEY_A3
+	PCONST(i32, KEY_A3);
 #endif
-#ifdef B2
-	PCONST(i32, B2);
+#ifdef KEY_B2
+	PCONST(i32, KEY_B2);
 #endif
-#ifdef C1
-	PCONST(i32, C1);
+#ifdef KEY_C1
+	PCONST(i32, KEY_C1);
 #endif
-#ifdef C3
-	PCONST(i32, C3);
+#ifdef KEY_C3
+	PCONST(i32, KEY_C3);
 #endif
 	PCONST(i32, KEY_BTAB);
 	PCONST(i32, KEY_BEG);

From e4a1b4fffe14f88bb91181638273003c00d59ac3 Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Thu, 11 Apr 2024 00:30:14 +0200
Subject: [PATCH 04/54] define A_ITALIC if it's defined in header

(regression)
---
 src/genconstants.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/genconstants.c b/src/genconstants.c
index b3a7160e..44987ae2 100644
--- a/src/genconstants.c
+++ b/src/genconstants.c
@@ -278,6 +278,9 @@ int main() {
 	PCONSTU(crate::ll::chtype, A_NORMAL);
 	PCONSTU(crate::ll::chtype, A_STANDOUT);
 	PCONSTU(crate::ll::chtype, A_UNDERLINE);
+#ifdef A_ITALIC
+	PCONSTU(crate::ll::chtype, A_ITALIC);
+#endif
 	PCONSTU(crate::ll::chtype, A_REVERSE);
 	PCONSTU(crate::ll::chtype, A_BLINK);
 	PCONSTU(crate::ll::chtype, A_DIM);

From 7fd51d9056147746e121ee3f41f70a6152700a99 Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Thu, 11 Apr 2024 00:35:22 +0200
Subject: [PATCH 05/54] make it compile in Gentoo & NixOS, not just Fedora

...provided the libs/includes are installed system-wide already.

Decided not to split this in different commits (which each still
compile) due to too much redundant work, since everything is already
done in this one commit.
---
 build.rs | 111 ++++++++++++++++++++++++++++++++++++++++++++++---------
 1 file changed, 94 insertions(+), 17 deletions(-)

diff --git a/build.rs b/build.rs
index 1489d532..87f79885 100644
--- a/build.rs
+++ b/build.rs
@@ -45,38 +45,101 @@ fn main() {
         }
     }
 
-    match std::env::var("NCURSES_RS_RUSTC_LINK_LIB") {
-        Ok(x) => println!("cargo:rustc-link-lib={}", x),
-        _ => if ncurses_lib.is_none() {
-            println!("cargo:rustc-link-lib={}", ncurses_lib_names.last().unwrap())
+    let mut already_printed:bool=false;
+    const ENV_VAR_NAME_FOR_LIB:&str="NCURSES_RS_RUSTC_LINK_LIB";
+    println!("cargo:rerun-if-env-changed={}",ENV_VAR_NAME_FOR_LIB);
+    let lib_name:String=match std::env::var(ENV_VAR_NAME_FOR_LIB) {
+        Ok(x) => x,
+        _ => if let Some(ref lib)=ncurses_lib {
+            // you can get something like this ["ncurses", "tinfo"] as the lib.libs vector
+            // but we shouldn't assume "ncurses" is the first ie. lib.libs[0]
+            // and the exact name of it can be ncurses,ncursesw,ncurses5,ncursesw5 ...
+            // so find whichever it is and return that:
+            let substring_to_find = "curses";
+            if let Some(found) = lib.libs.iter().find(|&s| s.contains(substring_to_find)) {
+                //If we're here, the pkg_config::probe_library() calls from above ie. through find_library()
+                //have already printed these:
+                //   cargo:rustc-link-lib=ncurses
+                //   cargo:rustc-link-lib=tinfo
+                //so there's no need to re-print the ncurses line
+                already_printed=true;
+                found.clone()
+            } else {
+                //if here, we should probably panic, but who knows it might still work even without pkg-config
+
+                // Construct the repeated pkg-config command string
+                let repeated_pkg_config_command: String = ncurses_lib_names
+                    .iter()
+                    .map(|ncurses_lib_name| format!("pkg-config --libs {}", ncurses_lib_name))
+                    .collect::<Vec<_>>()
+                    .join("` or `");
+
+                // Construct the warning message string with the repeated pkg-config commands
+                let warning_message = format!(
+                    "pkg_config reported that it found the ncurses libs but the substring '{}' was not among them, ie. in the output of the shell command(s) eg. `{}`",
+                    substring_to_find,
+                    repeated_pkg_config_command
+                    );
+
+                // Print the warning message, but use old style warning with one ":" not two "::",
+                // because old cargos(pre 23 Dec 2023) will simply ignore it and show no warning if it's "::"
+                println!("cargo:warning={}", warning_message);
+                //fallback lib name: 'ncurses' or 'ncursesw'
+                //if this fails, there's the warning above to get an idea as to why.
+                ncurses_lib_names.last().unwrap().to_string()
+            }
+        } else {
+            //pkg-config didn't find the lib, fallback to 'ncurses' or 'ncursesw'
+            ncurses_lib_names.last().unwrap().to_string()
         }
+    };
+    if !already_printed {
+        println!("cargo:rustc-link-lib={}", lib_name);
     }
 
-    if let Ok(x) = std::env::var("NCURSES_RS_RUSTC_FLAGS") {
+    const ENV_VAR_NAME_FOR_FLAGS:&str="NCURSES_RS_RUSTC_FLAGS";
+    println!("cargo:rerun-if-env-changed={}",ENV_VAR_NAME_FOR_FLAGS);
+    if let Ok(x) = std::env::var(ENV_VAR_NAME_FOR_FLAGS) {
         println!("cargo:rustc-flags={}", x);
     }
 
     check_chtype_size(&ncurses_lib);
 
-    gen_constants();
-    gen_menu_constants();
-    build_wrap();
+    gen_constants(&ncurses_lib, &lib_name);
+    gen_menu_constants(&ncurses_lib, &lib_name);
+    build_wrap(&ncurses_lib);
 }
 
-fn build_wrap() {
+fn build_wrap(ncurses_lib: &Option<Library>) {
     println!("cargo:rerun-if-changed=src/wrap.c");
-    cc::Build::new()
-        .file("src/wrap.c")
+    let mut build = cc::Build::new();
+    if let Some(lib) = ncurses_lib {
+        for path in lib.include_paths.iter() {
+            build.include(path);
+        }
+    }
+    build.file("src/wrap.c")
         .compile("wrap");
 }
 
-fn gen_constants() {
+fn gen_constants(ncurses_lib: &Option<Library>, lib_name:&str) {
     println!("cargo:rerun-if-changed=src/genconstants.c");
     let out_dir = env::var("OUT_DIR").expect("cannot get OUT_DIR");
     let bin = format!("{}", Path::new(&out_dir).join(if cfg!(windows) { "genconstants.exe" } else { "genconstants" }).display());
     let src = format!("{}", Path::new(&out_dir).join("raw_constants.rs").display());
 
-    let build = cc::Build::new();
+    let mut build = cc::Build::new();
+    let link_paths_for_linker;
+    if let Some(lib) = ncurses_lib {
+        for path in lib.include_paths.iter() {
+            build.include(path);
+        }
+        link_paths_for_linker=lib.link_paths.iter()
+            .map(|link_path| format!("-L{}", link_path.display()))
+            .collect::<Vec<String>>();
+    } else {
+        link_paths_for_linker=vec!();
+    }
     let compiler = build.try_get_compiler().expect("Failed Build::try_get_compiler");
     let mut command = compiler.to_command();
 
@@ -84,7 +147,8 @@ fn gen_constants() {
         command.args(x.split(" "));
     }    
 
-    command.arg("-o").arg(&bin).arg("src/genconstants.c").arg("-lcurses");
+    command.arg("-o").arg(&bin).arg("src/genconstants.c")
+        .arg(format!("-l{}",lib_name)).args(link_paths_for_linker);
     assert!(command.status().expect("compilation failed").success());
 
     let consts = Command::new(&bin).output()
@@ -95,13 +159,25 @@ fn gen_constants() {
     file.write_all(&consts.stdout).unwrap();
 }
 
-fn gen_menu_constants() {
+//FIXME: dedup code in these 2 functions
+fn gen_menu_constants(ncurses_lib: &Option<Library>, lib_name:&str) {
     println!("cargo:rerun-if-changed=src/menu/genconstants.c");
     let out_dir = env::var("OUT_DIR").expect("cannot get OUT_DIR");
     let bin = format!("{}", Path::new(&out_dir).join(if cfg!(windows) { "genmenuconstants.exe" } else { "genmenuconstants" }).display());
     let src = format!("{}", Path::new(&out_dir).join("menu_constants.rs").display());
 
-    let build = cc::Build::new();
+    let mut build = cc::Build::new();
+    let link_paths_for_linker;
+    if let Some(lib) = ncurses_lib {
+        for path in lib.include_paths.iter() {
+            build.include(path);
+        }
+        link_paths_for_linker=lib.link_paths.iter()
+            .map(|link_path| format!("-L{}", link_path.display()))
+            .collect::<Vec<String>>();
+    } else {
+        link_paths_for_linker=vec!();
+    }
     let compiler = build.try_get_compiler().expect("Failed Build::try_get_compiler");
     let mut command = compiler.to_command();
 
@@ -109,7 +185,8 @@ fn gen_menu_constants() {
         command.args(x.split(" "));
     }    
 
-    command.arg("-o").arg(&bin).arg("src/menu/genconstants.c").arg("-lcurses");
+    command.arg("-o").arg(&bin).arg("src/menu/genconstants.c")
+        .arg(format!("-l{}",lib_name)).args(link_paths_for_linker);
     assert!(command.status().expect("compilation failed").success());
 
     let consts = Command::new(&bin).output()

From ab37570057ce4dfd70b100469e9630efede5e4ed Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Thu, 11 Apr 2024 09:20:38 +0200
Subject: [PATCH 06/54] dedup some code

---
 build.rs | 105 ++++++++++++++++++++-----------------------------------
 1 file changed, 38 insertions(+), 67 deletions(-)

diff --git a/build.rs b/build.rs
index 87f79885..338585a7 100644
--- a/build.rs
+++ b/build.rs
@@ -8,6 +8,10 @@ use std::io::Write;
 use std::path::Path;
 use std::process::Command;
 
+const ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS:&str="NCURSES_RS_CFLAGS";
+const ENV_VAR_NAME_FOR_LIB:&str="NCURSES_RS_RUSTC_LINK_LIB";
+const ENV_VAR_NAME_FOR_NCURSES_RS_RUSTC_FLAGS:&str="NCURSES_RS_RUSTC_FLAGS";
+
 fn find_library(names: &[&str]) -> Option<Library> {
     for name in names {
         if let Ok(lib) = pkg_config::probe_library(name) {
@@ -19,6 +23,9 @@ fn find_library(names: &[&str]) -> Option<Library> {
 
 fn main() {
     println!("cargo:rerun-if-env-changed=PKG_CONFIG_PATH");
+    println!("cargo:rerun-if-env-changed={}",ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS);
+    println!("cargo:rerun-if-env-changed={}",ENV_VAR_NAME_FOR_NCURSES_RS_RUSTC_FLAGS);
+    println!("cargo:rerun-if-env-changed={}",ENV_VAR_NAME_FOR_LIB);
 
     let wide = cfg!(all(feature = "wide", not(target_os = "macos")));
 
@@ -46,8 +53,6 @@ fn main() {
     }
 
     let mut already_printed:bool=false;
-    const ENV_VAR_NAME_FOR_LIB:&str="NCURSES_RS_RUSTC_LINK_LIB";
-    println!("cargo:rerun-if-env-changed={}",ENV_VAR_NAME_FOR_LIB);
     let lib_name:String=match std::env::var(ENV_VAR_NAME_FOR_LIB) {
         Ok(x) => x,
         _ => if let Some(ref lib)=ncurses_lib {
@@ -57,11 +62,11 @@ fn main() {
             // so find whichever it is and return that:
             let substring_to_find = "curses";
             if let Some(found) = lib.libs.iter().find(|&s| s.contains(substring_to_find)) {
-                //If we're here, the pkg_config::probe_library() calls from above ie. through find_library()
-                //have already printed these:
+                //If we're here, the function calls to pkg_config::probe_library()
+                //from above ie. through find_library(), have already printed these:
                 //   cargo:rustc-link-lib=ncurses
                 //   cargo:rustc-link-lib=tinfo
-                //so there's no need to re-print the ncurses line
+                //so there's no need to re-print the ncurses line as it would be the same.
                 already_printed=true;
                 found.clone()
             } else {
@@ -84,8 +89,9 @@ fn main() {
                 // Print the warning message, but use old style warning with one ":" not two "::",
                 // because old cargos(pre 23 Dec 2023) will simply ignore it and show no warning if it's "::"
                 println!("cargo:warning={}", warning_message);
+
                 //fallback lib name: 'ncurses' or 'ncursesw'
-                //if this fails, there's the warning above to get an idea as to why.
+                //if this fails later, there's the warning above to get an idea as to why.
                 ncurses_lib_names.last().unwrap().to_string()
             }
         } else {
@@ -97,16 +103,14 @@ fn main() {
         println!("cargo:rustc-link-lib={}", lib_name);
     }
 
-    const ENV_VAR_NAME_FOR_FLAGS:&str="NCURSES_RS_RUSTC_FLAGS";
-    println!("cargo:rerun-if-env-changed={}",ENV_VAR_NAME_FOR_FLAGS);
-    if let Ok(x) = std::env::var(ENV_VAR_NAME_FOR_FLAGS) {
+    if let Ok(x) = std::env::var(ENV_VAR_NAME_FOR_NCURSES_RS_RUSTC_FLAGS) {
         println!("cargo:rustc-flags={}", x);
     }
 
     check_chtype_size(&ncurses_lib);
 
-    gen_constants(&ncurses_lib, &lib_name);
-    gen_menu_constants(&ncurses_lib, &lib_name);
+    gen_rs("src/genconstants.c", "genconstants", "raw_constants.rs", &ncurses_lib, &lib_name);
+    gen_rs("src/menu/genconstants.c", "genmenuconstants", "menu_constants.rs", &ncurses_lib, &lib_name);
     build_wrap(&ncurses_lib);
 }
 
@@ -122,81 +126,48 @@ fn build_wrap(ncurses_lib: &Option<Library>) {
         .compile("wrap");
 }
 
-fn gen_constants(ncurses_lib: &Option<Library>, lib_name:&str) {
-    println!("cargo:rerun-if-changed=src/genconstants.c");
+fn gen_rs(source_c_file:&str, out_bin_file:&str, gen_rust_file:&str, ncurses_lib: &Option<Library>, lib_name:&str) {
+    println!("cargo:rerun-if-changed={}", source_c_file);
     let out_dir = env::var("OUT_DIR").expect("cannot get OUT_DIR");
-    let bin = format!("{}", Path::new(&out_dir).join(if cfg!(windows) { "genconstants.exe" } else { "genconstants" }).display());
-    let src = format!("{}", Path::new(&out_dir).join("raw_constants.rs").display());
-
+    let gen_rust_file_full_path = format!("{}", Path::new(&out_dir).join(gen_rust_file).display());
+    let bin = format!("{}", Path::new(&out_dir)
+                          .join(format!("{}{}",out_bin_file,if cfg!(windows) { ".exe" } else { "" })).display());
     let mut build = cc::Build::new();
-    let link_paths_for_linker;
+    let mut linker_searchdir_args=Vec::new();
     if let Some(lib) = ncurses_lib {
         for path in lib.include_paths.iter() {
             build.include(path);
         }
-        link_paths_for_linker=lib.link_paths.iter()
-            .map(|link_path| format!("-L{}", link_path.display()))
-            .collect::<Vec<String>>();
-    } else {
-        link_paths_for_linker=vec!();
-    }
-    let compiler = build.try_get_compiler().expect("Failed Build::try_get_compiler");
-    let mut command = compiler.to_command();
-
-    if let Ok(x) = std::env::var("NCURSES_RS_CFLAGS") {
-        command.args(x.split(" "));
-    }    
-
-    command.arg("-o").arg(&bin).arg("src/genconstants.c")
-        .arg(format!("-l{}",lib_name)).args(link_paths_for_linker);
-    assert!(command.status().expect("compilation failed").success());
-
-    let consts = Command::new(&bin).output()
-        .expect(&format!("{} failed", bin));
-
-    let mut file = File::create(&src).unwrap();
-    
-    file.write_all(&consts.stdout).unwrap();
-}
-
-//FIXME: dedup code in these 2 functions
-fn gen_menu_constants(ncurses_lib: &Option<Library>, lib_name:&str) {
-    println!("cargo:rerun-if-changed=src/menu/genconstants.c");
-    let out_dir = env::var("OUT_DIR").expect("cannot get OUT_DIR");
-    let bin = format!("{}", Path::new(&out_dir).join(if cfg!(windows) { "genmenuconstants.exe" } else { "genmenuconstants" }).display());
-    let src = format!("{}", Path::new(&out_dir).join("menu_constants.rs").display());
-
-    let mut build = cc::Build::new();
-    let link_paths_for_linker;
-    if let Some(lib) = ncurses_lib {
-        for path in lib.include_paths.iter() {
-            build.include(path);
+        for link_path in &lib.link_paths {
+            linker_searchdir_args.push("-L".to_string());
+            linker_searchdir_args.push(link_path.display().to_string());
         }
-        link_paths_for_linker=lib.link_paths.iter()
-            .map(|link_path| format!("-L{}", link_path.display()))
-            .collect::<Vec<String>>();
-    } else {
-        link_paths_for_linker=vec!();
     }
     let compiler = build.try_get_compiler().expect("Failed Build::try_get_compiler");
     let mut command = compiler.to_command();
 
-    if let Ok(x) = std::env::var("NCURSES_RS_CFLAGS") {
+    if let Ok(x) = std::env::var(ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS) {
         command.args(x.split(" "));
-    }    
+    }
 
-    command.arg("-o").arg(&bin).arg("src/menu/genconstants.c")
-        .arg(format!("-l{}",lib_name)).args(link_paths_for_linker);
+    command.arg("-o").arg(&bin).arg(source_c_file)
+        .args(["-l", lib_name])
+        .args(linker_searchdir_args);
     assert!(command.status().expect("compilation failed").success());
 
     let consts = Command::new(&bin).output()
         .expect(&format!("{} failed", bin));
 
-    let mut file = File::create(&src).unwrap();
-    
-    file.write_all(&consts.stdout).unwrap();
+    let mut file = File::create(&gen_rust_file_full_path).unwrap_or_else(|err| {
+        panic!("Couldn't create rust file '{}', reason: '{}'", gen_rust_file_full_path, err)
+    });
+
+    file.write_all(&consts.stdout).unwrap_or_else(|err| {
+        panic!("Couldn't write to rust file '{}', reason: '{}'", gen_rust_file_full_path, err)
+    });
 }
 
+
 fn check_chtype_size(ncurses_lib: &Option<Library>) {
     let out_dir = env::var("OUT_DIR").expect("cannot get OUT_DIR");
     let src = format!("{}", Path::new(&out_dir).join("chtype_size.c").display());
@@ -235,7 +206,7 @@ int main(void)
     let compiler = build.try_get_compiler().expect("Failed Build::try_get_compiler");
     let mut command = compiler.to_command();
 
-    if let Ok(x) = std::env::var("NCURSES_RS_CFLAGS") {
+    if let Ok(x) = std::env::var(ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS) {
         command.args(x.split(" "));
     }
 

From 34b50ec2e4afe5ba5192733b9ae2d05f7b476f3b Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Thu, 11 Apr 2024 09:21:47 +0200
Subject: [PATCH 07/54] rustfmt build.rs

---
 build.rs | 181 ++++++++++++++++++++++++++++++++++++-------------------
 1 file changed, 120 insertions(+), 61 deletions(-)

diff --git a/build.rs b/build.rs
index 338585a7..5345e2fc 100644
--- a/build.rs
+++ b/build.rs
@@ -8,9 +8,9 @@ use std::io::Write;
 use std::path::Path;
 use std::process::Command;
 
-const ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS:&str="NCURSES_RS_CFLAGS";
-const ENV_VAR_NAME_FOR_LIB:&str="NCURSES_RS_RUSTC_LINK_LIB";
-const ENV_VAR_NAME_FOR_NCURSES_RS_RUSTC_FLAGS:&str="NCURSES_RS_RUSTC_FLAGS";
+const ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS: &str = "NCURSES_RS_CFLAGS";
+const ENV_VAR_NAME_FOR_LIB: &str = "NCURSES_RS_RUSTC_LINK_LIB";
+const ENV_VAR_NAME_FOR_NCURSES_RS_RUSTC_FLAGS: &str = "NCURSES_RS_RUSTC_FLAGS";
 
 fn find_library(names: &[&str]) -> Option<Library> {
     for name in names {
@@ -23,9 +23,15 @@ fn find_library(names: &[&str]) -> Option<Library> {
 
 fn main() {
     println!("cargo:rerun-if-env-changed=PKG_CONFIG_PATH");
-    println!("cargo:rerun-if-env-changed={}",ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS);
-    println!("cargo:rerun-if-env-changed={}",ENV_VAR_NAME_FOR_NCURSES_RS_RUSTC_FLAGS);
-    println!("cargo:rerun-if-env-changed={}",ENV_VAR_NAME_FOR_LIB);
+    println!(
+        "cargo:rerun-if-env-changed={}",
+        ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS
+    );
+    println!(
+        "cargo:rerun-if-env-changed={}",
+        ENV_VAR_NAME_FOR_NCURSES_RS_RUSTC_FLAGS
+    );
+    println!("cargo:rerun-if-env-changed={}", ENV_VAR_NAME_FOR_LIB);
 
     let wide = cfg!(all(feature = "wide", not(target_os = "macos")));
 
@@ -52,51 +58,53 @@ fn main() {
         }
     }
 
-    let mut already_printed:bool=false;
-    let lib_name:String=match std::env::var(ENV_VAR_NAME_FOR_LIB) {
+    let mut already_printed: bool = false;
+    let lib_name: String = match std::env::var(ENV_VAR_NAME_FOR_LIB) {
         Ok(x) => x,
-        _ => if let Some(ref lib)=ncurses_lib {
-            // you can get something like this ["ncurses", "tinfo"] as the lib.libs vector
-            // but we shouldn't assume "ncurses" is the first ie. lib.libs[0]
-            // and the exact name of it can be ncurses,ncursesw,ncurses5,ncursesw5 ...
-            // so find whichever it is and return that:
-            let substring_to_find = "curses";
-            if let Some(found) = lib.libs.iter().find(|&s| s.contains(substring_to_find)) {
-                //If we're here, the function calls to pkg_config::probe_library()
-                //from above ie. through find_library(), have already printed these:
-                //   cargo:rustc-link-lib=ncurses
-                //   cargo:rustc-link-lib=tinfo
-                //so there's no need to re-print the ncurses line as it would be the same.
-                already_printed=true;
-                found.clone()
-            } else {
-                //if here, we should probably panic, but who knows it might still work even without pkg-config
-
-                // Construct the repeated pkg-config command string
-                let repeated_pkg_config_command: String = ncurses_lib_names
-                    .iter()
-                    .map(|ncurses_lib_name| format!("pkg-config --libs {}", ncurses_lib_name))
-                    .collect::<Vec<_>>()
-                    .join("` or `");
-
-                // Construct the warning message string with the repeated pkg-config commands
-                let warning_message = format!(
+        _ => {
+            if let Some(ref lib) = ncurses_lib {
+                // you can get something like this ["ncurses", "tinfo"] as the lib.libs vector
+                // but we shouldn't assume "ncurses" is the first ie. lib.libs[0]
+                // and the exact name of it can be ncurses,ncursesw,ncurses5,ncursesw5 ...
+                // so find whichever it is and return that:
+                let substring_to_find = "curses";
+                if let Some(found) = lib.libs.iter().find(|&s| s.contains(substring_to_find)) {
+                    //If we're here, the function calls to pkg_config::probe_library()
+                    //from above ie. through find_library(), have already printed these:
+                    //   cargo:rustc-link-lib=ncurses
+                    //   cargo:rustc-link-lib=tinfo
+                    //so there's no need to re-print the ncurses line as it would be the same.
+                    already_printed = true;
+                    found.clone()
+                } else {
+                    //if here, we should probably panic, but who knows it might still work even without pkg-config
+
+                    // Construct the repeated pkg-config command string
+                    let repeated_pkg_config_command: String = ncurses_lib_names
+                        .iter()
+                        .map(|ncurses_lib_name| format!("pkg-config --libs {}", ncurses_lib_name))
+                        .collect::<Vec<_>>()
+                        .join("` or `");
+
+                    // Construct the warning message string with the repeated pkg-config commands
+                    let warning_message = format!(
                     "pkg_config reported that it found the ncurses libs but the substring '{}' was not among them, ie. in the output of the shell command(s) eg. `{}`",
                     substring_to_find,
                     repeated_pkg_config_command
                     );
 
-                // Print the warning message, but use old style warning with one ":" not two "::",
-                // because old cargos(pre 23 Dec 2023) will simply ignore it and show no warning if it's "::"
-                println!("cargo:warning={}", warning_message);
+                    // Print the warning message, but use old style warning with one ":" not two "::",
+                    // because old cargos(pre 23 Dec 2023) will simply ignore it and show no warning if it's "::"
+                    println!("cargo:warning={}", warning_message);
 
-                //fallback lib name: 'ncurses' or 'ncursesw'
-                //if this fails later, there's the warning above to get an idea as to why.
+                    //fallback lib name: 'ncurses' or 'ncursesw'
+                    //if this fails later, there's the warning above to get an idea as to why.
+                    ncurses_lib_names.last().unwrap().to_string()
+                }
+            } else {
+                //pkg-config didn't find the lib, fallback to 'ncurses' or 'ncursesw'
                 ncurses_lib_names.last().unwrap().to_string()
             }
-        } else {
-            //pkg-config didn't find the lib, fallback to 'ncurses' or 'ncursesw'
-            ncurses_lib_names.last().unwrap().to_string()
         }
     };
     if !already_printed {
@@ -109,8 +117,20 @@ fn main() {
 
     check_chtype_size(&ncurses_lib);
 
-    gen_rs("src/genconstants.c", "genconstants", "raw_constants.rs", &ncurses_lib, &lib_name);
-    gen_rs("src/menu/genconstants.c", "genmenuconstants", "menu_constants.rs", &ncurses_lib, &lib_name);
+    gen_rs(
+        "src/genconstants.c",
+        "genconstants",
+        "raw_constants.rs",
+        &ncurses_lib,
+        &lib_name,
+    );
+    gen_rs(
+        "src/menu/genconstants.c",
+        "genmenuconstants",
+        "menu_constants.rs",
+        &ncurses_lib,
+        &lib_name,
+    );
     build_wrap(&ncurses_lib);
 }
 
@@ -122,18 +142,31 @@ fn build_wrap(ncurses_lib: &Option<Library>) {
             build.include(path);
         }
     }
-    build.file("src/wrap.c")
-        .compile("wrap");
+    build.file("src/wrap.c").compile("wrap");
 }
 
-fn gen_rs(source_c_file:&str, out_bin_file:&str, gen_rust_file:&str, ncurses_lib: &Option<Library>, lib_name:&str) {
+fn gen_rs(
+    source_c_file: &str,
+    out_bin_file: &str,
+    gen_rust_file: &str,
+    ncurses_lib: &Option<Library>,
+    lib_name: &str,
+) {
     println!("cargo:rerun-if-changed={}", source_c_file);
     let out_dir = env::var("OUT_DIR").expect("cannot get OUT_DIR");
     let gen_rust_file_full_path = format!("{}", Path::new(&out_dir).join(gen_rust_file).display());
-    let bin = format!("{}", Path::new(&out_dir)
-                          .join(format!("{}{}",out_bin_file,if cfg!(windows) { ".exe" } else { "" })).display());
+    let bin = format!(
+        "{}",
+        Path::new(&out_dir)
+            .join(format!(
+                "{}{}",
+                out_bin_file,
+                if cfg!(windows) { ".exe" } else { "" }
+            ))
+            .display()
+    );
     let mut build = cc::Build::new();
-    let mut linker_searchdir_args=Vec::new();
+    let mut linker_searchdir_args = Vec::new();
     if let Some(lib) = ncurses_lib {
         for path in lib.include_paths.iter() {
             build.include(path);
@@ -143,38 +176,59 @@ fn gen_rs(source_c_file:&str, out_bin_file:&str, gen_rust_file:&str, ncurses_lib
             linker_searchdir_args.push(link_path.display().to_string());
         }
     }
-    let compiler = build.try_get_compiler().expect("Failed Build::try_get_compiler");
+    let compiler = build
+        .try_get_compiler()
+        .expect("Failed Build::try_get_compiler");
     let mut command = compiler.to_command();
 
     if let Ok(x) = std::env::var(ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS) {
         command.args(x.split(" "));
     }
 
-    command.arg("-o").arg(&bin).arg(source_c_file)
+    command
+        .arg("-o")
+        .arg(&bin)
+        .arg(source_c_file)
         .args(["-l", lib_name])
         .args(linker_searchdir_args);
     assert!(command.status().expect("compilation failed").success());
 
-    let consts = Command::new(&bin).output()
+    let consts = Command::new(&bin)
+        .output()
         .expect(&format!("{} failed", bin));
 
     let mut file = File::create(&gen_rust_file_full_path).unwrap_or_else(|err| {
-        panic!("Couldn't create rust file '{}', reason: '{}'", gen_rust_file_full_path, err)
+        panic!(
+            "Couldn't create rust file '{}', reason: '{}'",
+            gen_rust_file_full_path, err
+        )
     });
 
     file.write_all(&consts.stdout).unwrap_or_else(|err| {
-        panic!("Couldn't write to rust file '{}', reason: '{}'", gen_rust_file_full_path, err)
+        panic!(
+            "Couldn't write to rust file '{}', reason: '{}'",
+            gen_rust_file_full_path, err
+        )
     });
 }
 
-
 fn check_chtype_size(ncurses_lib: &Option<Library>) {
     let out_dir = env::var("OUT_DIR").expect("cannot get OUT_DIR");
     let src = format!("{}", Path::new(&out_dir).join("chtype_size.c").display());
-    let bin = format!("{}", Path::new(&out_dir).join(if cfg!(windows) { "chtype_size.exe" } else { "chtype_size" }).display());
+    let bin = format!(
+        "{}",
+        Path::new(&out_dir)
+            .join(if cfg!(windows) {
+                "chtype_size.exe"
+            } else {
+                "chtype_size"
+            })
+            .display()
+    );
 
     let mut fp = File::create(&src).expect(&format!("cannot create {}", src));
-    fp.write_all(b"
+    fp.write_all(
+        b"
 #include <assert.h>
 #include <limits.h>
 #include <stdio.h>
@@ -195,7 +249,9 @@ int main(void)
 #endif
     return 0;
 }
-    ").expect(&format!("cannot write into {}", src));
+    ",
+    )
+    .expect(&format!("cannot write into {}", src));
 
     let mut build = cc::Build::new();
     if let Some(lib) = ncurses_lib {
@@ -203,7 +259,9 @@ int main(void)
             build.include(path);
         }
     }
-    let compiler = build.try_get_compiler().expect("Failed Build::try_get_compiler");
+    let compiler = build
+        .try_get_compiler()
+        .expect("Failed Build::try_get_compiler");
     let mut command = compiler.to_command();
 
     if let Ok(x) = std::env::var(ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS) {
@@ -212,7 +270,8 @@ int main(void)
 
     command.arg("-o").arg(&bin).arg(&src);
     assert!(command.status().expect("compilation failed").success());
-    let features = Command::new(&bin).output()
+    let features = Command::new(&bin)
+        .output()
         .expect(&format!("{} failed", bin));
     print!("{}", String::from_utf8_lossy(&features.stdout));
 

From 0e46c9bc534c199b5f6eca82c598c8bfecf098c4 Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Thu, 11 Apr 2024 09:28:16 +0200
Subject: [PATCH 08/54] unnecessary format!, use .to_string

---
 build.rs | 46 ++++++++++++++++++++++++----------------------
 1 file changed, 24 insertions(+), 22 deletions(-)

diff --git a/build.rs b/build.rs
index 5345e2fc..4734cfd0 100644
--- a/build.rs
+++ b/build.rs
@@ -154,17 +154,18 @@ fn gen_rs(
 ) {
     println!("cargo:rerun-if-changed={}", source_c_file);
     let out_dir = env::var("OUT_DIR").expect("cannot get OUT_DIR");
-    let gen_rust_file_full_path = format!("{}", Path::new(&out_dir).join(gen_rust_file).display());
-    let bin = format!(
-        "{}",
-        Path::new(&out_dir)
-            .join(format!(
-                "{}{}",
-                out_bin_file,
-                if cfg!(windows) { ".exe" } else { "" }
-            ))
-            .display()
-    );
+    let gen_rust_file_full_path = Path::new(&out_dir)
+        .join(gen_rust_file)
+        .display()
+        .to_string();
+    let bin = Path::new(&out_dir)
+        .join(format!(
+            "{}{}",
+            out_bin_file,
+            if cfg!(windows) { ".exe" } else { "" }
+        ))
+        .display()
+        .to_string();
     let mut build = cc::Build::new();
     let mut linker_searchdir_args = Vec::new();
     if let Some(lib) = ncurses_lib {
@@ -214,17 +215,18 @@ fn gen_rs(
 
 fn check_chtype_size(ncurses_lib: &Option<Library>) {
     let out_dir = env::var("OUT_DIR").expect("cannot get OUT_DIR");
-    let src = format!("{}", Path::new(&out_dir).join("chtype_size.c").display());
-    let bin = format!(
-        "{}",
-        Path::new(&out_dir)
-            .join(if cfg!(windows) {
-                "chtype_size.exe"
-            } else {
-                "chtype_size"
-            })
-            .display()
-    );
+    let src = Path::new(&out_dir)
+        .join("chtype_size.c")
+        .display()
+        .to_string();
+    let bin = Path::new(&out_dir)
+        .join(if cfg!(windows) {
+            "chtype_size.exe"
+        } else {
+            "chtype_size"
+        })
+        .display()
+        .to_string();
 
     let mut fp = File::create(&src).expect(&format!("cannot create {}", src));
     fp.write_all(

From 627e812ceb0ae1949b22694094c6ce2ed5d3bfde Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Thu, 11 Apr 2024 09:31:49 +0200
Subject: [PATCH 09/54] move down var declaration

---
 build.rs | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/build.rs b/build.rs
index 4734cfd0..8c7fff3e 100644
--- a/build.rs
+++ b/build.rs
@@ -154,10 +154,6 @@ fn gen_rs(
 ) {
     println!("cargo:rerun-if-changed={}", source_c_file);
     let out_dir = env::var("OUT_DIR").expect("cannot get OUT_DIR");
-    let gen_rust_file_full_path = Path::new(&out_dir)
-        .join(gen_rust_file)
-        .display()
-        .to_string();
     let bin = Path::new(&out_dir)
         .join(format!(
             "{}{}",
@@ -198,6 +194,10 @@ fn gen_rs(
         .output()
         .expect(&format!("{} failed", bin));
 
+    let gen_rust_file_full_path = Path::new(&out_dir)
+        .join(gen_rust_file)
+        .display()
+        .to_string();
     let mut file = File::create(&gen_rust_file_full_path).unwrap_or_else(|err| {
         panic!(
             "Couldn't create rust file '{}', reason: '{}'",

From 1439cf63a1e1f003690756043ddcba80b676368b Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Thu, 11 Apr 2024 10:15:34 +0200
Subject: [PATCH 10/54] help user know why compilation might've failed

ie. one of pkg-config or pkgconf, or ncurses dev package might be
missing
---
 build.rs | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/build.rs b/build.rs
index 8c7fff3e..0b3e5660 100644
--- a/build.rs
+++ b/build.rs
@@ -102,6 +102,7 @@ fn main() {
                     ncurses_lib_names.last().unwrap().to_string()
                 }
             } else {
+                println!("cargo:warning={}", "You may not have either pkg-config or pkgconf, or ncurses installed (it's 'ncurses-devel' on Fedora). Using fallback but if compilation fails below, that's is why.");
                 //pkg-config didn't find the lib, fallback to 'ncurses' or 'ncursesw'
                 ncurses_lib_names.last().unwrap().to_string()
             }
@@ -271,7 +272,10 @@ int main(void)
     }
 
     command.arg("-o").arg(&bin).arg(&src);
-    assert!(command.status().expect("compilation failed").success());
+    assert!(
+        command.status().expect("compilation failed").success(),
+        "Is ncurses installed? pkg-config or pkgconf too? it's ncurses-devel on Fedora"
+    );
     let features = Command::new(&bin)
         .output()
         .expect(&format!("{} failed", bin));

From 5eccd8eab26aab682e7b6cfb14696b55a35889db Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Thu, 11 Apr 2024 13:10:29 +0200
Subject: [PATCH 11/54] get rid of build.rs clippy warnings

see "Why is this bad?" in:
https://rust-lang.github.io/rust-clippy/master/index.html#/print_literal
https://rust-lang.github.io/rust-clippy/master/index.html#/single_char_pattern
https://rust-lang.github.io/rust-clippy/master/index.html#/expect_fun_call

show the errors too, in .unwrap_or_else()
( .expect() was already doing this )
---
 build.rs | 21 ++++++++++++---------
 1 file changed, 12 insertions(+), 9 deletions(-)

diff --git a/build.rs b/build.rs
index 0b3e5660..311ebde0 100644
--- a/build.rs
+++ b/build.rs
@@ -102,7 +102,7 @@ fn main() {
                     ncurses_lib_names.last().unwrap().to_string()
                 }
             } else {
-                println!("cargo:warning={}", "You may not have either pkg-config or pkgconf, or ncurses installed (it's 'ncurses-devel' on Fedora). Using fallback but if compilation fails below, that's is why.");
+                println!("cargo:warning=You may not have either pkg-config or pkgconf, or ncurses installed (it's 'ncurses-devel' on Fedora). Using fallback but if compilation fails below, that's is why.");
                 //pkg-config didn't find the lib, fallback to 'ncurses' or 'ncursesw'
                 ncurses_lib_names.last().unwrap().to_string()
             }
@@ -180,7 +180,7 @@ fn gen_rs(
     let mut command = compiler.to_command();
 
     if let Ok(x) = std::env::var(ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS) {
-        command.args(x.split(" "));
+        command.args(x.split(' '));
     }
 
     command
@@ -193,7 +193,7 @@ fn gen_rs(
 
     let consts = Command::new(&bin)
         .output()
-        .expect(&format!("{} failed", bin));
+        .unwrap_or_else(|e| panic!("Executing '{}' failed, reason: '{}'", bin, e));
 
     let gen_rust_file_full_path = Path::new(&out_dir)
         .join(gen_rust_file)
@@ -229,7 +229,8 @@ fn check_chtype_size(ncurses_lib: &Option<Library>) {
         .display()
         .to_string();
 
-    let mut fp = File::create(&src).expect(&format!("cannot create {}", src));
+    let mut fp =
+        File::create(&src).unwrap_or_else(|e| panic!("cannot create '{}', reason: '{}'", src, e));
     fp.write_all(
         b"
 #include <assert.h>
@@ -254,7 +255,7 @@ int main(void)
 }
     ",
     )
-    .expect(&format!("cannot write into {}", src));
+    .unwrap_or_else(|e| panic!("cannot write into '{}', reason: '{}'", src, e));
 
     let mut build = cc::Build::new();
     if let Some(lib) = ncurses_lib {
@@ -268,7 +269,7 @@ int main(void)
     let mut command = compiler.to_command();
 
     if let Ok(x) = std::env::var(ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS) {
-        command.args(x.split(" "));
+        command.args(x.split(' '));
     }
 
     command.arg("-o").arg(&bin).arg(&src);
@@ -278,9 +279,11 @@ int main(void)
     );
     let features = Command::new(&bin)
         .output()
-        .expect(&format!("{} failed", bin));
+        .unwrap_or_else(|e| panic!("Executing '{}' failed, reason: '{}'", bin, e));
     print!("{}", String::from_utf8_lossy(&features.stdout));
 
-    std::fs::remove_file(&src).expect(&format!("cannot delete {}", src));
-    std::fs::remove_file(&bin).expect(&format!("cannot delete {}", bin));
+    std::fs::remove_file(&src)
+        .unwrap_or_else(|e| panic!("Cannot delete generated file '{}', reason: '{}'", src, e));
+    std::fs::remove_file(&bin)
+        .unwrap_or_else(|e| panic!("cannot delete compiled file '{}', reason: '{}'", bin, e));
 }

From bd907ec8511d09939f9d518ce7eecd2d0311041e Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Thu, 11 Apr 2024 14:24:36 +0200
Subject: [PATCH 12/54] typo

---
 build.rs | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/build.rs b/build.rs
index 311ebde0..7485be04 100644
--- a/build.rs
+++ b/build.rs
@@ -102,7 +102,7 @@ fn main() {
                     ncurses_lib_names.last().unwrap().to_string()
                 }
             } else {
-                println!("cargo:warning=You may not have either pkg-config or pkgconf, or ncurses installed (it's 'ncurses-devel' on Fedora). Using fallback but if compilation fails below, that's is why.");
+                println!("cargo:warning=You may not have either pkg-config or pkgconf, or ncurses installed (it's 'ncurses-devel' on Fedora). Using fallback but if compilation fails below, that is why.");
                 //pkg-config didn't find the lib, fallback to 'ncurses' or 'ncursesw'
                 ncurses_lib_names.last().unwrap().to_string()
             }

From 22ede03dc1f5e80ef3797f99c0dab4f80021ecea Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Thu, 11 Apr 2024 22:24:59 +0200
Subject: [PATCH 13/54] avoid a false positive warning

---
 src/menu/wrapper.rs | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/src/menu/wrapper.rs b/src/menu/wrapper.rs
index b5d72ecc..54016c6b 100644
--- a/src/menu/wrapper.rs
+++ b/src/menu/wrapper.rs
@@ -1,5 +1,6 @@
 #![allow(dead_code)]
 #![allow(unused_imports)]
+#![warn(temporary_cstring_as_ptr)] // false positives? https://github.com/rust-lang/rust/issues/78691
 
 use std::str;
 use std::ptr;
@@ -412,7 +413,8 @@ pub fn unpost_menu(menu: MENU) -> i32 {
 #[cfg(feature="menu")]
 pub fn menu_request_by_name<T: Into<Vec<u8>>>(name: T) -> i32 {
   unsafe {
-    super::ll::menu_request_by_name(CString::new(name).unwrap().as_ptr())
+    let cs=CString::new(name).unwrap();
+    super::ll::menu_request_by_name(cs.as_ptr())
   }
 }
 

From 344549e2333de5310393f3b84ece4dc11703de4b Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Thu, 11 Apr 2024 22:40:12 +0200
Subject: [PATCH 14/54] fix warnings from cargo test --all-features

it's safe to unwrap() in these cases, unless the data changes in the
future.
---
 examples/ex_5.rs | 7 ++++---
 examples/ex_7.rs | 4 ++--
 2 files changed, 6 insertions(+), 5 deletions(-)

diff --git a/examples/ex_5.rs b/examples/ex_5.rs
index 16658af4..a5100bc0 100644
--- a/examples/ex_5.rs
+++ b/examples/ex_5.rs
@@ -38,8 +38,8 @@ fn main() {
 
   /* Print a border around the main window */
   box_(my_menu_win, 0, 0);
-  mvprintw(LINES() - 3, 0, "Press <ENTER> to see the option selected");
-  mvprintw(LINES() - 2, 0, "F1 to exit");
+  mvprintw(LINES() - 3, 0, "Press <ENTER> to see the option selected").unwrap();//safe
+  mvprintw(LINES() - 2, 0, "F1 to exit").unwrap(); //safe
   refresh();
 
   /* Post the menu */
@@ -60,7 +60,8 @@ fn main() {
       10 => {/* Enter */
         mv(20, 0);
         clrtoeol();
-        mvprintw(20, 0, &format!("Item selected is : {}", item_name(current_item(my_menu)))[..]);
+        mvprintw(20, 0, &format!("Item selected is : {}", item_name(current_item(my_menu)))[..]).unwrap();
+        //unwrap() here is safe unless the items have any \0 (nul) char in them, then it will panic!
         pos_menu_cursor(my_menu);
       },
       _ => {}
diff --git a/examples/ex_7.rs b/examples/ex_7.rs
index f1b802a2..e4101e48 100644
--- a/examples/ex_7.rs
+++ b/examples/ex_7.rs
@@ -17,7 +17,7 @@ use ncurses::*;
 fn main()
 {
   let locale_conf = LcCategory::all;
-  setlocale(locale_conf, "en_US.UTF-8");
+  setlocale(locale_conf, "en_US.UTF-8").unwrap();//safe due to this &str having no \0 in it
 
   /* Setup ncurses. */
   initscr();
@@ -56,7 +56,7 @@ fn main()
 
     Some(WchResult::Char(c)) => {
       /* Enable attributes and output message. */
-      addstr("\nKey pressed: ");
+      addstr("\nKey pressed: ").unwrap();//safe, no \0 in this &str
       attron(A_BOLD | A_BLINK);
       addstr(format!("{}\n", char::from_u32(c as u32).expect("Invalid char")).as_ref()).unwrap();
       attroff(A_BOLD | A_BLINK);

From 2f143fce0aab89e24fc9b11dbe73e6eb8cb573ea Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Thu, 11 Apr 2024 23:26:01 +0200
Subject: [PATCH 15/54] `pkgs.pkg-config` is needed on NixOS

else this will fail to find `menu` lib:
$ nix-shell
$ cargo test --features=menu
unless you'd do it like this:
$ RUSTFLAGS='-l menu' cargo test --features=menu

This was true even before PR #218
---
 shell.nix | 1 +
 1 file changed, 1 insertion(+)

diff --git a/shell.nix b/shell.nix
index 0442e4b3..d93077fb 100644
--- a/shell.nix
+++ b/shell.nix
@@ -5,6 +5,7 @@ pkgs.stdenv.mkDerivation
   name = "ncurses-rs";
   buildInputs = with pkgs;
   [
+    pkgs.pkg-config
     pkgs.cargo
     pkgs.rustup
     pkgs.rustfmt

From b11c39825501f6fc8741a0484d691745352e2277 Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Sat, 13 Apr 2024 00:21:18 +0200
Subject: [PATCH 16/54] use latest cc-rs (1.0.92) for build.rs

---
 Cargo.toml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/Cargo.toml b/Cargo.toml
index a2b2d6f7..206dbfd2 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -12,7 +12,7 @@ license = "MIT"
 build = "build.rs"
 
 [build-dependencies]
-cc = "1.0.18"
+cc = "1.0.92"
 pkg-config = "0.3"
 
 [dependencies]

From 6a035d6f1201b4f034e9335ffe994d1035184257 Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Sat, 13 Apr 2024 17:34:15 +0200
Subject: [PATCH 17/54] use ncurses(6) instead of 5 on NixOS

this allows using the same 'nix-shell' to compile pancurses too, without
awkward compile errors, like:
  error[E0425]: cannot find value `BUTTON5_PRESSED` in crate `ncurses`
---
 shell.nix | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/shell.nix b/shell.nix
index d93077fb..d47cc2f9 100644
--- a/shell.nix
+++ b/shell.nix
@@ -9,6 +9,6 @@ pkgs.stdenv.mkDerivation
     pkgs.cargo
     pkgs.rustup
     pkgs.rustfmt
-    pkgs.ncurses5
+    pkgs.ncurses
   ];
 }

From e7e23633169928fc8f66a777d8c4ae308c2d30f4 Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Sat, 13 Apr 2024 18:18:33 +0200
Subject: [PATCH 18/54] revamp build.rs to be better at error reporting

This makes it easier to see what happened if an error happens in
build.rs

Plus other improvements that I don't remember.

Some comments added to get an idea what's happening.

To ensure some functionality inside build.rs works as expected,
run inner build.rs "tests" via command:
cargo build --features=test_build_rs_of_ncurses_rs
---
 Cargo.toml |   4 +
 build.rs   | 724 ++++++++++++++++++++++++++++++++++++++++++++---------
 2 files changed, 605 insertions(+), 123 deletions(-)

diff --git a/Cargo.toml b/Cargo.toml
index 206dbfd2..96a1d791 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -30,5 +30,9 @@ wide_chtype = []
 mouse_v1 = []
 extended_colors = ["wide"]
 
+#Internal features used in 'build.rs' only:
+test_build_rs_of_ncurses_rs = []
+dummy_feature_to_detect_that_--all-features_arg_was_used= []
+
 [lib]
 name = "ncurses"
diff --git a/build.rs b/build.rs
index 7485be04..5ca39e70 100644
--- a/build.rs
+++ b/build.rs
@@ -1,17 +1,59 @@
+// To test some of build.rs' code correctness run:
+// cargo build --features=test_build_rs_of_ncurses_rs
+// when doing that, the following cfg_attr ensures there are no warnings about unused stuff.
+#![cfg_attr(
+    all(
+        feature = "test_build_rs_of_ncurses_rs",
+        not(feature = "dummy_feature_to_detect_that_--all-features_arg_was_used")
+    ),
+    allow(dead_code)
+)]
+#![allow(clippy::uninlined_format_args)] // or is it more readable inlined?
+
 extern crate cc;
 extern crate pkg_config;
 
 use pkg_config::Library;
 use std::env;
+use std::ffi::OsStr;
+use std::ffi::OsString;
 use std::fs::File;
 use std::io::Write;
+use std::os::unix::ffi::OsStrExt;
+use std::os::unix::ffi::OsStringExt;
 use std::path::Path;
 use std::process::Command;
+use std::process::ExitStatus;
 
-const ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS: &str = "NCURSES_RS_CFLAGS";
+// Optional environment variables:
+
+// The below doc comment doesn't apply for these 2 env.vars:
 const ENV_VAR_NAME_FOR_LIB: &str = "NCURSES_RS_RUSTC_LINK_LIB";
 const ENV_VAR_NAME_FOR_NCURSES_RS_RUSTC_FLAGS: &str = "NCURSES_RS_RUSTC_FLAGS";
 
+/// Assuming we want env.var "NCURSES_RS_CFLAGS" here,
+/// and target==host and is "x86_64-unknown-linux-gnu"
+/// then calls to Build::try_flags_from_environment() below in code,
+/// will try the following env.vars in this order:
+/// 1. "NCURSES_RS_CFLAGS_x86_64-unknown-linux-gnu" (notice dashes)
+/// 2. "NCURSES_RS_CFLAGS_x86_64_unknown_linux_gnu" (notice underscores)
+/// 3. "HOST_NCURSES_RS_CFLAGS" or "TARGET_NCURSES_RS_CFLAGS" (if target!=host)
+/// 4. "NCURSES_RS_CFLAGS" (our original wanted)
+/// and the first one that exists is used instead.
+/// see: https://docs.rs/cc/1.0.92/src/cc/lib.rs.html#3571-3580
+const ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS: &str = "NCURSES_RS_CFLAGS";
+
+const IS_WIDE: bool = cfg!(all(feature = "wide", not(target_os = "macos")));
+
+// will search for these and if not found
+// then the last one in list will be used as fallback
+// and still try linking with it eg. -lncursesw
+const NCURSES_LIB_NAMES: &[&str] = if IS_WIDE {
+    &["ncursesw5", "ncursesw"]
+} else {
+    &["ncurses5", "ncurses"]
+};
+
 fn find_library(names: &[&str]) -> Option<Library> {
     for name in names {
         if let Ok(lib) = pkg_config::probe_library(name) {
@@ -20,30 +62,25 @@ fn find_library(names: &[&str]) -> Option<Library> {
     }
     None
 }
-
+// -----------------------------------------------------------------
+// This is the normal build.rs main(),
+// it's only disabled when you used: `cargo build --feature=test_build_rs_of_ncurses_rs`
+#[cfg(any(
+    not(feature = "test_build_rs_of_ncurses_rs"),
+    feature = "dummy_feature_to_detect_that_--all-features_arg_was_used"
+))]
 fn main() {
     println!("cargo:rerun-if-env-changed=PKG_CONFIG_PATH");
-    println!(
-        "cargo:rerun-if-env-changed={}",
-        ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS
-    );
     println!(
         "cargo:rerun-if-env-changed={}",
         ENV_VAR_NAME_FOR_NCURSES_RS_RUSTC_FLAGS
     );
     println!("cargo:rerun-if-env-changed={}", ENV_VAR_NAME_FOR_LIB);
 
-    let wide = cfg!(all(feature = "wide", not(target_os = "macos")));
-
-    let ncurses_lib_names = if wide {
-        &["ncursesw5", "ncursesw"]
-    } else {
-        &["ncurses5", "ncurses"]
-    };
-    let ncurses_lib = find_library(ncurses_lib_names);
+    let ncurses_lib = find_library(NCURSES_LIB_NAMES);
 
     if cfg!(feature = "menu") {
-        if wide {
+        if IS_WIDE {
             find_library(&["menuw5", "menuw"]);
         } else {
             find_library(&["menu5", "menu"]);
@@ -51,66 +88,16 @@ fn main() {
     }
 
     if cfg!(feature = "panel") {
-        if wide {
+        if IS_WIDE {
             find_library(&["panelw5", "panelw"]);
         } else {
             find_library(&["panel5", "panel"]);
         }
     }
 
-    let mut already_printed: bool = false;
-    let lib_name: String = match std::env::var(ENV_VAR_NAME_FOR_LIB) {
-        Ok(x) => x,
-        _ => {
-            if let Some(ref lib) = ncurses_lib {
-                // you can get something like this ["ncurses", "tinfo"] as the lib.libs vector
-                // but we shouldn't assume "ncurses" is the first ie. lib.libs[0]
-                // and the exact name of it can be ncurses,ncursesw,ncurses5,ncursesw5 ...
-                // so find whichever it is and return that:
-                let substring_to_find = "curses";
-                if let Some(found) = lib.libs.iter().find(|&s| s.contains(substring_to_find)) {
-                    //If we're here, the function calls to pkg_config::probe_library()
-                    //from above ie. through find_library(), have already printed these:
-                    //   cargo:rustc-link-lib=ncurses
-                    //   cargo:rustc-link-lib=tinfo
-                    //so there's no need to re-print the ncurses line as it would be the same.
-                    already_printed = true;
-                    found.clone()
-                } else {
-                    //if here, we should probably panic, but who knows it might still work even without pkg-config
-
-                    // Construct the repeated pkg-config command string
-                    let repeated_pkg_config_command: String = ncurses_lib_names
-                        .iter()
-                        .map(|ncurses_lib_name| format!("pkg-config --libs {}", ncurses_lib_name))
-                        .collect::<Vec<_>>()
-                        .join("` or `");
-
-                    // Construct the warning message string with the repeated pkg-config commands
-                    let warning_message = format!(
-                    "pkg_config reported that it found the ncurses libs but the substring '{}' was not among them, ie. in the output of the shell command(s) eg. `{}`",
-                    substring_to_find,
-                    repeated_pkg_config_command
-                    );
-
-                    // Print the warning message, but use old style warning with one ":" not two "::",
-                    // because old cargos(pre 23 Dec 2023) will simply ignore it and show no warning if it's "::"
-                    println!("cargo:warning={}", warning_message);
-
-                    //fallback lib name: 'ncurses' or 'ncursesw'
-                    //if this fails later, there's the warning above to get an idea as to why.
-                    ncurses_lib_names.last().unwrap().to_string()
-                }
-            } else {
-                println!("cargo:warning=You may not have either pkg-config or pkgconf, or ncurses installed (it's 'ncurses-devel' on Fedora). Using fallback but if compilation fails below, that is why.");
-                //pkg-config didn't find the lib, fallback to 'ncurses' or 'ncursesw'
-                ncurses_lib_names.last().unwrap().to_string()
-            }
-        }
-    };
-    if !already_printed {
-        println!("cargo:rustc-link-lib={}", lib_name);
-    }
+    // gets the name of ncurses lib found by pkg-config, if it found any!
+    // else (warns and)returns the default one like 'ncurses' or 'ncursesw'
+    let lib_name = get_ncurses_lib_name(&ncurses_lib);
 
     if let Ok(x) = std::env::var(ENV_VAR_NAME_FOR_NCURSES_RS_RUSTC_FLAGS) {
         println!("cargo:rustc-flags={}", x);
@@ -125,6 +112,7 @@ fn main() {
         &ncurses_lib,
         &lib_name,
     );
+
     gen_rs(
         "src/menu/genconstants.c",
         "genmenuconstants",
@@ -132,20 +120,26 @@ fn main() {
         &ncurses_lib,
         &lib_name,
     );
+
     build_wrap(&ncurses_lib);
 }
+// -----------------------------------------------------------------
 
 fn build_wrap(ncurses_lib: &Option<Library>) {
     println!("cargo:rerun-if-changed=src/wrap.c");
     let mut build = cc::Build::new();
     if let Some(lib) = ncurses_lib {
-        for path in lib.include_paths.iter() {
-            build.include(path);
-        }
+        build.includes(&lib.include_paths);
+        //for path in lib.include_paths.iter() {
+        //    build.include(path);
+        //}
     }
+    // The following creates `libwrap.a` on linux
     build.file("src/wrap.c").compile("wrap");
 }
 
+/// Compiles a .c file then generates a .rs file from its output.
+/// Uses ncurses include paths and links with ncurses lib(s)
 fn gen_rs(
     source_c_file: &str,
     out_bin_file: &str,
@@ -155,46 +149,58 @@ fn gen_rs(
 ) {
     println!("cargo:rerun-if-changed={}", source_c_file);
     let out_dir = env::var("OUT_DIR").expect("cannot get OUT_DIR");
-    let bin = Path::new(&out_dir)
-        .join(format!(
-            "{}{}",
-            out_bin_file,
-            if cfg!(windows) { ".exe" } else { "" }
-        ))
-        .display()
-        .to_string();
+    #[cfg(windows)]
+    let out_bin_file = format!("{}.exe", out_bin_file);
+    let bin_full = Path::new(&out_dir).join(out_bin_file).display().to_string();
+
+    //Note: env.var. "CC" can override the compiler used and will cause rebuild if changed.
     let mut build = cc::Build::new();
-    let mut linker_searchdir_args = Vec::new();
+    let mut linker_searchdir_args: Vec<String> = Vec::new();
     if let Some(lib) = ncurses_lib {
-        for path in lib.include_paths.iter() {
-            build.include(path);
-        }
+        build.includes(&lib.include_paths);
+        //for path in lib.include_paths.iter() {
+        //    build.include(path);
+        //}
         for link_path in &lib.link_paths {
             linker_searchdir_args.push("-L".to_string());
             linker_searchdir_args.push(link_path.display().to_string());
         }
     }
+
+    println!(
+        "cargo:rerun-if-env-changed={}",
+        ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS
+    );
+
+    let _ = build.try_flags_from_environment(ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS);
+
+    //'cc::Build' can do only lib outputs but we want a binary
+    //so we get the command (and args) thus far set and add our own args.
+    //Presumably all args will be kept, as per: https://docs.rs/cc/1.0.92/cc/struct.Build.html#method.get_compiler
+    //(though at least the setting for build.file(source_c_file) won't be,
+    // but we don't use that way and instead set it later as an arg to compiler)
     let compiler = build
         .try_get_compiler()
         .expect("Failed Build::try_get_compiler");
     let mut command = compiler.to_command();
 
-    if let Ok(x) = std::env::var(ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS) {
-        command.args(x.split(' '));
-    }
-
+    //create a bin(not a lib) from a .c file
+    //adding the relevant args for the libs that we depend upon such as ncurses
     command
         .arg("-o")
-        .arg(&bin)
-        .arg(source_c_file)
-        .args(["-l", lib_name])
-        .args(linker_searchdir_args);
-    assert!(command.status().expect("compilation failed").success());
-
-    let consts = Command::new(&bin)
+        .arg_checked(&bin_full)
+        .arg_checked(source_c_file)
+        .args_checked(["-l", lib_name])
+        .args_checked(linker_searchdir_args);
+    command.success_or_panic(); //runs compiler
+
+    //execute the compiled binary
+    let consts = Command::new(&bin_full)
         .output()
-        .unwrap_or_else(|e| panic!("Executing '{}' failed, reason: '{}'", bin, e));
+        .unwrap_or_else(|err| panic!("Executing '{}' failed, reason: '{}'", bin_full, err));
 
+    //write the output from executing the binary into a new rust source file .rs
+    //that .rs file is later used outside of this build.rs, in the normal build
     let gen_rust_file_full_path = Path::new(&out_dir)
         .join(gen_rust_file)
         .display()
@@ -220,17 +226,15 @@ fn check_chtype_size(ncurses_lib: &Option<Library>) {
         .join("chtype_size.c")
         .display()
         .to_string();
-    let bin = Path::new(&out_dir)
-        .join(if cfg!(windows) {
-            "chtype_size.exe"
-        } else {
-            "chtype_size"
-        })
-        .display()
-        .to_string();
+    let bin_name = if cfg!(windows) {
+        "chtype_size.exe"
+    } else {
+        "chtype_size"
+    };
+    let bin_full = Path::new(&out_dir).join(bin_name).display().to_string();
 
-    let mut fp =
-        File::create(&src).unwrap_or_else(|e| panic!("cannot create '{}', reason: '{}'", src, e));
+    let mut fp = File::create(&src)
+        .unwrap_or_else(|err| panic!("cannot create '{}', reason: '{}'", src, err));
     fp.write_all(
         b"
 #include <assert.h>
@@ -255,35 +259,509 @@ int main(void)
 }
     ",
     )
-    .unwrap_or_else(|e| panic!("cannot write into '{}', reason: '{}'", src, e));
+    .unwrap_or_else(|err| panic!("cannot write into file '{}', reason: '{}'", src, err));
 
     let mut build = cc::Build::new();
     if let Some(lib) = ncurses_lib {
-        for path in lib.include_paths.iter() {
-            build.include(path);
-        }
+        build.includes(&lib.include_paths);
+        //for path in lib.include_paths.iter() {
+        //    build.include(path);
+        //}
     }
+
+    let _ = build.try_flags_from_environment(ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS);
+
     let compiler = build
         .try_get_compiler()
         .expect("Failed Build::try_get_compiler");
     let mut command = compiler.to_command();
 
-    if let Ok(x) = std::env::var(ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS) {
-        command.args(x.split(' '));
-    }
+    command.arg("-o").arg_checked(&bin_full).arg_checked(&src);
+    command.success_or_panic(); //runs compiler
 
-    command.arg("-o").arg(&bin).arg(&src);
-    assert!(
-        command.status().expect("compilation failed").success(),
-        "Is ncurses installed? pkg-config or pkgconf too? it's ncurses-devel on Fedora"
-    );
-    let features = Command::new(&bin)
+    let features = Command::new(&bin_full)
         .output()
-        .unwrap_or_else(|e| panic!("Executing '{}' failed, reason: '{}'", bin, e));
+        .unwrap_or_else(|err| panic!("Executing '{}' failed, reason: '{}'", bin_full, err));
     print!("{}", String::from_utf8_lossy(&features.stdout));
 
     std::fs::remove_file(&src)
-        .unwrap_or_else(|e| panic!("Cannot delete generated file '{}', reason: '{}'", src, e));
-    std::fs::remove_file(&bin)
-        .unwrap_or_else(|e| panic!("cannot delete compiled file '{}', reason: '{}'", bin, e));
+        .unwrap_or_else(|err| panic!("Cannot delete generated file '{}', reason: '{}'", src, err));
+    std::fs::remove_file(&bin_full).unwrap_or_else(|err| {
+        panic!(
+            "cannot delete compiled file '{}', reason: '{}'",
+            bin_full, err
+        )
+    });
+}
+
+//call this only once
+fn get_ncurses_lib_name(ncurses_lib: &Option<Library>) -> String {
+    let mut already_printed: bool = false;
+    let lib_name: String = match std::env::var(ENV_VAR_NAME_FOR_LIB) {
+        Ok(value) => value,
+        Err(_) => {
+            if let Some(ref lib) = ncurses_lib {
+                // if here, `pkg-config`(shell command) via pkg_config crate,
+                // has found the ncurses lib (eg. via the `ncurses.pc` file)
+                // You can get something like this ["ncurses", "tinfo"] as the lib.libs vector
+                // but we shouldn't assume "ncurses" is the first ie. lib.libs[0]
+                // and the exact name of it can be ncurses,ncursesw,ncurses5,ncursesw5 ...
+                // so find whichever it is and return that:
+                let substring_to_find = "curses";
+                if let Some(found) = lib.libs.iter().find(|&s| s.contains(substring_to_find)) {
+                    //If we're here, the function calls to pkg_config::probe_library()
+                    //from above ie. through find_library(), have already printed these:
+                    //   cargo:rustc-link-lib=ncurses
+                    //   cargo:rustc-link-lib=tinfo
+                    //so there's no need to re-print the ncurses line as it would be the same.
+                    already_printed = true;
+                    found.clone()
+                } else {
+                    //if here, we should probably panic, but who knows it might still work even without pkg-config
+                    //I've found cases where we were here and it still worked, so don't panic!
+
+                    // Construct the repeated pkg-config command string
+                    let repeated_pkg_config_command: String = NCURSES_LIB_NAMES
+                        .iter()
+                        .map(|ncurses_lib_name| format!("pkg-config --libs {}", ncurses_lib_name))
+                        .collect::<Vec<_>>()
+                        .join("` or `");
+
+                    // Construct the warning message string with the repeated pkg-config commands
+                    let warning_message = format!(
+                    "pkg_config reported that it found the ncurses libs but the substring '{}' was not among them, ie. in the output of the shell command(s) eg. `{}`",
+                    substring_to_find,
+                    repeated_pkg_config_command
+                    );
+
+                    // Print the warning message, but use old style warning with one ":" not two "::",
+                    // because old cargos(pre 23 Dec 2023) will simply ignore it and show no warning if it's "::"
+                    println!("cargo:warning={}", warning_message);
+
+                    //fallback lib name: 'ncurses' or 'ncursesw'
+                    //if this fails later, there's the warning above to get an idea as to why.
+                    (*NCURSES_LIB_NAMES.last().unwrap()).to_string()
+                }
+            } else {
+                println!("cargo:warning=You may not have either pkg-config or pkgconf, or ncurses installed (it's 'ncurses-devel' on Fedora). Using fallback but if compilation fails below, that is why.");
+                //pkg-config didn't find the lib, fallback to 'ncurses' or 'ncursesw'
+                (*NCURSES_LIB_NAMES.last().unwrap()).to_string()
+            }
+        }
+    };
+    if !already_printed {
+        println!("cargo:rustc-link-lib={}", lib_name);
+    }
+    lib_name
+}
+
+// Define an extension trait for Command
+trait MyCompilerCommand {
+    fn success_or_panic(&mut self) -> ExitStatus;
+    //fn success_or_else<F: FnOnce(ExitStatus) -> ExitStatus>(&mut self, op: F) -> ExitStatus;
+    fn status_or_panic(&mut self) -> ExitStatus;
+    fn show_what_will_run(&mut self) -> &mut Self;
+    fn get_what_will_run(&self) -> (String, usize, String);
+    fn assert_no_nul_in_args(&mut self) -> &mut Self;
+    /// Panics if arg has \0 in it.
+    fn args_checked<I, S>(&mut self, args: I) -> &mut Command
+    where
+        I: IntoIterator<Item = S>,
+        S: AsRef<OsStr>;
+    /// Panics if arg has \0 aka NUL in it,
+    /// otherwise the original Command::arg would've set it to "<string-with-nul>"
+    /// Doesn't do any other checks, passes it to Command::arg()
+    fn arg_checked<S: AsRef<OsStr>>(&mut self, arg: S) -> &mut Command;
+}
+
+fn has_null_byte<S: AsRef<OsStr>>(arg: S) -> bool {
+    let os_str = arg.as_ref();
+    for &byte in os_str.as_bytes() {
+        if byte == 0 {
+            return true;
+        }
+    }
+    false
+}
+
+/// args with \0 in them, passed to std::process::Command::arg() or ::args()
+/// get replaced entirely with this: "<string-with-nul>"
+const REPLACEMENT_FOR_ARG_THAT_HAS_NUL: &str = "<string-with-nul>";
+// Implement the extension trait for Command
+impl MyCompilerCommand for Command {
+    /// you can't use an arg value "<string-with-nul>", or this will panic.
+    fn success_or_panic(&mut self) -> ExitStatus {
+        let exit_status: ExitStatus = self
+            .show_what_will_run()
+            .assert_no_nul_in_args()
+            .status_or_panic();
+        if exit_status.success() {
+            exit_status
+        } else {
+            let how: String;
+            if let Some(code) = exit_status.code() {
+                how = format!(" with exit code {}", code);
+            } else {
+                how = ", was terminated by a signal".to_string();
+            }
+            panic!(
+                "Compiler failed{}. Is ncurses installed? \
+        pkg-config or pkgconf too? \
+        it's 'ncurses-devel' on Fedora; \
+        run `nix-shell` first, on NixOS. \
+        Or maybe it failed for different reasons which are seen in the errored output above.",
+                how
+            )
+        }
+    }
+    //note: can't override arg/args because they're not part of a Trait in Command
+    //so would've to wrap Command in my own struct for that. This would've ensured
+    //that any added args were auto-checked.
+    fn args_checked<I, S>(&mut self, args: I) -> &mut Command
+    where
+        I: IntoIterator<Item = S>,
+        S: AsRef<OsStr>,
+    {
+        for arg in args {
+            self.arg_checked(arg.as_ref());
+        }
+        self
+    }
+    fn arg_checked<S: AsRef<OsStr>>(&mut self, arg: S) -> &mut Command {
+        if has_null_byte(&arg) {
+            //If the arg has NUL ie. \0  in it then arg got replaced already
+            //with "<string-with-nul>", internally, by std::process::Command::arg() .
+            //The found arg here will be shown with \0 in this Debug way.
+            panic!(
+                "Found arg '{:?}' that has at least one \\0 aka nul in it! \
+                   This would've been replaced with '{}'.",
+                arg.as_ref(),
+                REPLACEMENT_FOR_ARG_THAT_HAS_NUL
+            );
+        }
+        self.arg(arg)
+    }
+    /// Beware if user set the arg on purpose to the value of REPLACEMENT_FOR_ARG_THAT_HAS_NUL
+    /// which is "<string-with-nul>" then this will panic, it's a false positive.
+    fn assert_no_nul_in_args(&mut self) -> &mut Self {
+        let args = self.get_args();
+        for (count, arg) in args.enumerate() {
+            if let Some(fully_utf8_arg) = arg.to_str() {
+                //If the arg had NUL ie. \0  in it then arg got replaced already
+                //with "<string-with-nul>", internally, by std::process::Command::arg() .
+                if fully_utf8_arg == REPLACEMENT_FOR_ARG_THAT_HAS_NUL {
+                    panic!(
+                        "Found arg number '{}' that has \\0 aka NUL in it! \
+                           It got replaced with '{}'.",
+                        count + 1,
+                        REPLACEMENT_FOR_ARG_THAT_HAS_NUL
+                    );
+                }
+            }
+        }
+        self
+    }
+    fn get_what_will_run(&self) -> (String, usize, String) {
+        let program = self.get_program();
+        let p_prog = program
+            .to_str()
+            .unwrap_or_else(|| panic!("Compiler executable {:?} isn't valid rust string", program));
+        let args = self.get_args();
+        let how_many_args: usize = args.len();
+        let formatted_args: String = args
+            .map(|arg| {
+                //If the arg had NUL ie. \0  in it then arg got replaced already
+                //with "<string-with-nul>", internally, by std::process::Command::arg()
+                //if it was added via Command::arg() or Command::args().
+                //To prevent that use Command::arg_checked() and ::args_checked()
+                if let Some(fully_utf8_arg) = arg.to_str() {
+                    fully_utf8_arg.to_string()
+                } else {
+                    //None aka not fully utf8 arg
+                    //then we show it as ascii + hex
+                    let mut broken_arg = String::new();
+                    use std::fmt::Write; // can't globally import this ^, conflicts with std::io::Write
+                    for byte in arg.as_bytes() {
+                        match std::char::from_u32(*byte as u32) {
+                            Some(c) if c.is_ascii() => broken_arg.push(c),
+                            _ => {
+                                write!(&mut broken_arg, "\\x{:02X}", byte).expect("Failed to write")
+                            }
+                        }
+                    }
+                    broken_arg
+                }
+            })
+            .collect::<Vec<String>>()
+            .join("\" \"");
+        //TODO: maybe a better way to get the args as a Vec<String> and impl Display ? but not
+        //for the generic Vec<String> i think. Then, we won't have to return how_many_args!
+
+        //return this tuple
+        (
+            p_prog.to_string(),
+            how_many_args,
+            format!("\"{}\"", formatted_args),
+        )
+    }
+    /// just like Command::status() but panics if it can't execute it,
+    /// ie. if status() would've returned an Err
+    /// returns ExitStatus whether it be 0 or !=0
+    fn status_or_panic(&mut self) -> ExitStatus {
+        // Call the original status() method and handle the potential error
+        self.status().unwrap_or_else(|err| {
+            let (p_prog, how_many_args, formatted_args) = self.get_what_will_run();
+            panic!(
+                "Failed to run compilation command '{}' with '{}' args: '{}', reason: '{}'",
+                p_prog, how_many_args, formatted_args, err
+            )
+        })
+    }
+    fn show_what_will_run(&mut self) -> &mut Self {
+        let (exe_name, how_many_args, formatted_args) = self.get_what_will_run();
+        eprintln!(
+            "Next, attempting to run compilation command '{}' with '{}' args: '{}'",
+            exe_name, how_many_args, formatted_args
+        );
+        self
+    }
+}
+
+/// This is used to test build.rs, run with: cargo build --features=test_build_rs_of_ncurses_rs
+/// This won't happen if you use --all-features
+#[cfg(all(
+    feature = "test_build_rs_of_ncurses_rs",
+    not(feature = "dummy_feature_to_detect_that_--all-features_arg_was_used")
+))]
+fn main() {
+    test_assert_works();
+    test_invalid_utf8_in_program();
+    test_nul_in_arg_unchecked();
+    test_nul_in_arg();
+    test_no_panic_in_command();
+    test_panic_for_not_found_command();
+    test_panic_for_command_non_zero_exit();
+    test_get_what_will_run();
+    test_assert_no_nul_in_args();
+
+    eprintln!("\n-------------------------------------
+              \n!!! All build.rs tests have passed successfully! Ignore the above seemingly erroneous output, it was part of the successful testing !!!\nYou're seeing this because you tried to build with --features=test_build_rs_of_ncurses_rs");
+
+    // This stops the build from continuing which will fail in other places due to build.rs not
+    // doing its job, since we've only just tested build.rs not used it to generate stuff.
+    std::process::exit(5);
+}
+//The test functions are left outside of 'test_build_rs_of_ncurses_rs' feature gate
+//so that they're tested to still compile ok.
+
+#[allow(dead_code)]
+fn test_assert_works() {
+    let result = std::panic::catch_unwind(|| {
+        #[allow(clippy::assertions_on_constants)]
+        {
+            assert!(false, "!! just tested if asserts are enabled !!");
+        }
+    });
+    #[allow(clippy::manual_assert)]
+    if result.is_ok() {
+        panic!("Assertions are disabled in build.rs, should not happen!");
+    }
+}
+
+#[allow(dead_code)]
+fn test_no_panic_in_command() {
+    let expected_ec = 42;
+    let cmd = if cfg!(windows) { "cmd" } else { "sh" };
+    let args_ok = &["-c", "exit 0"];
+    let args_fail = &["-c", &format!("exit {}", expected_ec)];
+    let result = std::panic::catch_unwind(|| {
+        let mut command = Command::new(cmd);
+        command.args(args_ok);
+        //execute: sh -c 'exit 0'`
+        command.status_or_panic();
+    });
+    let fail_msg = format!(
+        "!!! This should not have panicked! Unless you don't have '{}' command, in PATH={:?} !!!",
+        cmd,
+        std::env::var("PATH")
+    );
+    assert!(result.is_ok(), "{}", fail_msg);
+
+    // executed bin exits with exit code 0, or it would panic ie. fail the test
+    let result = std::panic::catch_unwind(|| {
+        let mut command = Command::new(cmd);
+        command.args(args_ok);
+        //execute: sh -c 'exit 0'`
+        command.success_or_panic();
+    });
+    assert!(result.is_ok(), "{}", fail_msg);
+
+    // executed bin exits with specific exit code 2
+    let result = std::panic::catch_unwind(|| {
+        let mut command = Command::new(cmd);
+        command.args(args_fail);
+        //execute: sh -c 'exit 42'`
+        let exit_status = command.status_or_panic();
+        assert_eq!(
+            exit_status.code().expect("was command killed by a signal?"),
+            expected_ec,
+            "Command should've exited with exit code '{}'.",
+            expected_ec
+        );
+    });
+    assert!(result.is_ok(), "{}", fail_msg);
+}
+
+#[allow(dead_code)]
+fn test_panic_for_not_found_command() {
+    let result = std::panic::catch_unwind(|| {
+        let mut command = Command::new("some non-exitent command");
+        command.args([OsString::from("arg1")]);
+        command.status_or_panic();
+    });
+    let expected_panic_msg=
+     "Failed to run compilation command 'some non-exitent command' with '1' args: '\"arg1\"', reason: 'No such file or directory (os error 2)'";
+    expect_panic(result, expected_panic_msg);
+
+    let result = std::panic::catch_unwind(|| {
+        let mut command = Command::new("some non-exitent command");
+        command.args([OsString::from("arg1")]);
+        command.success_or_panic();
+    });
+    expect_panic(result, expected_panic_msg);
+}
+
+#[allow(dead_code)]
+fn test_panic_for_command_non_zero_exit() {
+    let cmd = if cfg!(windows) { "cmd" } else { "sh" };
+    let args_fail = &["-c", &format!("exit 43")];
+    let result = std::panic::catch_unwind(|| {
+        let mut command = Command::new(cmd);
+        command.args(args_fail);
+        command.success_or_panic();
+    });
+    let expected_panic_msg = "Compiler failed with exit code 43. Is ncurses installed? pkg-config or pkgconf too? it's 'ncurses-devel' on Fedora; run `nix-shell` first, on NixOS. Or maybe it failed for different reasons which are seen in the errored output above.";
+    expect_panic(result, expected_panic_msg);
+}
+
+#[allow(dead_code)]
+fn test_invalid_utf8_in_program() {
+    let result = std::panic::catch_unwind(|| {
+        let mut command = Command::new(OsString::from_vec(
+            b"test_invalid_utf8_\xFFin_program".to_vec(),
+        ));
+        command.args([
+            OsString::from("arg1"),
+            OsString::from_vec(b"my\xffarg3".to_vec()),
+        ]);
+        command.status_or_panic();
+    });
+    expect_panic(
+        result,
+        "Compiler executable \"test_invalid_utf8_\\xFFin_program\" isn't valid rust string",
+    );
+}
+
+fn expect_panic(result: Result<(), Box<dyn std::any::Any + Send>>, expected_panic_message: &str) {
+    if result.is_err() {
+        if let Some(err) = result.unwrap_err().downcast_ref::<String>() {
+            // Uncomment this to can copy/paste it for asserts:
+            //println!("!!!!!!!!!! Panic message: {:?}", err);
+            assert_eq!(
+                err, expected_panic_message,
+                "!!! Got different panic message than expected !!!"
+            );
+        }
+    } else {
+        panic!(
+            "No panic was thrown! But was expecting this panic: '{}'",
+            expected_panic_message
+        );
+    };
+}
+
+#[allow(dead_code)]
+fn test_nul_in_arg_unchecked() {
+    let result = std::panic::catch_unwind(|| {
+        let mut command = Command::new("test_nul_in_arg_unchecked.exe");
+        command.args([
+            OsString::from("arg1"),
+            OsString::from("a\0rg2"),
+            OsString::from_vec(b"my\xffarg3".to_vec()),
+        ]);
+        command.status_or_panic();
+    });
+    expect_panic(result,
+         "Failed to run compilation command 'test_nul_in_arg_unchecked.exe' with '3' args: '\"arg1\" \"<string-with-nul>\" \"my\\xFFarg3\"', reason: 'nul byte found in provided data'"
+        );
+}
+
+#[allow(dead_code)]
+fn test_nul_in_arg() {
+    //via .arg()
+    let result = std::panic::catch_unwind(|| {
+        let mut command = Command::new("test_nul_in_arg.exe");
+        command.arg_checked(OsString::from("arg1"));
+        command.arg_checked(
+            // would panic here
+            OsString::from("a\0rg2"),
+        );
+        command.arg_checked(OsString::from_vec(b"my\xffarg3".to_vec()));
+        command.status_or_panic();
+    });
+    let expected_panic_msg=
+         "Found arg '\"a\\0rg2\"' that has at least one \\0 aka nul in it! This would've been replaced with '<string-with-nul>'.";
+    expect_panic(result, expected_panic_msg);
+    //via .args()
+    let result = std::panic::catch_unwind(|| {
+        let mut command = Command::new("test_nul_in_args.exe");
+        command.args_checked([
+            // would panic here
+            OsString::from("arg1"),
+            OsString::from("a\0rg2"),
+            OsString::from_vec(b"my\xffarg3".to_vec()),
+        ]);
+        command.status_or_panic();
+    });
+    expect_panic(result, expected_panic_msg);
+}
+
+#[allow(dead_code)]
+fn test_get_what_will_run() {
+    let expected_prog = "test_get_what_will_run.exe";
+    let mut command = Command::new(expected_prog);
+    command.arg_checked(OsString::from("arg1"));
+    command.args_checked([
+        // would panic here
+        OsString::from_vec(b"my\xffarg3".to_vec()),
+        OsString::from("arg4"),
+    ]);
+    command.arg_checked(OsString::from_vec(b"my\xffarg3".to_vec()));
+    let (prog, how_many_args, formatted_args) = command.get_what_will_run();
+    let expected_hma = 4;
+    let expected_fa = "\"arg1\" \"my\\xFFarg3\" \"arg4\" \"my\\xFFarg3\"";
+    assert_eq!(prog, expected_prog);
+    assert_eq!(how_many_args, expected_hma);
+    assert_eq!(formatted_args, expected_fa);
+}
+
+#[allow(dead_code)]
+fn test_assert_no_nul_in_args() {
+    let expected_prog = "test_get_what_will_run.exe";
+    let result = std::panic::catch_unwind(|| {
+        let mut command = Command::new(expected_prog);
+        command.arg("a\0here");
+        command.assert_no_nul_in_args();
+    });
+    expect_panic(
+        result,
+        r##"Found arg number '1' that has \0 aka NUL in it! It got replaced with '<string-with-nul>'."##,
+    );
+
+    let result = std::panic::catch_unwind(|| {
+        let mut command = Command::new(expected_prog);
+        command.arg("no nul in this arg here");
+        command.assert_no_nul_in_args();
+    });
+    assert!(result.is_ok(), "!!! This should not have panicked !!!");
 }

From d69a043bad14884ea64adf80a439b0f328f56e57 Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Sat, 13 Apr 2024 23:21:01 +0200
Subject: [PATCH 19/54] fix NixOS warning about _FORTIFY_SOURCE needing -O

warning: ncurses@6.0.0:   414 | #  warning _FORTIFY_SOURCE requires compiling with optimization (-O)
---
 build.rs | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/build.rs b/build.rs
index 5ca39e70..72e77b13 100644
--- a/build.rs
+++ b/build.rs
@@ -134,6 +134,8 @@ fn build_wrap(ncurses_lib: &Option<Library>) {
         //    build.include(path);
         //}
     }
+    build.opt_level(1); //else is 0, causes warning on NixOS: _FORTIFY_SOURCE requires compiling with optimization (-O)
+
     // The following creates `libwrap.a` on linux
     build.file("src/wrap.c").compile("wrap");
 }

From 226b8467aa2af976e02bb55a314e709472efd51b Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Sat, 13 Apr 2024 23:40:07 +0200
Subject: [PATCH 20/54] undeprecate printw, since it's fixed now

it got fixed here: https://github.com/jeaye/ncurses-rs/commit/8fd11147ec9cc85d07a21f71afd07874e06f4a5f#diff-b1a35a68f14e696205874893c07fd24fdb88882b47c23cc0e0c80a30c7d53759L1078-R1091

so it won't crash anymore or be a security issue

and it works the same as mvprintw() mvwprintw() wprintw()
which got fixed in the same commit mentioned above.

So either deprecate all 4 or none.
---
 src/lib.rs | 1 -
 1 file changed, 1 deletion(-)

diff --git a/src/lib.rs b/src/lib.rs
index 5cb0c952..0ca7699e 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -1096,7 +1096,6 @@ pub fn prefresh(pad: WINDOW, pmin_row: i32, pmin_col: i32, smin_row: i32, smin_c
 { unsafe { ll::prefresh(pad, pmin_row, pmin_col, smin_row, smin_col, smax_row, smax_col) } }
 
 
-#[deprecated(since = "5.98.0", note = "printw format support is disabled. Use addstr instead")]
 pub fn printw(s: &str) -> Result<i32, std::ffi::NulError>
 {
     // We don't actually need this function to support format strings,

From e3eb2ffe006dfd4417b42dee0156faf0a8db5e5f Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Sat, 13 Apr 2024 23:47:44 +0200
Subject: [PATCH 21/54] name the fmt arg for ll::vwprintw & ll::vw_printw

---
 src/ll.rs | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/ll.rs b/src/ll.rs
index d6916ecc..a47806f2 100644
--- a/src/ll.rs
+++ b/src/ll.rs
@@ -261,8 +261,8 @@ extern {
     //  fn vidputs(_:chtype, extern  fn f(c_int) -> c_int) -> c_int;
     //pub fn vidputs(_:chtype, f:*mut c_char) -> c_int;
     pub fn vline(_:chtype, _:c_int) -> c_int;
-    pub fn vwprintw(_:WINDOW, _:char_p, _:va_list) -> c_int;
-    pub fn vw_printw(_:WINDOW, _:char_p,_:va_list) -> c_int;
+    pub fn vwprintw(_:WINDOW, fmt:char_p, _:va_list) -> c_int;
+    pub fn vw_printw(_:WINDOW, fmt:char_p,_:va_list) -> c_int;
     //  fn vwscanw(_:WINDOW, _:char_p, _:va_list) -> c_int;
     //  fn vw_scanw(_:WINDOW, _:char_p, _:va_list) -> c_int;
     pub fn waddch(_:WINDOW, _:chtype) -> c_int;

From 9f96fbb5548802b5725effe1b05abd65cd5550ea Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Sat, 13 Apr 2024 23:54:04 +0200
Subject: [PATCH 22/54] unused_braces: Unnecessary braces in use statement

---
 src/lib.rs | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/lib.rs b/src/lib.rs
index 0ca7699e..65b1d1ca 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -17,7 +17,7 @@ extern crate libc;
 use std::mem;
 use std::{ char, ptr };
 use std::ffi::{CString, CStr};
-use self::ll::{FILE_p};
+use self::ll::FILE_p;
 pub use self::constants::*;
 pub use self::panel::wrapper::*;
 pub use self::menu::wrapper::*;

From a2ad6de789d3ce064771cd8cb194c4800c5d1375 Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Sun, 14 Apr 2024 00:21:42 +0200
Subject: [PATCH 23/54] fix link_name=box warning + add r#box too

warning: attribute should be applied to a foreign function or static
   --> src/lib.rs:161:1
    |
161 |   #[link_name="box"] pub fn box_(w: WINDOW, v: chtype, h: chtype) -> i32
    |  _^^^^^^^^^^^^^^^^^^_-
162 | | { wborder(w, v, v, h, h, 0, 0, 0, 0) }
    | |______________________________________- not a foreign function or static
    |
    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
    = note: `#[warn(unused_attributes)]` on by default

Also allows 'box'(ie. r#box) in rust
both box_ and r#box(aka 'box') can be used in rust code
---
 src/lib.rs | 7 ++++++-
 src/ll.rs  | 3 +++
 2 files changed, 9 insertions(+), 1 deletion(-)

diff --git a/src/lib.rs b/src/lib.rs
index 65b1d1ca..a5576bdb 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -158,7 +158,12 @@ pub fn border(ls: chtype, rs: chtype, ts: chtype, bs: chtype, tl: chtype, tr: ch
 { unsafe { ll::border(ls, rs, ts, bs, tl, tr, bl, br) } }
 
 
-#[link_name="box"] pub fn box_(w: WINDOW, v: chtype, h: chtype) -> i32
+// this is 'box' in rust but must use r#box because 'box' is reserved keyword
+#[inline(always)]
+pub fn r#box(w: WINDOW, v: chtype, h: chtype) -> i32
+{ box_(w,v,h) }
+
+pub fn box_(w: WINDOW, v: chtype, h: chtype) -> i32
 { wborder(w, v, v, h, h, 0, 0, 0, 0) }
 
 
diff --git a/src/ll.rs b/src/ll.rs
index a47806f2..819dd0e7 100644
--- a/src/ll.rs
+++ b/src/ll.rs
@@ -62,7 +62,10 @@ extern {
     pub fn bkgd(_:chtype) -> c_int;
     pub fn bkgdset(_:chtype);
     pub fn border(_:chtype,_:chtype,_:chtype,_:chtype,_:chtype,_:chtype,_:chtype,_:chtype) -> c_int;
+    #[link_name="box"] // points to 'box' of ncurses lib, but is 'box_' here in rust.
     pub fn box_(_:WINDOW, _:chtype, _:chtype) -> c_int;
+    //This is 'box' both in rust and in ncurses lib; but 'box' is reserved keyword, so use r#box
+    pub fn r#box(_:WINDOW, _:chtype, _:chtype) -> c_int;
     pub fn can_change_color() -> c_bool;
     pub fn cbreak() -> c_int;
     pub fn chgat(_:c_int, _:attr_t, _:c_short, _:void_p) -> c_int;

From 2dbd2071d46c5fe247b3602ab4802489f9429217 Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Sun, 14 Apr 2024 00:32:28 +0200
Subject: [PATCH 24/54] fix unused import warning on ex_5 and ex_7

when compiled without their respective features (menu, wide)
---
 examples/ex_5.rs | 1 +
 examples/ex_7.rs | 1 +
 2 files changed, 2 insertions(+)

diff --git a/examples/ex_5.rs b/examples/ex_5.rs
index a5100bc0..293245a0 100644
--- a/examples/ex_5.rs
+++ b/examples/ex_5.rs
@@ -1,6 +1,7 @@
 #[allow(unused_imports)]
 extern crate ncurses;
 
+#[cfg(feature="menu")]
 use ncurses::*;
 
 #[cfg(feature="menu")]
diff --git a/examples/ex_7.rs b/examples/ex_7.rs
index e4101e48..ec885f85 100644
--- a/examples/ex_7.rs
+++ b/examples/ex_7.rs
@@ -10,6 +10,7 @@
 
 extern crate ncurses;
 
+#[cfg(feature = "wide")]
 use std::char;
 use ncurses::*;
 

From 8974f44379df29c04303f4c289c8b565dc98942b Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Sun, 14 Apr 2024 00:38:33 +0200
Subject: [PATCH 25/54] fix 'unused doc comment' warning

$ cargo test --all-features
warning: unused doc comment
   --> /home/user/1tmp/ncurses-rs/src/ll.rs:429:1
    |
429 |   /// Extended color support. Requires ncurses6.
    |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
430 |   #[cfg(feature = "extended_colors")]
431 | / extern {
432 | |     pub fn init_extended_color(_: c_int, _: c_int, _: c_int, _: c_int) -> c_int;
433 | |     pub fn init_extended_pair(_: c_int, _: c_int, _: c_int) -> c_int;
434 | |     pub fn extended_color_content(_: c_int, _: int_p, _: int_p, _: int_p) -> c_int;
435 | |     pub fn extended_pair_content(_: c_int, _: int_p, _: int_p) -> c_int;
436 | | }
    | |_- rustdoc does not generate documentation for extern blocks
    |
    = help: use `//` for a plain comment
    = note: `#[warn(unused_doc_comments)]` on by default

warning: `ncurses` (lib) generated 1 warning
warning: `ncurses` (lib test) generated 1 warning (1 duplicate)
---
 src/ll.rs | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/ll.rs b/src/ll.rs
index 819dd0e7..24ef141c 100644
--- a/src/ll.rs
+++ b/src/ll.rs
@@ -426,7 +426,7 @@ extern {
     
 }
 
-/// Extended color support. Requires ncurses6.
+// XXX: Extended color support. Requires ncurses6.
 #[cfg(feature = "extended_colors")]
 extern {
     pub fn init_extended_color(_: c_int, _: c_int, _: c_int, _: c_int) -> c_int;

From d43c79df6ad1322cae3a51e38f3e6f1794424170 Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Sun, 14 Apr 2024 16:50:39 +0200
Subject: [PATCH 26/54] set fallback lib name for menu & panel too

this makes ex_5 link on FreeBSD (if it doesn't have pkgconf and ncurses
installed)

We're already using fallback lib name 'ncurses' for the ncurses lib.
Fallback happens when pkg-config or pkgconf returned no finds for the lib.
---
 build.rs | 44 ++++++++++++++++++++++++++++++++++----------
 1 file changed, 34 insertions(+), 10 deletions(-)

diff --git a/build.rs b/build.rs
index 72e77b13..d73bc435 100644
--- a/build.rs
+++ b/build.rs
@@ -54,6 +54,24 @@ const NCURSES_LIB_NAMES: &[&str] = if IS_WIDE {
     &["ncurses5", "ncurses"]
 };
 
+const MENU_LIB_NAMES: &[&str] = if IS_WIDE {
+    &["menuw5", "menuw"]
+} else {
+    &["menu5", "menu"]
+};
+
+const PANEL_LIB_NAMES: &[&str] = if IS_WIDE {
+    &["panelw5", "panelw"]
+} else {
+    &["panel5", "panel"]
+};
+//TODO: why are we trying the v5 of the lib first instead of v6 (which is the second/last in list),
+//was v5 newer than the next in list? is it so on other systems?
+//like: was it ever ncurses5 newer than ncurses ?
+//Since we're trying v5 and it finds it, it will use it and stop looking, even though the next one
+//might be v6
+
+/// finds and emits cargo:rustc-link-lib=
 fn find_library(names: &[&str]) -> Option<Library> {
     for name in names {
         if let Ok(lib) = pkg_config::probe_library(name) {
@@ -80,23 +98,22 @@ fn main() {
     let ncurses_lib = find_library(NCURSES_LIB_NAMES);
 
     if cfg!(feature = "menu") {
-        if IS_WIDE {
-            find_library(&["menuw5", "menuw"]);
-        } else {
-            find_library(&["menu5", "menu"]);
+        if find_library(MENU_LIB_NAMES).is_none() {
+            let fallback_lib_name = *MENU_LIB_NAMES.last().unwrap();
+            println!("cargo:rustc-link-lib={}", fallback_lib_name);
         }
     }
 
     if cfg!(feature = "panel") {
-        if IS_WIDE {
-            find_library(&["panelw5", "panelw"]);
-        } else {
-            find_library(&["panel5", "panel"]);
+        if find_library(PANEL_LIB_NAMES).is_none() {
+            let fallback_lib_name = *PANEL_LIB_NAMES.last().unwrap();
+            println!("cargo:rustc-link-lib={}", fallback_lib_name);
         }
     }
 
     // gets the name of ncurses lib found by pkg-config, if it found any!
     // else (warns and)returns the default one like 'ncurses' or 'ncursesw'
+    // and emits cargo:rustc-link-lib= for it unless already done.
     let lib_name = get_ncurses_lib_name(&ncurses_lib);
 
     if let Ok(x) = std::env::var(ENV_VAR_NAME_FOR_NCURSES_RS_RUSTC_FLAGS) {
@@ -345,9 +362,16 @@ fn get_ncurses_lib_name(ncurses_lib: &Option<Library>) -> String {
                     (*NCURSES_LIB_NAMES.last().unwrap()).to_string()
                 }
             } else {
-                println!("cargo:warning=You may not have either pkg-config or pkgconf, or ncurses installed (it's 'ncurses-devel' on Fedora). Using fallback but if compilation fails below, that is why.");
                 //pkg-config didn't find the lib, fallback to 'ncurses' or 'ncursesw'
-                (*NCURSES_LIB_NAMES.last().unwrap()).to_string()
+                let what_lib = (*NCURSES_LIB_NAMES.last().unwrap()).to_string();
+                // On FreeBSD it works without pkgconf and ncurses(6.4) installed but it will fail
+                // to link ex_5 with 'menu' lib, unless `NCURSES_RS_RUSTC_FLAGS="-lmenu" is set.
+                // this is why we now use fallbacks for 'menu' and 'panel` above too(not just for 'ncurses' lib)
+                // that is, when pkgconf or pkg-config are missing, yet the libs are there.
+                // TODO: maybe do it even for 'tinfo' but at least NixOS won't have tinfo at all so
+                // it would fail?!
+                println!("cargo:warning=It's likely you have not installed one of ['pkg-config' or 'pkgconf'], and/or 'ncurses' (it's package 'ncurses-devel' on Fedora). This seems to work fine on FreeBSD 14 regardless, however to not see this warning and to ensure 100% compatibility be sure to install at least `pkgconf` if not both ie. `# pkg install ncurses pkgconf`. Using fallback lib name '{}' but if compilation fails below(like when linking ex_5 with 'menu' feature), that is why.", what_lib);
+                what_lib
             }
         }
     };

From 0ed3b2e7b7b9da06d61ee46869e87e5c1f9cfb9f Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Mon, 15 Apr 2024 14:35:48 +0200
Subject: [PATCH 27/54] use fallback for tinfo lib eg. if no `pkg-config`

shouldn't interfere with how it was linked before, when pkg-config did
exist, but in case it doesn't exist, it won't cause linker errors in
certain cases which require -ltinfo(w) linker arg.

added/modifed some comments
renamed some vars
todo: should we delete what we've generated at all?
---
 build.rs | 201 ++++++++++++++++++++++++++++++++++++++++++++++++++-----
 1 file changed, 185 insertions(+), 16 deletions(-)

diff --git a/build.rs b/build.rs
index d73bc435..532c22cc 100644
--- a/build.rs
+++ b/build.rs
@@ -65,11 +65,31 @@ const PANEL_LIB_NAMES: &[&str] = if IS_WIDE {
 } else {
     &["panel5", "panel"]
 };
+
+const TINFO_LIB_NAMES: &[&str] = if IS_WIDE {
+    //elements order here matters, because:
+    //Fedora has ncursesw+tinfo(without w) for wide!
+    //and -ltinfow fails to link on NixOS and Fedora! so -ltinfo must be used even tho wide.
+    //(presumably because tinfo doesn't depend on wideness?)
+    //NixOS has only ncursesw(tinfo is presumably inside it) but -ltinfo still works for it(it's a
+    //symlink to ncursesw lib)
+    //Gentoo has ncursesw+tinfow
+    //
+    //These are tried in order and first that links is selected:
+    &["tinfow5", "tinfow", "tinfo"]
+} else {
+    //no reason to ever fallback to tinfow here when not-wide!
+    //Fedora/Gentoo has ncurses+tinfo
+    //NixOS has only ncursesw(but works for non-wide), -ltinfo symlinks to ncursesw .so file)
+    //so 'tinfo' is safe fallback here.
+    &["tinfo5", "tinfo"]
+};
 //TODO: why are we trying the v5 of the lib first instead of v6 (which is the second/last in list),
 //was v5 newer than the next in list? is it so on other systems?
 //like: was it ever ncurses5 newer than ncurses ?
 //Since we're trying v5 and it finds it, it will use it and stop looking, even though the next one
 //might be v6
+//This is the commit that added this v5 then v6 way: https://github.com/jeaye/ncurses-rs/commit/daddcbb557169cfac03af9667ef7aefed19f9409
 
 /// finds and emits cargo:rustc-link-lib=
 fn find_library(names: &[&str]) -> Option<Library> {
@@ -111,6 +131,41 @@ fn main() {
         }
     }
 
+    //This comment block is about libtinfo.
+    //If pkg-config can't find it, use fallback: 'tinfo' or 'tinfow'
+    //if cargo can't find it it will ignore it gracefully - NO IT WON'T!
+    //if it can find it, it will link it.
+    //It's needed for ex_5 to can link  when pkg-config is missing,
+    //otherwise you get this: undefined reference to symbol 'noraw'
+    //Thus w/o this block, the following command would be needed to run ex_5
+    //$ NCURSES_RS_RUSTC_FLAGS="-ltinfo" cargo run --features=menu --example ex_5
+    //To emulate this even if you have pkg-config you can tell it to not do its job
+    // by setting these env. vars before the above command:
+    // $ NCURSES_NO_PKG_CONFIG=1 NCURSESW_NO_PKG_CONFIG=1 NCURSES5_NO_PKG_CONFIG=1 NCURSESW5_NO_PKG_CONFIG=1 the_rest_of_the_command_here
+    // Fedora and Gentoo are two that have both ncurses(w) and tinfo(w), ie. split,
+    // however Gentoo has ncurses+tinfo and ncursesw+tinfow,
+    // but Fedora has ncurses+tinfo and ncursesw+tinfo (see 'tinfo' is same! no w)
+    // NixOS has only ncursesw (tinfo is presumably inside?) but -lncurses -lncursesw -ltinfo work!
+    // but -ltinfow doesn't work! on NixOS and Fedora!
+    // On Gentoo -ltinfow works too!
+    // so when pkg-config is missing, how do we know which tinfo to tell cargo to link, if any!
+    // doneFIXME: ^ I guess we gonna have to compile own .c to link with tinfo to see if it fails or
+    // works!
+    if find_library(TINFO_LIB_NAMES).is_none() {
+        //Pick the tinfo lib to link with, as fallback,
+        //the first one that links successfully!
+        //The order in the list matters!
+        for each in TINFO_LIB_NAMES {
+            if try_link(each, &ncurses_lib) {
+                println!("cargo:warning=Found tinfo fallback '{}'", each);
+                //successfully linked with this tinfo variant,
+                //so let's use it as fallback
+                println!("cargo:rustc-link-lib={}", each);
+                break;
+            }
+        }
+    }
+
     // gets the name of ncurses lib found by pkg-config, if it found any!
     // else (warns and)returns the default one like 'ncurses' or 'ncursesw'
     // and emits cargo:rustc-link-lib= for it unless already done.
@@ -142,6 +197,95 @@ fn main() {
 }
 // -----------------------------------------------------------------
 
+/// Tries to see if linker can find/link with the named library.
+/// Uses ncurses lib searchdirs(if any found by pkg-config) to find that lib.
+/// This is mainly used when pkg-config is missing.
+/// Should still work if pkg-config exists though.
+/// Returns true is linking succeeded, false otherwise.
+fn try_link(lib_name: &str, ncurses_lib: &Option<Library>) -> bool {
+    //OUT_DIR is set by cargo during build
+    let out_dir = env::var("OUT_DIR").expect("cannot get OUT_DIR");
+
+    //We won't execute it though, so doesn't matter if it's .exe for Windows
+    let out_bin_fname = format!("try_link_with_{}", lib_name);
+
+    //we'll generate this .c file with our contents
+    let out_src_full = Path::new(&out_dir)
+        .join(format!("{}.c", out_bin_fname))
+        .display()
+        .to_string();
+
+    let mut file = File::create(&out_src_full).unwrap_or_else(|err| {
+        panic!(
+            "Couldn't create rust file '{}', reason: '{}'",
+            out_src_full, err
+        )
+    });
+
+    let source_code = b"int main() { return 0; }";
+    file.write_all(source_code).unwrap_or_else(|err| {
+        panic!(
+            "Couldn't write to C file '{}', reason: '{}'",
+            out_src_full, err
+        )
+    });
+    drop(file); //explicit file close
+
+    let build = cc::Build::new();
+    let mut linker_searchdir_args: Vec<String> = Vec::new();
+    //Add linker paths from ncurses lib, if any found! ie. -L
+    //(this likely will be empty if pkg-config doesn't exist)
+    //Include paths(for headers) don't matter! ie. -I
+    if let Some(lib) = ncurses_lib {
+        for link_path in &lib.link_paths {
+            linker_searchdir_args.push("-L".to_string());
+            linker_searchdir_args.push(link_path.display().to_string());
+        }
+    }
+
+    let compiler = build
+        .try_get_compiler()
+        .expect("Failed Build::try_get_compiler");
+    let mut command = compiler.to_command();
+
+    let out_bin_full = Path::new(&out_dir)
+        .join(out_bin_fname)
+        .display()
+        .to_string();
+    //Create a bin(not a lib) from a .c file
+    //though it wouldn't matter here if it's bin or lib, I'm
+    //not sure how to find its exact output name after, to delete it.
+    //Adding the relevant args for the libs that we depend upon such as ncurses
+    command
+        .arg("-o")
+        .arg_checked(&out_bin_full)
+        .arg_checked(&out_src_full)
+        .args_checked(["-l", lib_name])
+        .args_checked(linker_searchdir_args);
+    let exit_status = command.status_or_panic(); //runs compiler
+    let ret = exit_status.success();
+    if !is_debug() {
+        //we don't keep the generated files around, should we?
+        if ret {
+            //delete temporary bin that we successfully generated
+            std::fs::remove_file(&out_bin_full).unwrap_or_else(|err| {
+                panic!(
+                    "Cannot delete generated bin file '{}', reason: '{}'",
+                    out_bin_full, err
+                )
+            });
+        }
+        //delete the .c that we generated
+        std::fs::remove_file(&out_src_full).unwrap_or_else(|err| {
+            panic!(
+                "Cannot delete generated C file '{}', reason: '{}'",
+                out_src_full, err
+            )
+        });
+    }
+    return ret;
+}
+
 fn build_wrap(ncurses_lib: &Option<Library>) {
     println!("cargo:rerun-if-changed=src/wrap.c");
     let mut build = cc::Build::new();
@@ -157,11 +301,14 @@ fn build_wrap(ncurses_lib: &Option<Library>) {
     build.file("src/wrap.c").compile("wrap");
 }
 
-/// Compiles a .c file then generates a .rs file from its output.
+/// Compiles an existing .c file, runs its bin to generate a .rs file from its output.
 /// Uses ncurses include paths and links with ncurses lib(s)
+// Note: won't link with tinfo unless pkg-config returned it.
+// ie. if `pkg-config ncurses --libs` shows: -lncurses -ltinfo
+// So even though we used a fallback tinfo in main, for cargo, it won't be used here. FIXME: if tinfo is needed here ever! (it's currently not, btw)
 fn gen_rs(
     source_c_file: &str,
-    out_bin_file: &str,
+    out_bin_fname: &str,
     gen_rust_file: &str,
     ncurses_lib: &Option<Library>,
     lib_name: &str,
@@ -169,8 +316,11 @@ fn gen_rs(
     println!("cargo:rerun-if-changed={}", source_c_file);
     let out_dir = env::var("OUT_DIR").expect("cannot get OUT_DIR");
     #[cfg(windows)]
-    let out_bin_file = format!("{}.exe", out_bin_file);
-    let bin_full = Path::new(&out_dir).join(out_bin_file).display().to_string();
+    let out_bin_fname = format!("{}.exe", out_bin_fname);
+    let bin_full = Path::new(&out_dir)
+        .join(out_bin_fname)
+        .display()
+        .to_string();
 
     //Note: env.var. "CC" can override the compiler used and will cause rebuild if changed.
     let mut build = cc::Build::new();
@@ -252,6 +402,7 @@ fn check_chtype_size(ncurses_lib: &Option<Library>) {
     };
     let bin_full = Path::new(&out_dir).join(bin_name).display().to_string();
 
+    //TODO: do we want to keep or delete this file after ?
     let mut fp = File::create(&src)
         .unwrap_or_else(|err| panic!("cannot create '{}', reason: '{}'", src, err));
     fp.write_all(
@@ -279,6 +430,7 @@ int main(void)
     ",
     )
     .unwrap_or_else(|err| panic!("cannot write into file '{}', reason: '{}'", src, err));
+    drop(fp); //explicit file close (flush)
 
     let mut build = cc::Build::new();
     if let Some(lib) = ncurses_lib {
@@ -303,17 +455,36 @@ int main(void)
         .unwrap_or_else(|err| panic!("Executing '{}' failed, reason: '{}'", bin_full, err));
     print!("{}", String::from_utf8_lossy(&features.stdout));
 
-    std::fs::remove_file(&src)
-        .unwrap_or_else(|err| panic!("Cannot delete generated file '{}', reason: '{}'", src, err));
-    std::fs::remove_file(&bin_full).unwrap_or_else(|err| {
-        panic!(
-            "cannot delete compiled file '{}', reason: '{}'",
-            bin_full, err
-        )
-    });
+    //Don't delete anything we've generated, unless in --release mode or debug= is set in [profile.*]
+    if !is_debug() {
+        std::fs::remove_file(&src).unwrap_or_else(|err| {
+            panic!("Cannot delete generated file '{}', reason: '{}'", src, err)
+        });
+        std::fs::remove_file(&bin_full).unwrap_or_else(|err| {
+            panic!(
+                "cannot delete compiled file '{}', reason: '{}'",
+                bin_full, err
+            )
+        });
+    }
+}
+
+//TODO: maybe don't delete anything we've generated? let 'cargo clean' do it.
+#[inline]
+fn is_debug() -> bool {
+    //cargo sets DEBUG to 'true' if 'cargo build', and to 'false' if 'cargo build --release'
+    //this is the -C debuginfo flag " which controls the amount of debug information included
+    //in the compiled binary."
+    //it actually depends on `debug=` of the profile in Cargo.toml https://doc.rust-lang.org/cargo/reference/profiles.html#debug
+    //thus also doesn't need a println!("cargo:rerun-if-env-changed=DEBUG");
+    // possible values here are only 'true' and 'false', even if debug="none"
+    // or debug=false or debug=0 under say [profile.dev] of Cargo.toml, here
+    // env.var "DEBUG" is still the string "false".
+    // Also, it ignores any env.var DEBUG set before running 'cargo build'
+    env::var("DEBUG").is_ok_and(|val| val != "false")
 }
 
-//call this only once
+//call this only once, to avoid re-printing "cargo:rustc-link-lib=" // FIXME
 fn get_ncurses_lib_name(ncurses_lib: &Option<Library>) -> String {
     let mut already_printed: bool = false;
     let lib_name: String = match std::env::var(ENV_VAR_NAME_FOR_LIB) {
@@ -368,9 +539,7 @@ fn get_ncurses_lib_name(ncurses_lib: &Option<Library>) -> String {
                 // to link ex_5 with 'menu' lib, unless `NCURSES_RS_RUSTC_FLAGS="-lmenu" is set.
                 // this is why we now use fallbacks for 'menu' and 'panel` above too(not just for 'ncurses' lib)
                 // that is, when pkgconf or pkg-config are missing, yet the libs are there.
-                // TODO: maybe do it even for 'tinfo' but at least NixOS won't have tinfo at all so
-                // it would fail?!
-                println!("cargo:warning=It's likely you have not installed one of ['pkg-config' or 'pkgconf'], and/or 'ncurses' (it's package 'ncurses-devel' on Fedora). This seems to work fine on FreeBSD 14 regardless, however to not see this warning and to ensure 100% compatibility be sure to install at least `pkgconf` if not both ie. `# pkg install ncurses pkgconf`. Using fallback lib name '{}' but if compilation fails below(like when linking ex_5 with 'menu' feature), that is why.", what_lib);
+                println!("cargo:warning=Using fallback lib name '{}' but if compilation fails below(like when linking ex_5 with 'menu' feature), that is why. It's likely you have not installed one of ['pkg-config' or 'pkgconf'], and/or 'ncurses' (it's package 'ncurses-devel' on Fedora). This seems to work fine on FreeBSD 14 regardless, however to not see this warning and to ensure 100% compatibility(on any OS) be sure to install, on FreeBSD, at least `pkgconf` if not both ie. `# pkg install ncurses pkgconf`.", what_lib);
                 what_lib
             }
         }

From 9655fea3133d5661766d1bf2beb2ffeeb2baa893 Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Mon, 15 Apr 2024 15:55:32 +0200
Subject: [PATCH 28/54] default to not deletin anything build.rs generated

use a const bool, instead of DEBUG aka -C debuginfo
---
 build.rs | 39 ++++++++++++++++-----------------------
 1 file changed, 16 insertions(+), 23 deletions(-)

diff --git a/build.rs b/build.rs
index 532c22cc..0e68433a 100644
--- a/build.rs
+++ b/build.rs
@@ -25,6 +25,12 @@ use std::path::Path;
 use std::process::Command;
 use std::process::ExitStatus;
 
+//Decide whether or not to delete .c and bin files generated by build.rs once they're not needed.
+//Defaulting to 'false' because it's a job for 'cargo clean' and
+//it might help with debugging build issues if we keep them around.
+//even if this were true, we're already keeping 'libwrap.a', so FIXME: if this is set true.
+const DELETE_GENERATEDS: bool = false;
+
 // Optional environment variables:
 
 // The below doc comment doesn't apply for these 2 env.vars:
@@ -264,8 +270,8 @@ fn try_link(lib_name: &str, ncurses_lib: &Option<Library>) -> bool {
         .args_checked(linker_searchdir_args);
     let exit_status = command.status_or_panic(); //runs compiler
     let ret = exit_status.success();
-    if !is_debug() {
-        //we don't keep the generated files around, should we?
+
+    if DELETE_GENERATEDS {
         if ret {
             //delete temporary bin that we successfully generated
             std::fs::remove_file(&out_bin_full).unwrap_or_else(|err| {
@@ -297,8 +303,9 @@ fn build_wrap(ncurses_lib: &Option<Library>) {
     }
     build.opt_level(1); //else is 0, causes warning on NixOS: _FORTIFY_SOURCE requires compiling with optimization (-O)
 
-    // The following creates `libwrap.a` on linux
+    // The following creates `libwrap.a` on linux, but what does it create on Windows?(via pancurses)
     build.file("src/wrap.c").compile("wrap");
+    //the resulting lib will be kept until deleted by 'cargo clean'
 }
 
 /// Compiles an existing .c file, runs its bin to generate a .rs file from its output.
@@ -402,7 +409,6 @@ fn check_chtype_size(ncurses_lib: &Option<Library>) {
     };
     let bin_full = Path::new(&out_dir).join(bin_name).display().to_string();
 
-    //TODO: do we want to keep or delete this file after ?
     let mut fp = File::create(&src)
         .unwrap_or_else(|err| panic!("cannot create '{}', reason: '{}'", src, err));
     fp.write_all(
@@ -455,35 +461,22 @@ int main(void)
         .unwrap_or_else(|err| panic!("Executing '{}' failed, reason: '{}'", bin_full, err));
     print!("{}", String::from_utf8_lossy(&features.stdout));
 
-    //Don't delete anything we've generated, unless in --release mode or debug= is set in [profile.*]
-    if !is_debug() {
+    if DELETE_GENERATEDS {
         std::fs::remove_file(&src).unwrap_or_else(|err| {
-            panic!("Cannot delete generated file '{}', reason: '{}'", src, err)
+            panic!(
+                "Cannot delete generated C file '{}', reason: '{}'",
+                src, err
+            )
         });
         std::fs::remove_file(&bin_full).unwrap_or_else(|err| {
             panic!(
-                "cannot delete compiled file '{}', reason: '{}'",
+                "cannot delete compiled bin file '{}', reason: '{}'",
                 bin_full, err
             )
         });
     }
 }
 
-//TODO: maybe don't delete anything we've generated? let 'cargo clean' do it.
-#[inline]
-fn is_debug() -> bool {
-    //cargo sets DEBUG to 'true' if 'cargo build', and to 'false' if 'cargo build --release'
-    //this is the -C debuginfo flag " which controls the amount of debug information included
-    //in the compiled binary."
-    //it actually depends on `debug=` of the profile in Cargo.toml https://doc.rust-lang.org/cargo/reference/profiles.html#debug
-    //thus also doesn't need a println!("cargo:rerun-if-env-changed=DEBUG");
-    // possible values here are only 'true' and 'false', even if debug="none"
-    // or debug=false or debug=0 under say [profile.dev] of Cargo.toml, here
-    // env.var "DEBUG" is still the string "false".
-    // Also, it ignores any env.var DEBUG set before running 'cargo build'
-    env::var("DEBUG").is_ok_and(|val| val != "false")
-}
-
 //call this only once, to avoid re-printing "cargo:rustc-link-lib=" // FIXME
 fn get_ncurses_lib_name(ncurses_lib: &Option<Library>) -> String {
     let mut already_printed: bool = false;

From ebf875b17152c63cd44a4878b11fea79c110f089 Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Mon, 15 Apr 2024 21:55:21 +0200
Subject: [PATCH 29/54] handle better when TERM isn't in terminal database

happens in FreeBSD with TERM=alacritty (eg. via ssh),
and in sabotage linux with TERM=linux

TERM=xterm would've made both compile fine (instead of err like below)

eg. TERM=foo on any linux would cause oddly cryptic compilation errors like:

   Compiling ncurses v6.0.0 (/home/user/sandbox/21/ncurses_things/ncurses-rs)
error[E0432]: unresolved import `constants::TRUE`
 --> src/panel/wrapper.rs:6:5
  |
6 | use constants::TRUE;
  |     ^^^^^^^^^^^^^^^ no `TRUE` in `constants`

error[E0432]: unresolved import `constants::TRUE`
  --> src/menu/wrapper.rs:12:5
   |
12 | use constants::TRUE;
   |     ^^^^^^^^^^^^^^^ no `TRUE` in `constants`

error[E0425]: cannot find value `TRUE` in this scope
   --> src/lib.rs:171:38
    |
171 | { unsafe { ll::can_change_color() == TRUE } }
    |                                      ^^^^ not found in this scope
    |
help: you may want to use a bool value instead
    |
171 | { unsafe { ll::can_change_color() == true } }
    |                                      ~~~~

error[E0425]: cannot find value `OK` in this scope
   --> src/lib.rs:418:7
    |
418 |       OK
    |       ^^ help: a tuple variant with a similar name exists (notice the capitalization): `Ok`
   --> /wrkdirs/usr/ports/lang/rust-nightly/work/rustc-nightly-src/library/core/src/result.rs:506:5
    |
    = note: similarly named tuple variant `Ok` defined here

error[E0425]: cannot find value `ERR` in this scope
   --> src/lib.rs:421:7
    |
421 |       ERR
    |       ^^^ help: a tuple variant with a similar name exists: `Err`
   --> /wrkdirs/usr/ports/lang/rust-nightly/work/rustc-nightly-src/library/core/src/result.rs:511:5
    |
    = note: similarly named tuple variant `Err` defined here

error[E0425]: cannot find value `TRUE` in this scope
   --> src/lib.rs:472:32
    |
472 | { unsafe { ll::has_colors() == TRUE } }
    |                                ^^^^ not found in this scope
    |
help: you may want to use a bool value instead
    |
472 | { unsafe { ll::has_colors() == true } }
    |                                ~~~~

error[E0425]: cannot find value `TRUE` in this scope
   --> src/lib.rs:476:28
    |
476 | { unsafe { ll::has_ic() == TRUE } }
    |                            ^^^^ not found in this scope
    |
help: you may want to use a bool value instead
    |
476 | { unsafe { ll::has_ic() == true } }
    |                            ~~~~

error[E0425]: cannot find value `TRUE` in this scope
   --> src/lib.rs:480:28
    |
480 | { unsafe { ll::has_il() == TRUE } }
    |                            ^^^^ not found in this scope
    |
help: you may want to use a bool value instead
    |
480 | { unsafe { ll::has_il() == true } }
    |                            ~~~~

error[E0425]: cannot find value `TRUE` in this scope
   --> src/lib.rs:614:30
    |
614 | { unsafe { ll::isendwin() == TRUE } }
    |                              ^^^^ not found in this scope
    |
help: you may want to use a bool value instead
    |
614 | { unsafe { ll::isendwin() == true } }
    |                              ~~~~

error[E0425]: cannot find value `TRUE` in this scope
   --> src/lib.rs:618:40
    |
618 | { unsafe { ll::is_linetouched(w, l) == TRUE } }
    |                                        ^^^^ not found in this scope
    |
help: you may want to use a bool value instead
    |
618 | { unsafe { ll::is_linetouched(w, l) == true } }
    |                                        ~~~~

error[E0425]: cannot find value `TRUE` in this scope
   --> src/lib.rs:622:36
    |
622 | { unsafe { ll::is_wintouched(w) == TRUE } }
    |                                    ^^^^ not found in this scope
    |
help: you may want to use a bool value instead
    |
622 | { unsafe { ll::is_wintouched(w) == true } }
    |                                    ~~~~

error[E0425]: cannot find value `TRUE` in this scope
   --> src/lib.rs:626:48
    |
626 | { unsafe { ll::is_term_resized(lines, cols) == TRUE } }
    |                                                ^^^^ not found in this scope
    |
help: you may want to use a bool value instead
    |
626 | { unsafe { ll::is_term_resized(lines, cols) == true } }
    |                                                ~~~~

error[E0425]: cannot find value `TRUE` in this scope
   --> src/lib.rs:630:33
    |
630 | { unsafe { ll::is_cleared(w) == TRUE } }
    |                                 ^^^^ not found in this scope
    |
help: you may want to use a bool value instead
    |
630 | { unsafe { ll::is_cleared(w) == true } }
    |                                 ~~~~

error[E0425]: cannot find value `TRUE` in this scope
   --> src/lib.rs:634:31
    |
634 | { unsafe { ll::is_idcok(w) == TRUE } }
    |                               ^^^^ not found in this scope
    |
help: you may want to use a bool value instead
    |
634 | { unsafe { ll::is_idcok(w) == true } }
    |                               ~~~~

error[E0425]: cannot find value `TRUE` in this scope
   --> src/lib.rs:638:31
    |
638 | { unsafe { ll::is_idlok(w) == TRUE } }
    |                               ^^^^ not found in this scope
    |
help: you may want to use a bool value instead
    |
638 | { unsafe { ll::is_idlok(w) == true } }
    |                               ~~~~

error[E0425]: cannot find value `TRUE` in this scope
   --> src/lib.rs:642:33
    |
642 | { unsafe { ll::is_immedok(w) == TRUE } }
    |                                 ^^^^ not found in this scope
    |
help: you may want to use a bool value instead
    |
642 | { unsafe { ll::is_immedok(w) == true } }
    |                                 ~~~~

error[E0425]: cannot find value `TRUE` in this scope
   --> src/lib.rs:646:32
    |
646 | { unsafe { ll::is_keypad(w) == TRUE } }
    |                                ^^^^ not found in this scope
    |
help: you may want to use a bool value instead
    |
646 | { unsafe { ll::is_keypad(w) == true } }
    |                                ~~~~

error[E0425]: cannot find value `TRUE` in this scope
   --> src/lib.rs:650:33
    |
650 | { unsafe { ll::is_leaveok(w) == TRUE } }
    |                                 ^^^^ not found in this scope
    |
help: you may want to use a bool value instead
    |
650 | { unsafe { ll::is_leaveok(w) == true } }
    |                                 ~~~~

error[E0425]: cannot find value `TRUE` in this scope
   --> src/lib.rs:654:33
    |
654 | { unsafe { ll::is_nodelay(w) == TRUE } }
    |                                 ^^^^ not found in this scope
    |
help: you may want to use a bool value instead
    |
654 | { unsafe { ll::is_nodelay(w) == true } }
    |                                 ~~~~

error[E0425]: cannot find value `TRUE` in this scope
   --> src/lib.rs:658:35
    |
658 | { unsafe { ll::is_notimeout(w) == TRUE } }
    |                                   ^^^^ not found in this scope
    |
help: you may want to use a bool value instead
    |
658 | { unsafe { ll::is_notimeout(w) == true } }
    |                                   ~~~~

error[E0425]: cannot find value `TRUE` in this scope
   --> src/lib.rs:662:34
    |
662 | { unsafe { ll::is_scrollok(w) == TRUE } }
    |                                  ^^^^ not found in this scope
    |
help: you may want to use a bool value instead
    |
662 | { unsafe { ll::is_scrollok(w) == true } }
    |                                  ~~~~

error[E0425]: cannot find value `TRUE` in this scope
   --> src/lib.rs:666:32
    |
666 | { unsafe { ll::is_syncok(w) == TRUE }}
    |                                ^^^^ not found in this scope
    |
help: you may want to use a bool value instead
    |
666 | { unsafe { ll::is_syncok(w) == true }}
    |                                ~~~~

error[E0425]: cannot find value `ERR` in this scope
   --> src/lib.rs:703:18
    |
703 |   if mv(y, x) == ERR
    |                  ^^^ help: a tuple variant with a similar name exists: `Err`
   --> /wrkdirs/usr/ports/lang/rust-nightly/work/rustc-nightly-src/library/core/src/result.rs:511:5
    |
    = note: similarly named tuple variant `Err` defined here

error[E0425]: cannot find value `ERR` in this scope
   --> src/lib.rs:704:12
    |
704 |   { return ERR; }
    |            ^^^ help: a tuple variant with a similar name exists: `Err`
   --> /wrkdirs/usr/ports/lang/rust-nightly/work/rustc-nightly-src/library/core/src/result.rs:511:5
    |
    = note: similarly named tuple variant `Err` defined here

error[E0425]: cannot find value `ERR` in this scope
   --> src/lib.rs:711:18
    |
711 |   if mv(y, x) == ERR
    |                  ^^^ help: a tuple variant with a similar name exists: `Err`
   --> /wrkdirs/usr/ports/lang/rust-nightly/work/rustc-nightly-src/library/core/src/result.rs:511:5
    |
    = note: similarly named tuple variant `Err` defined here

error[E0425]: cannot find value `ERR` in this scope
   --> src/lib.rs:712:12
    |
712 |   { return ERR; }
    |            ^^^ help: a tuple variant with a similar name exists: `Err`
   --> /wrkdirs/usr/ports/lang/rust-nightly/work/rustc-nightly-src/library/core/src/result.rs:511:5
    |
    = note: similarly named tuple variant `Err` defined here

error[E0425]: cannot find value `ERR` in this scope
   --> src/lib.rs:719:18
    |
719 |   if mv(y, x) == ERR
    |                  ^^^ help: a tuple variant with a similar name exists: `Err`
   --> /wrkdirs/usr/ports/lang/rust-nightly/work/rustc-nightly-src/library/core/src/result.rs:511:5
    |
    = note: similarly named tuple variant `Err` defined here

error[E0425]: cannot find value `ERR` in this scope
   --> src/lib.rs:720:15
    |
720 |   { return Ok(ERR); }
    |               ^^^ help: a tuple variant with a similar name exists: `Err`
   --> /wrkdirs/usr/ports/lang/rust-nightly/work/rustc-nightly-src/library/core/src/result.rs:511:5
    |
    = note: similarly named tuple variant `Err` defined here

error[E0425]: cannot find value `ERR` in this scope
   --> src/lib.rs:727:18
    |
727 |   if mv(y, x) == ERR
    |                  ^^^ help: a tuple variant with a similar name exists: `Err`
   --> /wrkdirs/usr/ports/lang/rust-nightly/work/rustc-nightly-src/library/core/src/result.rs:511:5
    |
    = note: similarly named tuple variant `Err` defined here

error[E0425]: cannot find value `ERR` in this scope
   --> src/lib.rs:728:15
    |
728 |   { return Ok(ERR); }
    |               ^^^ help: a tuple variant with a similar name exists: `Err`
   --> /wrkdirs/usr/ports/lang/rust-nightly/work/rustc-nightly-src/library/core/src/result.rs:511:5
    |
    = note: similarly named tuple variant `Err` defined here

error[E0425]: cannot find value `ERR` in this scope
   --> src/lib.rs:758:10
    |
758 |     _ => ERR,
    |          ^^^ help: a tuple variant with a similar name exists: `Err`
   --> /wrkdirs/usr/ports/lang/rust-nightly/work/rustc-nightly-src/library/core/src/result.rs:511:5
    |
    = note: similarly named tuple variant `Err` defined here

error[E0425]: cannot find value `ERR` in this scope
   --> src/lib.rs:765:18
    |
765 |   if mv(y, x) == ERR
    |                  ^^^ help: a tuple variant with a similar name exists: `Err`
   --> /wrkdirs/usr/ports/lang/rust-nightly/work/rustc-nightly-src/library/core/src/result.rs:511:5
    |
    = note: similarly named tuple variant `Err` defined here

error[E0425]: cannot find value `ERR` in this scope
   --> src/lib.rs:766:12
    |
766 |   { return ERR; }
    |            ^^^ help: a tuple variant with a similar name exists: `Err`
   --> /wrkdirs/usr/ports/lang/rust-nightly/work/rustc-nightly-src/library/core/src/result.rs:511:5
    |
    = note: similarly named tuple variant `Err` defined here

error[E0425]: cannot find value `ERR` in this scope
   --> src/lib.rs:781:18
    |
781 |   if mv(y, x) == ERR
    |                  ^^^ help: a tuple variant with a similar name exists: `Err`
   --> /wrkdirs/usr/ports/lang/rust-nightly/work/rustc-nightly-src/library/core/src/result.rs:511:5
    |
    = note: similarly named tuple variant `Err` defined here

error[E0425]: cannot find value `ERR` in this scope
   --> src/lib.rs:782:12
    |
782 |   { return ERR; }
    |            ^^^ help: a tuple variant with a similar name exists: `Err`
   --> /wrkdirs/usr/ports/lang/rust-nightly/work/rustc-nightly-src/library/core/src/result.rs:511:5
    |
    = note: similarly named tuple variant `Err` defined here

error[E0425]: cannot find value `ERR` in this scope
   --> src/lib.rs:789:18
    |
789 |   if mv(y, x) == ERR
    |                  ^^^ help: a tuple variant with a similar name exists: `Err`
   --> /wrkdirs/usr/ports/lang/rust-nightly/work/rustc-nightly-src/library/core/src/result.rs:511:5
    |
    = note: similarly named tuple variant `Err` defined here

error[E0425]: cannot find value `ERR` in this scope
   --> src/lib.rs:790:12
    |
790 |   { return ERR; }
    |            ^^^ help: a tuple variant with a similar name exists: `Err`
   --> /wrkdirs/usr/ports/lang/rust-nightly/work/rustc-nightly-src/library/core/src/result.rs:511:5
    |
    = note: similarly named tuple variant `Err` defined here

error[E0425]: cannot find value `ERR` in this scope
   --> src/lib.rs:797:18
    |
797 |   if mv(y, x) == ERR
    |                  ^^^ help: a tuple variant with a similar name exists: `Err`
   --> /wrkdirs/usr/ports/lang/rust-nightly/work/rustc-nightly-src/library/core/src/result.rs:511:5
    |
    = note: similarly named tuple variant `Err` defined here

error[E0425]: cannot find value `ERR` in this scope
   --> src/lib.rs:798:12
    |
798 |   { return ERR; }
    |            ^^^ help: a tuple variant with a similar name exists: `Err`
   --> /wrkdirs/usr/ports/lang/rust-nightly/work/rustc-nightly-src/library/core/src/result.rs:511:5
    |
    = note: similarly named tuple variant `Err` defined here

error[E0425]: cannot find value `ERR` in this scope
   --> src/lib.rs:809:18
    |
809 |   if mv(y, x) == ERR
    |                  ^^^ help: a tuple variant with a similar name exists: `Err`
   --> /wrkdirs/usr/ports/lang/rust-nightly/work/rustc-nightly-src/library/core/src/result.rs:511:5
    |
    = note: similarly named tuple variant `Err` defined here

error[E0425]: cannot find value `ERR` in this scope
   --> src/lib.rs:810:12
    |
810 |   { return ERR; }
    |            ^^^ help: a tuple variant with a similar name exists: `Err`
   --> /wrkdirs/usr/ports/lang/rust-nightly/work/rustc-nightly-src/library/core/src/result.rs:511:5
    |
    = note: similarly named tuple variant `Err` defined here

error[E0425]: cannot find value `ERR` in this scope
   --> src/lib.rs:817:18
    |
817 |   if mv(y, x) == ERR
    |                  ^^^ help: a tuple variant with a similar name exists: `Err`
   --> /wrkdirs/usr/ports/lang/rust-nightly/work/rustc-nightly-src/library/core/src/result.rs:511:5
    |
    = note: similarly named tuple variant `Err` defined here

error[E0425]: cannot find value `ERR` in this scope
   --> src/lib.rs:818:12
    |
818 |   { return ERR; }
    |            ^^^ help: a tuple variant with a similar name exists: `Err`
   --> /wrkdirs/usr/ports/lang/rust-nightly/work/rustc-nightly-src/library/core/src/result.rs:511:5
    |
    = note: similarly named tuple variant `Err` defined here

error[E0425]: cannot find value `ERR` in this scope
   --> src/lib.rs:825:18
    |
825 |   if mv(y, x) == ERR
    |                  ^^^ help: a tuple variant with a similar name exists: `Err`
   --> /wrkdirs/usr/ports/lang/rust-nightly/work/rustc-nightly-src/library/core/src/result.rs:511:5
    |
    = note: similarly named tuple variant `Err` defined here

error[E0425]: cannot find value `ERR` in this scope
   --> src/lib.rs:826:15
    |
826 |   { return Ok(ERR); }
    |               ^^^ help: a tuple variant with a similar name exists: `Err`
   --> /wrkdirs/usr/ports/lang/rust-nightly/work/rustc-nightly-src/library/core/src/result.rs:511:5
    |
    = note: similarly named tuple variant `Err` defined here

error[E0425]: cannot find value `ERR` in this scope
   --> src/lib.rs:872:10
    |
872 |     _ => ERR,
    |          ^^^ help: a tuple variant with a similar name exists: `Err`
   --> /wrkdirs/usr/ports/lang/rust-nightly/work/rustc-nightly-src/library/core/src/result.rs:511:5
    |
    = note: similarly named tuple variant `Err` defined here

error[E0425]: cannot find value `ERR` in this scope
   --> src/lib.rs:879:20
    |
879 |     if mv(y, x) == ERR
    |                    ^^^ help: a tuple variant with a similar name exists: `Err`
   --> /wrkdirs/usr/ports/lang/rust-nightly/work/rustc-nightly-src/library/core/src/result.rs:511:5
    |
    = note: similarly named tuple variant `Err` defined here

error[E0425]: cannot find value `ERR` in this scope
   --> src/lib.rs:880:14
    |
880 |     { return ERR; }
    |              ^^^ help: a tuple variant with a similar name exists: `Err`
   --> /wrkdirs/usr/ports/lang/rust-nightly/work/rustc-nightly-src/library/core/src/result.rs:511:5
    |
    = note: similarly named tuple variant `Err` defined here

error[E0425]: cannot find value `OK` in this scope
   --> src/lib.rs:892:6
    |
892 |         OK
    |         ^^ help: a tuple variant with a similar name exists (notice the capitalization): `Ok`
   --> /wrkdirs/usr/ports/lang/rust-nightly/work/rustc-nightly-src/library/core/src/result.rs:506:5
    |
    = note: similarly named tuple variant `Ok` defined here

error[E0425]: cannot find value `ERR` in this scope
   --> src/lib.rs:895:6
    |
895 |         ERR
    |         ^^^ help: a tuple variant with a similar name exists: `Err`
   --> /wrkdirs/usr/ports/lang/rust-nightly/work/rustc-nightly-src/library/core/src/result.rs:511:5
    |
    = note: similarly named tuple variant `Err` defined here

error[E0425]: cannot find value `ERR` in this scope
    --> src/lib.rs:1490:10
     |
1490 |     _ => ERR,
     |          ^^^ help: a tuple variant with a similar name exists: `Err`
    --> /wrkdirs/usr/ports/lang/rust-nightly/work/rustc-nightly-src/library/core/src/result.rs:511:5
     |
     = note: similarly named tuple variant `Err` defined here

error[E0425]: cannot find value `OK` in this scope
    --> src/lib.rs:1507:6
     |
1507 |         OK
     |         ^^ help: a tuple variant with a similar name exists (notice the capitalization): `Ok`
    --> /wrkdirs/usr/ports/lang/rust-nightly/work/rustc-nightly-src/library/core/src/result.rs:506:5
     |
     = note: similarly named tuple variant `Ok` defined here

error[E0425]: cannot find value `ERR` in this scope
    --> src/lib.rs:1510:6
     |
1510 |         ERR
     |         ^^^ help: a tuple variant with a similar name exists: `Err`
    --> /wrkdirs/usr/ports/lang/rust-nightly/work/rustc-nightly-src/library/core/src/result.rs:511:5
     |
     = note: similarly named tuple variant `Err` defined here

error[E0425]: cannot find value `TRUE` in this scope
    --> src/lib.rs:1745:38
     |
1745 |       if ll::is_leaveok(newscr()) == TRUE
     |                                      ^^^^ not found in this scope
     |
help: you may want to use a bool value instead
     |
1745 |       if ll::is_leaveok(newscr()) == true
     |                                      ~~~~

error[E0425]: cannot find value `KEY_F0` in this scope
    --> src/lib.rs:1780:3
     |
1780 |   KEY_F0 + n as i32
     |   ^^^^^^ not found in this scope

error[E0425]: cannot find value `TRUE` in this scope
    --> src/lib.rs:1788:31
     |
1788 | { unsafe { ll::has_mouse() == TRUE } }
     |                               ^^^^ not found in this scope
     |
help: you may want to use a bool value instead
     |
1788 | { unsafe { ll::has_mouse() == true } }
     |                               ~~~~

error[E0425]: cannot find value `TRUE` in this scope
    --> src/lib.rs:1808:67
     |
1808 | { unsafe { ll::wenclose(w, y as libc::c_int, x as libc::c_int) == TRUE } }
     |                                                                   ^^^^ not found in this scope
     |
help: you may want to use a bool value instead
     |
1808 | { unsafe { ll::wenclose(w, y as libc::c_int, x as libc::c_int) == true } }
     |                                                                   ~~~~

error[E0425]: cannot find value `TRUE` in this scope
    --> src/lib.rs:1811:92
     |
1811 | { unsafe { ll::wmouse_trafo(w, y.as_mut_ptr(), x.as_mut_ptr(), to_screen as ll::c_bool) == TRUE } }
     |                                                                                            ^^^^ not found in this scope
     |
help: you may want to use a bool value instead
     |
1811 | { unsafe { ll::wmouse_trafo(w, y.as_mut_ptr(), x.as_mut_ptr(), to_screen as ll::c_bool) == true } }
     |                                                                                            ~~~~

error[E0425]: cannot find value `TRUE` in this scope
    --> src/lib.rs:1814:88
     |
1814 | { unsafe { ll::mouse_trafo(y.as_mut_ptr(), x.as_mut_ptr(), to_screen as ll::c_bool) == TRUE } }
     |                                                                                        ^^^^ not found in this scope
     |
help: you may want to use a bool value instead
     |
1814 | { unsafe { ll::mouse_trafo(y.as_mut_ptr(), x.as_mut_ptr(), to_screen as ll::c_bool) == true } }
     |                                                                                        ~~~~

warning: creating a shared reference to mutable static is discouraged
  --> src/constants.rs:61:9
   |
61 |         &wrapped::acs_map as *const chtype
   |         ^^^^^^^^^^^^^^^^^ shared reference to mutable static
   |
   = note: for more information, see issue #114447 <https://github.com/rust-lang/rust/issues/114447>
   = note: this will be a hard error in the 2024 edition
   = note: this shared reference has lifetime `'static`, but if the static ever gets mutated, or a mutable reference is created, then any further use of this shared reference is Undefined Behavior
   = note: `#[warn(static_mut_refs)]` on by default
help: use `addr_of!` instead to create a raw pointer
   |
61 |         addr_of!(wrapped::acs_map) as *const chtype
   |         ~~~~~~~~~~~~~~~~~~~~~~~~~~

warning: unreachable pattern
   --> src/lib.rs:234:7
    |
233 |       ERR => None,
    |       --- matches any value
234 |       ret => Some(mem::transmute::<i8, CURSOR_VISIBILITY>(ret as i8)),
    |       ^^^ unreachable pattern
    |
    = note: `#[warn(unreachable_patterns)]` on by default

warning: unused variable: `ERR`
   --> src/lib.rs:233:7
    |
233 |       ERR => None,
    |       ^^^ help: if this is intentional, prefix it with an underscore: `_ERR`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: unreachable pattern
   --> src/lib.rs:332:13
    |
329 |             OK => {
    |             -- matches any value
...
332 |             KEY_CODE_YES => {
    |             ^^^^^^^^^^^^ unreachable pattern

warning: unreachable pattern
   --> src/lib.rs:335:13
    |
329 |             OK => {
    |             -- matches any value
...
335 |             _ => {
    |             ^ unreachable pattern

warning: unused variable: `OK`
   --> src/lib.rs:329:13
    |
329 |             OK => {
    |             ^^ help: if this is intentional, prefix it with an underscore: `_OK`

warning: unused variable: `KEY_CODE_YES`
   --> src/lib.rs:332:13
    |
332 |             KEY_CODE_YES => {
    |             ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_KEY_CODE_YES`

warning: unreachable pattern
   --> src/lib.rs:349:13
    |
346 |             OK => {
    |             -- matches any value
...
349 |             KEY_CODE_YES => {
    |             ^^^^^^^^^^^^ unreachable pattern

warning: unreachable pattern
   --> src/lib.rs:352:13
    |
346 |             OK => {
    |             -- matches any value
...
352 |             _ => {
    |             ^ unreachable pattern

warning: unused variable: `OK`
   --> src/lib.rs:346:13
    |
346 |             OK => {
    |             ^^ help: if this is intentional, prefix it with an underscore: `_OK`

warning: unused variable: `KEY_CODE_YES`
   --> src/lib.rs:349:13
    |
349 |             KEY_CODE_YES => {
    |             ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_KEY_CODE_YES`

Some errors have detailed explanations: E0425, E0432.
For more information about an error, try `rustc --explain E0425`.
warning: `ncurses` (lib) generated 11 warnings
error: could not compile `ncurses` (lib) due to 59 previous errors; 11 warnings emitted
---
 build.rs | 48 +++++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 45 insertions(+), 3 deletions(-)

diff --git a/build.rs b/build.rs
index 0e68433a..12133885 100644
--- a/build.rs
+++ b/build.rs
@@ -183,6 +183,11 @@ fn main() {
 
     check_chtype_size(&ncurses_lib);
 
+    //The code in src/genconstants.c uses initscr() of ncurses (see: $ man 3x initscr)
+    //which depends on TERM env.var and will fail if TERM is wrong, say 'TERM=foo',
+    //with: "Error opening terminal: foo." and exit code 1
+    //therefore rebuild if TERM is changed without needing a 'cargo clean' first:
+    println!("cargo:rerun-if-env-changed=TERM",);
     gen_rs(
         "src/genconstants.c",
         "genconstants",
@@ -370,10 +375,29 @@ fn gen_rs(
         .args_checked(linker_searchdir_args);
     command.success_or_panic(); //runs compiler
 
-    //execute the compiled binary
+    //Execute the compiled binary, panicking if non-zero exit code, else compilation will fail
+    //later with things like: "error[E0432]: unresolved import `constants::TRUE`" in the case of
+    //generating raw_constants.rs which would be empty due to 'genconstants' having failed with exit
+    //code 1
     let consts = Command::new(&bin_full)
-        .output()
+        .output() // TODO: maybe make this a trait extension and dedup code
         .unwrap_or_else(|err| panic!("Executing '{}' failed, reason: '{}'", bin_full, err));
+    let exit_code = consts.status.code().unwrap_or_else(|| {
+        panic!(
+            "Execution of '{}' failed, possibly killed by signal? stderr is: '{}'",
+            bin_full,
+            String::from_utf8_lossy(&consts.stderr)
+        )
+    });
+    assert_eq!(
+        exit_code,
+        0,
+        "Executing '{}' failed with exit code '{}',\n|||stdout start|||\n{}\n|||stdout end||| |||stderr start|||\n{}\n|||stderr end|||",
+        bin_full,
+        exit_code,
+        String::from_utf8_lossy(&consts.stdout),
+        String::from_utf8_lossy(&consts.stderr),
+    );
 
     //write the output from executing the binary into a new rust source file .rs
     //that .rs file is later used outside of this build.rs, in the normal build
@@ -457,8 +481,26 @@ int main(void)
     command.success_or_panic(); //runs compiler
 
     let features = Command::new(&bin_full)
-        .output()
+        .output() // TODO: maybe make this a trait extension and dedup code
         .unwrap_or_else(|err| panic!("Executing '{}' failed, reason: '{}'", bin_full, err));
+    let exit_code = features.status.code().unwrap_or_else(|| {
+        panic!(
+            "Execution of '{}' failed, possibly killed by signal? stderr is: '{}'",
+            bin_full,
+            String::from_utf8_lossy(&features.stderr)
+        )
+    });
+    assert_eq!(
+        exit_code,
+        0,
+        "Executing '{}' failed with exit code '{}',\n|||stdout start|||\n{}\n|||stdout end||| |||stderr start|||\n{}\n|||stderr end|||",
+        bin_full,
+        exit_code,
+        String::from_utf8_lossy(&features.stdout),
+        String::from_utf8_lossy(&features.stderr),
+    );
+
+    //for cargo to consume
     print!("{}", String::from_utf8_lossy(&features.stdout));
 
     if DELETE_GENERATEDS {

From 8deefe21487c3e52b974ebb8c27283b8ccd8eed4 Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Mon, 15 Apr 2024 22:13:53 +0200
Subject: [PATCH 30/54] be helpful by suggesting TERM env.var change

when 'genconstants'(likely) bin execution failed with exit code non-zero
---
 build.rs | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/build.rs b/build.rs
index 12133885..6a9be201 100644
--- a/build.rs
+++ b/build.rs
@@ -392,7 +392,7 @@ fn gen_rs(
     assert_eq!(
         exit_code,
         0,
-        "Executing '{}' failed with exit code '{}',\n|||stdout start|||\n{}\n|||stdout end||| |||stderr start|||\n{}\n|||stderr end|||",
+        "Executing '{}' failed with exit code '{}',\n|||stdout start|||\n{}\n|||stdout end||| |||stderr start|||\n{}\n|||stderr end|||\n!! Maybe you need to try a different value for the TERM environment variable !!",
         bin_full,
         exit_code,
         String::from_utf8_lossy(&consts.stdout),

From d256c29a429b264c4c6387d261ad421379588676 Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Tue, 16 Apr 2024 14:28:42 +0200
Subject: [PATCH 31/54] build.rs: connect lib fallback with lib names

otherwise future code changes might miss things and mess up the logic
---
 build.rs | 113 ++++++++++++++++++++++++++++++++++++-------------------
 1 file changed, 75 insertions(+), 38 deletions(-)

diff --git a/build.rs b/build.rs
index 6a9be201..4213f4a3 100644
--- a/build.rs
+++ b/build.rs
@@ -49,30 +49,48 @@ const ENV_VAR_NAME_FOR_NCURSES_RS_RUSTC_FLAGS: &str = "NCURSES_RS_RUSTC_FLAGS";
 /// see: https://docs.rs/cc/1.0.92/src/cc/lib.rs.html#3571-3580
 const ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS: &str = "NCURSES_RS_CFLAGS";
 
-const IS_WIDE: bool = cfg!(all(feature = "wide", not(target_os = "macos")));
-
-// will search for these and if not found
-// then the last one in list will be used as fallback
-// and still try linking with it eg. -lncursesw
-const NCURSES_LIB_NAMES: &[&str] = if IS_WIDE {
-    &["ncursesw5", "ncursesw"]
+const IS_WIDE: bool = cfg!(feature = "wide");
+const IS_MACOS: bool = cfg!(target_os = "macos");
+// Why also not on macos? see: https://github.com/jeaye/ncurses-rs/issues/151
+const IS_WIDE_AND_NOT_ON_MACOS: bool = IS_WIDE && !IS_MACOS;
+
+// Will search for these lib names and if not found via pkg-config
+// then use the fallback name and still try linking with it
+// because in most cases it will work anyway.
+const NCURSES_LIB_NAME_FALLBACK: &str = if IS_WIDE_AND_NOT_ON_MACOS {
+    "ncursesw"
+} else {
+    "ncurses"
+};
+const NCURSES_LIB_NAMES: &[&str] = if IS_WIDE_AND_NOT_ON_MACOS {
+    &["ncursesw5", NCURSES_LIB_NAME_FALLBACK]
 } else {
-    &["ncurses5", "ncurses"]
+    &["ncurses5", NCURSES_LIB_NAME_FALLBACK]
 };
 
-const MENU_LIB_NAMES: &[&str] = if IS_WIDE {
-    &["menuw5", "menuw"]
+const MENU_LIB_NAME_FALLBACK: &str = if IS_WIDE_AND_NOT_ON_MACOS {
+    "menuw"
+} else {
+    "menu"
+};
+const MENU_LIB_NAMES: &[&str] = if IS_WIDE_AND_NOT_ON_MACOS {
+    &["menuw5", MENU_LIB_NAME_FALLBACK]
 } else {
-    &["menu5", "menu"]
+    &["menu5", MENU_LIB_NAME_FALLBACK]
 };
 
-const PANEL_LIB_NAMES: &[&str] = if IS_WIDE {
-    &["panelw5", "panelw"]
+const PANEL_LIB_NAME_FALLBACK: &str = if IS_WIDE_AND_NOT_ON_MACOS {
+    "panelw"
+} else {
+    "panel"
+};
+const PANEL_LIB_NAMES: &[&str] = if IS_WIDE_AND_NOT_ON_MACOS {
+    &["panelw5", PANEL_LIB_NAME_FALLBACK]
 } else {
-    &["panel5", "panel"]
+    &["panel5", PANEL_LIB_NAME_FALLBACK]
 };
 
-const TINFO_LIB_NAMES: &[&str] = if IS_WIDE {
+const TINFO_LIB_NAMES: &[&str] = if IS_WIDE_AND_NOT_ON_MACOS {
     //elements order here matters, because:
     //Fedora has ncursesw+tinfo(without w) for wide!
     //and -ltinfow fails to link on NixOS and Fedora! so -ltinfo must be used even tho wide.
@@ -123,16 +141,36 @@ fn main() {
 
     let ncurses_lib = find_library(NCURSES_LIB_NAMES);
 
+    //TODO: dedup, unmessify
+    //TODO: dedup warning msgs and see when to still emit them.
     if cfg!(feature = "menu") {
         if find_library(MENU_LIB_NAMES).is_none() {
-            let fallback_lib_name = *MENU_LIB_NAMES.last().unwrap();
+            let fallback_lib_name = MENU_LIB_NAME_FALLBACK;
+            if try_link(fallback_lib_name, &ncurses_lib) {
+                println!("cargo:warning=Using lib fallback '{}' which links successfully. You might be missing `pkg-config`/`pkgconf`.", fallback_lib_name);
+            } else {
+                println!("cargo:warning=Possibly missing lib for the '{}' feature, and couldn't find its fallback lib name '{}' but we're gonna use it anyway thus compilation is likely to fail below because of this.\n
+                         You might need installed ncurses and pkg-config/pkgconf to fix this.", "menu", fallback_lib_name);
+            }
+            //We still try linking with it anyway, in case our try_link() code is somehow wrong,
+            //like it doesn't include some link searchdir paths that are somehow included
+            //otherwise.
             println!("cargo:rustc-link-lib={}", fallback_lib_name);
         }
     }
 
     if cfg!(feature = "panel") {
         if find_library(PANEL_LIB_NAMES).is_none() {
-            let fallback_lib_name = *PANEL_LIB_NAMES.last().unwrap();
+            let fallback_lib_name = PANEL_LIB_NAME_FALLBACK;
+            if try_link(fallback_lib_name, &ncurses_lib) {
+                println!("cargo:warning=Using lib fallback '{}' which links successfully. You might be missing `pkg-config`/`pkgconf`.", fallback_lib_name);
+            } else {
+                println!("cargo:warning=Possibly missing lib for the '{}' feature, and couldn't find its fallback lib name '{}' but we're gonna use it anyway thus compilation is likely to fail below because of this.\n
+                         You might need installed ncurses and pkg-config/pkgconf to fix this.", "panel", fallback_lib_name);
+            }
+            //We still try linking with it anyway, in case our try_link() code is somehow wrong,
+            //like it doesn't include some link searchdir paths that are somehow included
+            //otherwise.
             println!("cargo:rustc-link-lib={}", fallback_lib_name);
         }
     }
@@ -163,7 +201,10 @@ fn main() {
         //The order in the list matters!
         for each in TINFO_LIB_NAMES {
             if try_link(each, &ncurses_lib) {
-                println!("cargo:warning=Found tinfo fallback '{}'", each);
+                println!(
+                    "cargo:warning=Using lib fallback '{}' which links successfully.",
+                    each
+                );
                 //successfully linked with this tinfo variant,
                 //so let's use it as fallback
                 println!("cargo:rustc-link-lib={}", each);
@@ -521,9 +562,11 @@ int main(void)
 
 //call this only once, to avoid re-printing "cargo:rustc-link-lib=" // FIXME
 fn get_ncurses_lib_name(ncurses_lib: &Option<Library>) -> String {
+    //Was it found(and thus printed) by pkg_config::probe_library() ?
     let mut already_printed: bool = false;
-    let lib_name: String = match std::env::var(ENV_VAR_NAME_FOR_LIB) {
-        Ok(value) => value,
+    let lib_name: String;
+    match std::env::var(ENV_VAR_NAME_FOR_LIB) {
+        Ok(value) => lib_name = value,
         Err(_) => {
             if let Some(ref lib) = ncurses_lib {
                 // if here, `pkg-config`(shell command) via pkg_config crate,
@@ -540,11 +583,8 @@ fn get_ncurses_lib_name(ncurses_lib: &Option<Library>) -> String {
                     //   cargo:rustc-link-lib=tinfo
                     //so there's no need to re-print the ncurses line as it would be the same.
                     already_printed = true;
-                    found.clone()
+                    lib_name = found.clone();
                 } else {
-                    //if here, we should probably panic, but who knows it might still work even without pkg-config
-                    //I've found cases where we were here and it still worked, so don't panic!
-
                     // Construct the repeated pkg-config command string
                     let repeated_pkg_config_command: String = NCURSES_LIB_NAMES
                         .iter()
@@ -552,34 +592,31 @@ fn get_ncurses_lib_name(ncurses_lib: &Option<Library>) -> String {
                         .collect::<Vec<_>>()
                         .join("` or `");
 
-                    // Construct the warning message string with the repeated pkg-config commands
-                    let warning_message = format!(
-                    "pkg_config reported that it found the ncurses libs but the substring '{}' was not among them, ie. in the output of the shell command(s) eg. `{}`",
+                    panic!(
+                    "pkg_config(crate) reported that it found the ncurses lib(s) but the substring '{}' was not among them, ie. in the output of the shell command(s) eg. `{}`\n
+                    Try setting NCURSES_NO_PKG_CONFIG=1 and/or NCURSESW_NO_PKG_CONFIG=1 to disable pkg-config and thus allow for the fallback to lib name 'ncurses' respectively 'ncursesw' to be tried. Or fix ncurses.pc or ncursesw.pc file.",
                     substring_to_find,
                     repeated_pkg_config_command
                     );
-
-                    // Print the warning message, but use old style warning with one ":" not two "::",
-                    // because old cargos(pre 23 Dec 2023) will simply ignore it and show no warning if it's "::"
-                    println!("cargo:warning={}", warning_message);
-
-                    //fallback lib name: 'ncurses' or 'ncursesw'
-                    //if this fails later, there's the warning above to get an idea as to why.
-                    (*NCURSES_LIB_NAMES.last().unwrap()).to_string()
                 }
             } else {
                 //pkg-config didn't find the lib, fallback to 'ncurses' or 'ncursesw'
-                let what_lib = (*NCURSES_LIB_NAMES.last().unwrap()).to_string();
+                let what_lib = NCURSES_LIB_NAME_FALLBACK.to_string();
                 // On FreeBSD it works without pkgconf and ncurses(6.4) installed but it will fail
                 // to link ex_5 with 'menu' lib, unless `NCURSES_RS_RUSTC_FLAGS="-lmenu" is set.
                 // this is why we now use fallbacks for 'menu' and 'panel` above too(not just for 'ncurses' lib)
                 // that is, when pkgconf or pkg-config are missing, yet the libs are there.
-                println!("cargo:warning=Using fallback lib name '{}' but if compilation fails below(like when linking ex_5 with 'menu' feature), that is why. It's likely you have not installed one of ['pkg-config' or 'pkgconf'], and/or 'ncurses' (it's package 'ncurses-devel' on Fedora). This seems to work fine on FreeBSD 14 regardless, however to not see this warning and to ensure 100% compatibility(on any OS) be sure to install, on FreeBSD, at least `pkgconf` if not both ie. `# pkg install ncurses pkgconf`.", what_lib);
-                what_lib
+                // Print the warning message, but use old style warning with one ":" not two "::",
+                // because old cargos(pre 23 Dec 2023) will simply ignore it and show no warning if it's "::"
+                println!("cargo:warning=Using (untested)fallback lib name '{}' but if compilation fails below(like when linking ex_5 with 'menu' feature), that is why. It's likely you have not installed one of ['pkg-config' or 'pkgconf'], and/or 'ncurses' (it's package 'ncurses-devel' on Fedora). This seems to work fine on FreeBSD 14 regardless, however to not see this warning and to ensure 100% compatibility(on any OS) be sure to install, on FreeBSD, at least `pkgconf` if not both ie. `# pkg install ncurses pkgconf`.", what_lib);
+                //fallback lib name: 'ncurses' or 'ncursesw'
+                //if this fails later, there's the warning above to get an idea as to why.
+                lib_name = what_lib;
             }
         }
     };
     if !already_printed {
+        //TODO: try_link() ? then refactor the warning messages.
         println!("cargo:rustc-link-lib={}", lib_name);
     }
     lib_name

From 4c99e99574127631979be04b8eacba8902f2c8d6 Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Wed, 17 Apr 2024 13:21:34 +0200
Subject: [PATCH 32/54] use same indent and flush output in genconstants.c

* using tabs as indents, rather than mixture of tabs/spaces
* flush stdout/stderr just to be extra safe (wasn't not needed so far)
* add commented out segfault-causing line when testing build.rs manually
  This segfault needs to be done before initscr/endwin or else the terminal
  seems messed up and you've to run 'reset' to restore it, plus you
  don't see the outputs properly.
---
 src/genconstants.c | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/src/genconstants.c b/src/genconstants.c
index 44987ae2..c6cf0516 100644
--- a/src/genconstants.c
+++ b/src/genconstants.c
@@ -4,11 +4,12 @@
 #define PCONSTU(ty, NAME) printf("pub const " #NAME ": " #ty " = %llu;\n", (unsigned long long) (NAME))
 
 int main() {
-        /* some values aren't set until after this is run */
-        printf("//");
+	/* some values aren't set until after this is run */
+	printf("//");
+	//fflush(stdout);fflush(stderr);*((int *)0) = 42; //segfault(on purpose for testing purposes) before terminal gets messed up needing a `reset` shell command to restore!
 	initscr();
 	endwin();
-        printf("\n");
+	printf("\n");
 
 	/* Success/Failure. */
 	PCONST(i32, ERR);
@@ -296,4 +297,7 @@ int main() {
 	PCONSTU(crate::ll::chtype, A_ATTRIBUTES);
 	PCONSTU(crate::ll::chtype, A_CHARTEXT);
 	PCONSTU(crate::ll::chtype, A_COLOR);
+
+	//do last, flush just to be sure!
+	fflush(stdout);fflush(stderr);
 }

From 19b2aeb742332ad403cd009f7f84c468ef4fae5e Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Wed, 17 Apr 2024 19:39:03 +0200
Subject: [PATCH 33/54] some build.rs deduppage and improvements

* handles some a case with lib tinfo building like when setting
TINFOW_NO_PKG_CONFIG=1 env. var
* dedup some common code so changes won't have to be made in two/more places
* added some todos/fixmes
* made source for chtype_size.c not need escaping inside build.rs via br#"..."#
* unified cargo:rerun-if-env-changed={} under one function: watch_env_var()
* some comments
* typo: `Couldn't create rust file` was wrong, it was a `C file`
* ...
---
 build.rs | 576 ++++++++++++++++++++++++++++++++++++-------------------
 1 file changed, 381 insertions(+), 195 deletions(-)

diff --git a/build.rs b/build.rs
index 4213f4a3..8928eb70 100644
--- a/build.rs
+++ b/build.rs
@@ -17,8 +17,9 @@ use pkg_config::Library;
 use std::env;
 use std::ffi::OsStr;
 use std::ffi::OsString;
+use std::fmt::Write as required_for_writeln_macro;
 use std::fs::File;
-use std::io::Write;
+use std::io::Write as required_for_write_all_function; //in File
 use std::os::unix::ffi::OsStrExt;
 use std::os::unix::ffi::OsStringExt;
 use std::path::Path;
@@ -47,6 +48,9 @@ const ENV_VAR_NAME_FOR_NCURSES_RS_RUSTC_FLAGS: &str = "NCURSES_RS_RUSTC_FLAGS";
 /// 4. "NCURSES_RS_CFLAGS" (our original wanted)
 /// and the first one that exists is used instead.
 /// see: https://docs.rs/cc/1.0.92/src/cc/lib.rs.html#3571-3580
+/// All of the _tried_ ones are emitted as: cargo:rerun-if-env-changed=
+/// which means, if NCURSES_RS_CFLAGS_x86_64_unknown_linux_gnu is set then NCURSES_RS_CFLAGS won't
+/// be emitted which makes sense as this one overrides the rest anyway.
 const ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS: &str = "NCURSES_RS_CFLAGS";
 
 const IS_WIDE: bool = cfg!(feature = "wide");
@@ -101,6 +105,7 @@ const TINFO_LIB_NAMES: &[&str] = if IS_WIDE_AND_NOT_ON_MACOS {
     //
     //These are tried in order and first that links is selected:
     &["tinfow5", "tinfow", "tinfo"]
+    //doneFIXME: here ^, user can have in env. this TINFOW_NO_PKG_CONFIG=1 (but not also TINFO_NO_PKG_CONFIG=1) which would cause seg fault on Gentoo because tinfo will be found&linked(instead of tinfow) with one or more of menuw,panelw,ncursesw eg. when doing example ex_5 (ie. menuw,ncursesw,tinfo(no w)); but on Fedora this ncursesw+tinfo(no w) makes sense(because tinfo(no w) has both inside it, somehow, i guess), so we can't really guard against this (well maybe with target_os but what if they change in the future...) instead maybe print a warning if w and non-w are mixed(but only for tinfo is needed), even though it will be a false warning on Fedora, well maybe it won't be if we also check if env. var is set TINFOW_NO_PKG_CONFIG.
 } else {
     //no reason to ever fallback to tinfow here when not-wide!
     //Fedora/Gentoo has ncurses+tinfo
@@ -118,7 +123,9 @@ const TINFO_LIB_NAMES: &[&str] = if IS_WIDE_AND_NOT_ON_MACOS {
 /// finds and emits cargo:rustc-link-lib=
 fn find_library(names: &[&str]) -> Option<Library> {
     for name in names {
+        //println!("cargo:warning=Trying lib '{}'",name);
         if let Ok(lib) = pkg_config::probe_library(name) {
+            //println!("cargo:warning=Found lib '{}' '{:?}'",name, lib);
             return Some(lib);
         }
     }
@@ -132,12 +139,7 @@ fn find_library(names: &[&str]) -> Option<Library> {
     feature = "dummy_feature_to_detect_that_--all-features_arg_was_used"
 ))]
 fn main() {
-    println!("cargo:rerun-if-env-changed=PKG_CONFIG_PATH");
-    println!(
-        "cargo:rerun-if-env-changed={}",
-        ENV_VAR_NAME_FOR_NCURSES_RS_RUSTC_FLAGS
-    );
-    println!("cargo:rerun-if-env-changed={}", ENV_VAR_NAME_FOR_LIB);
+    watch_env_var("PKG_CONFIG_PATH");
 
     let ncurses_lib = find_library(NCURSES_LIB_NAMES);
 
@@ -195,29 +197,58 @@ fn main() {
     // so when pkg-config is missing, how do we know which tinfo to tell cargo to link, if any!
     // doneFIXME: ^ I guess we gonna have to compile own .c to link with tinfo to see if it fails or
     // works!
-    if find_library(TINFO_LIB_NAMES).is_none() {
+    let tinfo_name = if let Some(found) = find_library(TINFO_LIB_NAMES) {
+        let libs = found.libs;
+        assert_eq!(
+            libs.len(),
+            1,
+            "Unexpected pkg-config query for tinfo lib returned more than one lib: '{:?}'",
+            libs
+        );
+        libs.first()
+            .unwrap_or_else(|| {
+                panic!(
+                    "Unexpected panic on trying to get the first found tinfo lib string from: '{:?}'.",
+                    libs
+                )
+            })
+            .clone()
+    } else {
+        //None found; but at least on NixOS it works without any tinfo(it's inside ncursesw lib and tinfo/ncurses all symlink to that same ncursesw.so, except tinfow which doesn't exist but pkg-config points it to -lncursesw), so no need to warn that we didn't find any tinfo.
         //Pick the tinfo lib to link with, as fallback,
         //the first one that links successfully!
         //The order in the list matters!
-        for each in TINFO_LIB_NAMES {
-            if try_link(each, &ncurses_lib) {
-                println!(
-                    "cargo:warning=Using lib fallback '{}' which links successfully.",
-                    each
-                );
-                //successfully linked with this tinfo variant,
-                //so let's use it as fallback
-                println!("cargo:rustc-link-lib={}", each);
-                break;
-            }
-        }
+        TINFO_LIB_NAMES
+            .iter()
+            .find(|&each| {
+                let ret: bool = try_link(each, &ncurses_lib);
+                if ret {
+                    println!(
+                        "cargo:warning=Using lib fallback '{}' which links successfully.",
+                        each
+                    );
+                    println!("cargo:rustc-link-lib={}", each);
+                }
+                ret
+            })
+            .unwrap_or_else(|| &"")
+            .to_string()
+    };
+    if IS_WIDE_AND_NOT_ON_MACOS
+        && tinfo_name == "tinfo"
+        && std::env::var("TINFOW_NO_PKG_CONFIG").is_ok()
+    {
+        println!("cargo:warning=Looks like you're using wide(and are not on macos) and you've set TINFOW_NO_PKG_CONFIG but have NOT set TINFO_NO_PKG_CONFIG too, so you're linking tinfo(no w) with other wide libs like ncursesw, which will cause '{}' eg. for example ex_5 when trying to run it. This is a warning not a panic because we assume you know what you're doing, and besides this works on Fedora (even if that env. var isn't set)!","Segmentation fault (core dumped)");
     }
+    //TODO: test on macos-es. When not using the brew ncurses, it won't have A_ITALIC and BUTTON5_*
+    //thus cursive will fail compilation. TODO: detect this and issue cargo:warning from here.
 
-    // gets the name of ncurses lib found by pkg-config, if it found any!
+    // Gets the name of ncurses lib found by pkg-config, if it found any!
     // else (warns and)returns the default one like 'ncurses' or 'ncursesw'
     // and emits cargo:rustc-link-lib= for it unless already done.
     let lib_name = get_ncurses_lib_name(&ncurses_lib);
 
+    watch_env_var(ENV_VAR_NAME_FOR_NCURSES_RS_RUSTC_FLAGS);
     if let Ok(x) = std::env::var(ENV_VAR_NAME_FOR_NCURSES_RS_RUSTC_FLAGS) {
         println!("cargo:rustc-flags={}", x);
     }
@@ -228,7 +259,7 @@ fn main() {
     //which depends on TERM env.var and will fail if TERM is wrong, say 'TERM=foo',
     //with: "Error opening terminal: foo." and exit code 1
     //therefore rebuild if TERM is changed without needing a 'cargo clean' first:
-    println!("cargo:rerun-if-env-changed=TERM",);
+    watch_env_var("TERM");
     gen_rs(
         "src/genconstants.c",
         "genconstants",
@@ -249,14 +280,57 @@ fn main() {
 }
 // -----------------------------------------------------------------
 
+//TODO: look into how to make doc tests and if they'd work with build.rs
+/// Creates file with the specified contents.
+/// Any existing file with that name is lost.
+/// Panics if file_name isn't prefixed by the value of OUT_DIR (at runtime) for extra safety.
+fn overwrite_file_contents(file_name: &str, contents: &[u8]) {
+    //Note: asserts in build.rs appear to be enabled even for cargo build --release, and can't be disabled(which is good, we want them on, always)
+    assert!(
+        file_name.starts_with(&get_out_dir()),
+        "The file name you wanted to create '{}' should be created in OUT_DIR only",
+        file_name
+    );
+    //FIXME: Maybe don't require utf-8 valid paths? by requiring &str here,
+    //the caller would do PathBuf::display() which replaces '\xFF' with the placeholder char
+    //which is the replacement character \u{FFFD}
+    //Many other programs break at compile time if path contains non-utf8 chars, before we even get here!
+    let mut file = File::create(file_name)
+        .unwrap_or_else(|err| panic!("Couldn't create file '{}', reason: '{}'", file_name, err));
+
+    file.write_all(contents).unwrap_or_else(|err| {
+        panic!(
+            "Couldn't write contents to file '{}', reason: '{}'",
+            file_name, err
+        )
+    });
+    drop(file); //explicit file close, not needed since it's in a function now!
+}
+
+fn get_out_dir() -> &'static str {
+    use std::sync::OnceLock;
+    static LOCK: OnceLock<String> = OnceLock::new();
+
+    //OUT_DIR is set by cargo during build
+    const ENV_NAME_OF_OUT_DIR: &str = "OUT_DIR";
+    LOCK.get_or_init(|| {
+        env::var(ENV_NAME_OF_OUT_DIR).unwrap_or_else(|err| {
+            panic!(
+                "Cannot get env.var. '{}', reason: '{}'. Use `cargo build` instead of running this build script binary directly!",
+                ENV_NAME_OF_OUT_DIR, err
+            )
+        })
+    })
+    //^ Rust automatically coerces the &String reference to a &str reference, making the function return type &'static str valid without any additional explicit conversion. This behavior is possible due to Deref coercion.
+}
+
 /// Tries to see if linker can find/link with the named library.
 /// Uses ncurses lib searchdirs(if any found by pkg-config) to find that lib.
 /// This is mainly used when pkg-config is missing.
-/// Should still work if pkg-config exists though.
-/// Returns true is linking succeeded, false otherwise.
+/// Should still work if pkg-config exists though(except it will be missing the found link searchdirs and thus might fail? TODO: test this on NixOS, with NCURSES(W)_NO_PKG_CONFIG=1 env.var, for something like menu(w) or panel(w) )
+/// Returns true if linking succeeded, false otherwise.
 fn try_link(lib_name: &str, ncurses_lib: &Option<Library>) -> bool {
-    //OUT_DIR is set by cargo during build
-    let out_dir = env::var("OUT_DIR").expect("cannot get OUT_DIR");
+    let out_dir = get_out_dir();
 
     //We won't execute it though, so doesn't matter if it's .exe for Windows
     let out_bin_fname = format!("try_link_with_{}", lib_name);
@@ -267,21 +341,9 @@ fn try_link(lib_name: &str, ncurses_lib: &Option<Library>) -> bool {
         .display()
         .to_string();
 
-    let mut file = File::create(&out_src_full).unwrap_or_else(|err| {
-        panic!(
-            "Couldn't create rust file '{}', reason: '{}'",
-            out_src_full, err
-        )
-    });
-
-    let source_code = b"int main() { return 0; }";
-    file.write_all(source_code).unwrap_or_else(|err| {
-        panic!(
-            "Couldn't write to C file '{}', reason: '{}'",
-            out_src_full, err
-        )
-    });
-    drop(file); //explicit file close
+    let source_code = b"int main(void) { return 0; }";
+    overwrite_file_contents(&out_src_full, source_code);
+    //TODO: remove commented out code everywhere in build.rs
 
     let build = cc::Build::new();
     let mut linker_searchdir_args: Vec<String> = Vec::new();
@@ -295,10 +357,7 @@ fn try_link(lib_name: &str, ncurses_lib: &Option<Library>) -> bool {
         }
     }
 
-    let compiler = build
-        .try_get_compiler()
-        .expect("Failed Build::try_get_compiler");
-    let mut command = compiler.to_command();
+    let mut command = get_the_compiler_command_from_build(build);
 
     let out_bin_full = Path::new(&out_dir)
         .join(out_bin_fname)
@@ -315,7 +374,7 @@ fn try_link(lib_name: &str, ncurses_lib: &Option<Library>) -> bool {
         .args_checked(["-l", lib_name])
         .args_checked(linker_searchdir_args);
     let exit_status = command.status_or_panic(); //runs compiler
-    let ret = exit_status.success();
+    let ret: bool = exit_status.success();
 
     if DELETE_GENERATEDS {
         if ret {
@@ -338,10 +397,40 @@ fn try_link(lib_name: &str, ncurses_lib: &Option<Library>) -> bool {
     return ret;
 }
 
-fn build_wrap(ncurses_lib: &Option<Library>) {
-    println!("cargo:rerun-if-changed=src/wrap.c");
+//TODO: change this to apply to anything that's emitted for cargo to consume, except warnings, and
+//make it HashMap with a counter.
+/// Emits "cargo:rerun-if-env-changed=ENV_VAR" on stdout
+/// only once for each ENV_VAR
+/// regardless of how many times it gets called.
+fn watch_env_var(env_var: &'static str) {
+    assert!(!env_var.is_empty(), "Passed empty env.var. to watch for.");
+    use std::collections::HashSet;
+    use std::sync::OnceLock;
+    use std::sync::{Arc, RwLock};
+    // static gets inited only once before main() and is scoped only to this function
+    static SHARED_DATA: OnceLock<Arc<RwLock<HashSet<&'static str>>>> = OnceLock::new();
+    //the inner value (hashset) is inited only once on first call of this function
+    let hs = SHARED_DATA.get_or_init(|| Arc::new(RwLock::new(HashSet::new())));
+    // Acquire a write lock to atomically check and insert if necessary
+    if let Ok(mut guard) = hs.write() {
+        // Critical section where the lock is held
+        if !guard.contains(env_var) {
+            println!("cargo:rerun-if-env-changed={}", env_var);
+            guard.insert(env_var);
+        }
+    } //lock released here
+
+    //TODO: can use HashMap(since HashSet I hear is just a HashMap underneath) and keep a counter as val
+    //this way we'd know how many times an env.var. tried to be emitted, but for what reason we'd
+    //wanna know though...
+}
+
+/// set some sensible defaults
+fn new_build(lib: &Option<Library>) -> cc::Build {
+    //XXX: Note: env.var. "CC" can override the compiler used and will cause rebuild if changed.
     let mut build = cc::Build::new();
-    if let Some(lib) = ncurses_lib {
+    if let Some(lib) = lib {
+        //header file paths eg. for ncurses.h
         build.includes(&lib.include_paths);
         //for path in lib.include_paths.iter() {
         //    build.include(path);
@@ -349,11 +438,49 @@ fn build_wrap(ncurses_lib: &Option<Library>) {
     }
     build.opt_level(1); //else is 0, causes warning on NixOS: _FORTIFY_SOURCE requires compiling with optimization (-O)
 
-    // The following creates `libwrap.a` on linux, but what does it create on Windows?(via pancurses)
+    //XXX:Don't have to emit cargo:rerun-if-env-changed= here because try_flags_from_environment()
+    //below does it for us, however it does it on every call! (unless Build::emit_rerun_if_env_changed(false))
+    //but if an overriding variant of it is defined like NCURSES_RS_CFLAGS_x86_64_unknown_linux_gnu
+    //then this weaker one won't be emitted because the override will be the only one in effect.
+    //We could forcefully emit anyway, but no point, it will be ignored and just rebuild for no reason.
+    //watch_env_var(ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS);
+
+    //See comment above the const var def. to understand which env.vars are tried here:
+    let _ = build.try_flags_from_environment(ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS);
+
+    //these two are already in from the default Build
+    //build.flag_if_supported("-Wall");
+    //build.flag_if_supported("-Wextra");
+    build.flag_if_supported("-Wpedantic");
+    //build.flag_if_supported("-Wstrict-prototypes");//maybe fix me: triggers warnings in wrap.c
+    build.flag_if_supported("-Weverything"); //only clang
+
+    return build; // explicit return makes it more obvious that the ";" is missing so it's a return!
+}
+
+fn build_wrap(ncurses_lib: &Option<Library>) {
+    // build.file(source_file), below, doesn't emit this:
+    println!("cargo:rerun-if-changed=src/wrap.c");
+    let mut build = new_build(ncurses_lib);
+
+    // The following creates `libwrap.a` on linux, a static lib
     build.file("src/wrap.c").compile("wrap");
     //the resulting lib will be kept until deleted by 'cargo clean'
 }
 
+fn get_the_compiler_command_from_build(build: cc::Build) -> std::process::Command {
+    //'cc::Build' can do only lib outputs but we want a binary
+    //so we get the command (and args) thus far set and add our own args.
+    //Presumably all args will be kept, as per: https://docs.rs/cc/1.0.92/cc/struct.Build.html#method.get_compiler
+    //(though at least the setting for build.file(source_c_file) won't be,
+    // but we don't use that way and instead set it later as an arg to compiler)
+    let compiler = build
+        .try_get_compiler()
+        .expect("Failed Build::try_get_compiler");
+    let command = compiler.to_command();
+    return command;
+}
+
 /// Compiles an existing .c file, runs its bin to generate a .rs file from its output.
 /// Uses ncurses include paths and links with ncurses lib(s)
 // Note: won't link with tinfo unless pkg-config returned it.
@@ -366,45 +493,26 @@ fn gen_rs(
     ncurses_lib: &Option<Library>,
     lib_name: &str,
 ) {
+    //TODO: see if build.file() already emits this!
     println!("cargo:rerun-if-changed={}", source_c_file);
-    let out_dir = env::var("OUT_DIR").expect("cannot get OUT_DIR");
+    let out_dir = get_out_dir();
     #[cfg(windows)]
-    let out_bin_fname = format!("{}.exe", out_bin_fname);
+    let out_bin_fname = format!("{}.exe", out_bin_fname); //shadowed
     let bin_full = Path::new(&out_dir)
         .join(out_bin_fname)
         .display()
         .to_string();
 
-    //Note: env.var. "CC" can override the compiler used and will cause rebuild if changed.
-    let mut build = cc::Build::new();
+    let build = new_build(ncurses_lib);
     let mut linker_searchdir_args: Vec<String> = Vec::new();
     if let Some(lib) = ncurses_lib {
-        build.includes(&lib.include_paths);
-        //for path in lib.include_paths.iter() {
-        //    build.include(path);
-        //}
         for link_path in &lib.link_paths {
             linker_searchdir_args.push("-L".to_string());
             linker_searchdir_args.push(link_path.display().to_string());
         }
     }
 
-    println!(
-        "cargo:rerun-if-env-changed={}",
-        ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS
-    );
-
-    let _ = build.try_flags_from_environment(ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS);
-
-    //'cc::Build' can do only lib outputs but we want a binary
-    //so we get the command (and args) thus far set and add our own args.
-    //Presumably all args will be kept, as per: https://docs.rs/cc/1.0.92/cc/struct.Build.html#method.get_compiler
-    //(though at least the setting for build.file(source_c_file) won't be,
-    // but we don't use that way and instead set it later as an arg to compiler)
-    let compiler = build
-        .try_get_compiler()
-        .expect("Failed Build::try_get_compiler");
-    let mut command = compiler.to_command();
+    let mut command = get_the_compiler_command_from_build(build);
 
     //create a bin(not a lib) from a .c file
     //adding the relevant args for the libs that we depend upon such as ncurses
@@ -419,51 +527,23 @@ fn gen_rs(
     //Execute the compiled binary, panicking if non-zero exit code, else compilation will fail
     //later with things like: "error[E0432]: unresolved import `constants::TRUE`" in the case of
     //generating raw_constants.rs which would be empty due to 'genconstants' having failed with exit
-    //code 1
-    let consts = Command::new(&bin_full)
-        .output() // TODO: maybe make this a trait extension and dedup code
-        .unwrap_or_else(|err| panic!("Executing '{}' failed, reason: '{}'", bin_full, err));
-    let exit_code = consts.status.code().unwrap_or_else(|| {
-        panic!(
-            "Execution of '{}' failed, possibly killed by signal? stderr is: '{}'",
-            bin_full,
-            String::from_utf8_lossy(&consts.stderr)
-        )
-    });
-    assert_eq!(
-        exit_code,
-        0,
-        "Executing '{}' failed with exit code '{}',\n|||stdout start|||\n{}\n|||stdout end||| |||stderr start|||\n{}\n|||stderr end|||\n!! Maybe you need to try a different value for the TERM environment variable !!",
-        bin_full,
-        exit_code,
-        String::from_utf8_lossy(&consts.stdout),
-        String::from_utf8_lossy(&consts.stderr),
-    );
+    //code 1 because env.var. TERM=a_terminal_not_in_term_database
+    let output: std::process::Output = Command::new(&bin_full).output_success_or_panic();
 
-    //write the output from executing the binary into a new rust source file .rs
-    //that .rs file is later used outside of this build.rs, in the normal build
+    //Write the output from executing the binary into a new rust source file .rs
+    //That .rs file is later used outside of this build.rs, in the normal build
     let gen_rust_file_full_path = Path::new(&out_dir)
         .join(gen_rust_file)
         .display()
         .to_string();
-    let mut file = File::create(&gen_rust_file_full_path).unwrap_or_else(|err| {
-        panic!(
-            "Couldn't create rust file '{}', reason: '{}'",
-            gen_rust_file_full_path, err
-        )
-    });
-
-    file.write_all(&consts.stdout).unwrap_or_else(|err| {
-        panic!(
-            "Couldn't write to rust file '{}', reason: '{}'",
-            gen_rust_file_full_path, err
-        )
-    });
+    overwrite_file_contents(&gen_rust_file_full_path, &output.stdout);
+    //we ignore stderr.
+    //we don't delete this file because it's used to compile the rest of the crate.
 }
 
 fn check_chtype_size(ncurses_lib: &Option<Library>) {
-    let out_dir = env::var("OUT_DIR").expect("cannot get OUT_DIR");
-    let src = Path::new(&out_dir)
+    let out_dir = get_out_dir();
+    let src_full = Path::new(&out_dir)
         .join("chtype_size.c")
         .display()
         .to_string();
@@ -474,10 +554,7 @@ fn check_chtype_size(ncurses_lib: &Option<Library>) {
     };
     let bin_full = Path::new(&out_dir).join(bin_name).display().to_string();
 
-    let mut fp = File::create(&src)
-        .unwrap_or_else(|err| panic!("cannot create '{}', reason: '{}'", src, err));
-    fp.write_all(
-        b"
+    let contents = br#"// autogenerated by build.rs
 #include <assert.h>
 #include <limits.h>
 #include <stdio.h>
@@ -487,68 +564,40 @@ fn check_chtype_size(ncurses_lib: &Option<Library>) {
 int main(void)
 {
     if (sizeof(chtype)*CHAR_BIT == 64) {
-        puts(\"cargo:rustc-cfg=feature=\\\"wide_chtype\\\"\");
+        puts("cargo:rustc-cfg=feature=\"wide_chtype\"");
     } else {
         /* We only support 32-bit and 64-bit chtype. */
-        assert(sizeof(chtype)*CHAR_BIT == 32 && \"unsupported size for chtype\");
+        assert(sizeof(chtype)*CHAR_BIT == 32 && "unsupported size for chtype");
     }
 
 #if defined(NCURSES_MOUSE_VERSION) && NCURSES_MOUSE_VERSION == 1
-	puts(\"cargo:rustc-cfg=feature=\\\"mouse_v1\\\"\");
+    puts("cargo:rustc-cfg=feature=\"mouse_v1\"");
 #endif
     return 0;
 }
-    ",
-    )
-    .unwrap_or_else(|err| panic!("cannot write into file '{}', reason: '{}'", src, err));
-    drop(fp); //explicit file close (flush)
+"#;
+    overwrite_file_contents(&src_full, contents);
 
-    let mut build = cc::Build::new();
-    if let Some(lib) = ncurses_lib {
-        build.includes(&lib.include_paths);
-        //for path in lib.include_paths.iter() {
-        //    build.include(path);
-        //}
-    }
+    let build = new_build(ncurses_lib);
 
-    let _ = build.try_flags_from_environment(ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS);
+    let mut command = get_the_compiler_command_from_build(build);
 
-    let compiler = build
-        .try_get_compiler()
-        .expect("Failed Build::try_get_compiler");
-    let mut command = compiler.to_command();
-
-    command.arg("-o").arg_checked(&bin_full).arg_checked(&src);
+    command
+        .arg("-o")
+        .arg_checked(&bin_full)
+        .arg_checked(&src_full);
     command.success_or_panic(); //runs compiler
 
-    let features = Command::new(&bin_full)
-        .output() // TODO: maybe make this a trait extension and dedup code
-        .unwrap_or_else(|err| panic!("Executing '{}' failed, reason: '{}'", bin_full, err));
-    let exit_code = features.status.code().unwrap_or_else(|| {
-        panic!(
-            "Execution of '{}' failed, possibly killed by signal? stderr is: '{}'",
-            bin_full,
-            String::from_utf8_lossy(&features.stderr)
-        )
-    });
-    assert_eq!(
-        exit_code,
-        0,
-        "Executing '{}' failed with exit code '{}',\n|||stdout start|||\n{}\n|||stdout end||| |||stderr start|||\n{}\n|||stderr end|||",
-        bin_full,
-        exit_code,
-        String::from_utf8_lossy(&features.stdout),
-        String::from_utf8_lossy(&features.stderr),
-    );
+    let features = Command::new(&bin_full).output_success_or_panic();
 
     //for cargo to consume
     print!("{}", String::from_utf8_lossy(&features.stdout));
 
     if DELETE_GENERATEDS {
-        std::fs::remove_file(&src).unwrap_or_else(|err| {
+        std::fs::remove_file(&src_full).unwrap_or_else(|err| {
             panic!(
                 "Cannot delete generated C file '{}', reason: '{}'",
-                src, err
+                src_full, err
             )
         });
         std::fs::remove_file(&bin_full).unwrap_or_else(|err| {
@@ -565,6 +614,7 @@ fn get_ncurses_lib_name(ncurses_lib: &Option<Library>) -> String {
     //Was it found(and thus printed) by pkg_config::probe_library() ?
     let mut already_printed: bool = false;
     let lib_name: String;
+    watch_env_var(ENV_VAR_NAME_FOR_LIB);
     match std::env::var(ENV_VAR_NAME_FOR_LIB) {
         Ok(value) => lib_name = value,
         Err(_) => {
@@ -622,12 +672,48 @@ fn get_ncurses_lib_name(ncurses_lib: &Option<Library>) -> String {
     lib_name
 }
 
+//trait MyOutput {}
+//
+//impl MyOutput for std::process::Output {}
+
+trait MyExitStatus {
+    fn success_or_panic(self) -> ExitStatus;
+}
+
+impl MyExitStatus for std::process::ExitStatus {
+    fn success_or_panic(self) -> ExitStatus {
+        if self.success() {
+            self
+        } else {
+            let how: String;
+            if let Some(code) = self.code() {
+                how = format!(" with exit code {}.", code);
+            } else {
+                how = ", was it terminated by a signal?!".to_string();
+            }
+            panic!(
+                "!!! Compiler failed{} Is ncurses installed? \
+        pkg-config or pkgconf too? \
+        it's 'ncurses-devel' on Fedora; \
+        run `nix-shell` first, on NixOS. \
+        Or maybe it failed for different reasons which are seen in the errored output above.",
+                how
+            )
+        }
+    }
+}
+
 // Define an extension trait for Command
 trait MyCompilerCommand {
+    fn output_or_panic(&mut self) -> std::process::Output;
+    fn output_success_or_panic(&mut self) -> std::process::Output;
     fn success_or_panic(&mut self) -> ExitStatus;
     //fn success_or_else<F: FnOnce(ExitStatus) -> ExitStatus>(&mut self, op: F) -> ExitStatus;
+    fn just_status_or_panic(&mut self) -> ExitStatus;
     fn status_or_panic(&mut self) -> ExitStatus;
+    fn status_or_panic_but_no_check_args(&mut self) -> ExitStatus;
     fn show_what_will_run(&mut self) -> &mut Self;
+    fn get_program_or_panic(&self) -> &str;
     fn get_what_will_run(&self) -> (String, usize, String);
     fn assert_no_nul_in_args(&mut self) -> &mut Self;
     /// Panics if arg has \0 in it.
@@ -639,6 +725,7 @@ trait MyCompilerCommand {
     /// otherwise the original Command::arg would've set it to "<string-with-nul>"
     /// Doesn't do any other checks, passes it to Command::arg()
     fn arg_checked<S: AsRef<OsStr>>(&mut self, arg: S) -> &mut Command;
+    fn panic<T: std::fmt::Display>(&mut self, err: T, what_type_of_command: &str) -> !;
 }
 
 fn has_null_byte<S: AsRef<OsStr>>(arg: S) -> bool {
@@ -651,39 +738,95 @@ fn has_null_byte<S: AsRef<OsStr>>(arg: S) -> bool {
     false
 }
 
-/// args with \0 in them, passed to std::process::Command::arg() or ::args()
-/// get replaced entirely with this: "<string-with-nul>"
+/// Args with \0 in them, passed to std::process::Command::arg() or ::args()
+/// get replaced(by those calls)entirely with this: "<string-with-nul>"
 const REPLACEMENT_FOR_ARG_THAT_HAS_NUL: &str = "<string-with-nul>";
-// Implement the extension trait for Command
-impl MyCompilerCommand for Command {
-    /// you can't use an arg value "<string-with-nul>", or this will panic.
-    fn success_or_panic(&mut self) -> ExitStatus {
-        let exit_status: ExitStatus = self
-            .show_what_will_run()
-            .assert_no_nul_in_args()
-            .status_or_panic();
-        if exit_status.success() {
-            exit_status
-        } else {
-            let how: String;
-            if let Some(code) = exit_status.code() {
-                how = format!(" with exit code {}", code);
-            } else {
-                how = ", was terminated by a signal".to_string();
-            }
+// Implement the extension trait for Command, so you can use methods on a Command instance even
+// though it's a type that's not defined here but in std::process
+impl MyCompilerCommand for std::process::Command {
+    /// Executes Command::output() and gives you Output struct or panics
+    /// but the exit code may not have been 0
+    fn output_or_panic(&mut self) -> std::process::Output {
+        self.output().unwrap_or_else(|err| {
+            self.panic(err, "generated bin"); //TODO: let caller provide this
+        })
+    }
+
+    /// Executes Command::output() and gives you Output struct or panics
+    /// also panics if exit code was not 0 and shows you stdout/stderr if so.
+    fn output_success_or_panic(&mut self) -> std::process::Output {
+        let output = self.output_or_panic();
+        // test this with: `$ TERM=foo cargo build`
+        let show_stdout_stderr = || {
+            //XXX: presumably eprintln! and std::io::stderr().write_all().unwrap() write to same stderr
+            //stream and both would panic if some error would happen when writing to it!
+            eprintln!("But here's its stdout&stderr:");
+            eprintln!("|||stdout start|||");
+            //Preserve stdout/stderr bytes, instead of lossily convert them to utf-8 before showing them.
+            //show stdout of executed binary, on stderr
+            std::io::stderr().write_all(&output.stdout).unwrap();
+            eprintln!("\n|||stdout end||| |||stderr start|||");
+            //show stderr of executed binary, on stderr
+            std::io::stderr().write_all(&output.stderr).unwrap();
+            eprintln!("\n|||stderr end|||");
+        };
+        let prog = self.get_program_or_panic();
+        let and_panic = || -> ! {
             panic!(
-                "Compiler failed{}. Is ncurses installed? \
-        pkg-config or pkgconf too? \
-        it's 'ncurses-devel' on Fedora; \
-        run `nix-shell` first, on NixOS. \
-        Or maybe it failed for different reasons which are seen in the errored output above.",
-                how
-            )
+                "due to the above-reported error while executing '{}'.",
+                //self.get_program_or_panic()
+                prog
+            );
+        };
+
+        let exit_code = output.status.code().unwrap_or_else(|| {
+            //we get here if it segfaults(signal 11), so if exited due to signal
+            //but unsure if we get here for any other reasons!
+            //To test this branch uncomment a segfault line early in src/genconstants.c then `cargo build`
+
+            let basename=Path::new(prog).file_name().unwrap_or_else(|| {
+                eprintln!("Couldn't get basename for '{}'", prog);
+                OsStr::new("") //refusing to panic over this
+            });
+            let basename=basename.to_str().unwrap_or_else(|| {
+                eprintln!("Couldn't convert OsStr '{:?}' to &str", basename);
+                "" //refusing to panic over this
+            });
+            eprintln!(
+                "!!! Execution of '{}' failed, likely killed by signal! Maybe check 'dmesg' for the word \"segfault\" or \"{}\". We can't know here, which signal happened.",
+                prog, basename
+                );
+            show_stdout_stderr();
+            and_panic();
+        });
+        if 0 != exit_code {
+            eprintln!(
+                "!!! Execution of '{}' failed with exit code '{}'",
+                prog, exit_code
+            );
+            show_stdout_stderr();
+            eprintln!(
+                //FIXME: this msg can't be part of the (future)extension trait impl, it's for src/genconstants.c only.
+                "!! Maybe you need to try a different value for the TERM environment variable !!"
+            );
+            and_panic();
+        } else {
+            return output;
         }
     }
-    //note: can't override arg/args because they're not part of a Trait in Command
+
+    /// Executes Command::status().success() and panics if it any fail
+    /// This means exit code 0 is ensured.
+    /// Note: You can't use an arg value "<string-with-nul>", or this will panic.
+    fn success_or_panic(&mut self) -> ExitStatus {
+        let exit_status: ExitStatus = self.status_or_panic().success_or_panic();
+        exit_status
+    }
+
+    //XXX: can't override arg/args because they're not part of a Trait in Command
     //so would've to wrap Command in my own struct for that. This would've ensured
     //that any added args were auto-checked.
+    /// panics if any args have \0 aka nul in it, else Command will panic later, on execution.
     fn args_checked<I, S>(&mut self, args: I) -> &mut Command
     where
         I: IntoIterator<Item = S>,
@@ -694,6 +837,8 @@ impl MyCompilerCommand for Command {
         }
         self
     }
+
+    /// panics if arg has \0 aka nul in it, else Command will panic later, on execution.
     fn arg_checked<S: AsRef<OsStr>>(&mut self, arg: S) -> &mut Command {
         if has_null_byte(&arg) {
             //If the arg has NUL ie. \0  in it then arg got replaced already
@@ -708,6 +853,7 @@ impl MyCompilerCommand for Command {
         }
         self.arg(arg)
     }
+
     /// Beware if user set the arg on purpose to the value of REPLACEMENT_FOR_ARG_THAT_HAS_NUL
     /// which is "<string-with-nul>" then this will panic, it's a false positive.
     fn assert_no_nul_in_args(&mut self) -> &mut Self {
@@ -728,11 +874,18 @@ impl MyCompilerCommand for Command {
         }
         self
     }
-    fn get_what_will_run(&self) -> (String, usize, String) {
+
+    fn get_program_or_panic(&self) -> &str {
         let program = self.get_program();
         let p_prog = program
             .to_str()
             .unwrap_or_else(|| panic!("Compiler executable {:?} isn't valid rust string", program));
+        //TODO: "Compiler" is too specific here, could be we're running just a bin we created!
+        p_prog
+    }
+
+    fn get_what_will_run(&self) -> (String, usize, String) {
+        let p_prog = self.get_program_or_panic();
         let args = self.get_args();
         let how_many_args: usize = args.len();
         let formatted_args: String = args
@@ -747,7 +900,7 @@ impl MyCompilerCommand for Command {
                     //None aka not fully utf8 arg
                     //then we show it as ascii + hex
                     let mut broken_arg = String::new();
-                    use std::fmt::Write; // can't globally import this ^, conflicts with std::io::Write
+                    //use std::fmt::Write; // can't globally import this ^, conflicts with std::io::Write
                     for byte in arg.as_bytes() {
                         match std::char::from_u32(*byte as u32) {
                             Some(c) if c.is_ascii() => broken_arg.push(c),
@@ -771,23 +924,56 @@ impl MyCompilerCommand for Command {
             format!("\"{}\"", formatted_args),
         )
     }
+
     /// just like Command::status() but panics if it can't execute it,
     /// ie. if status() would've returned an Err
     /// returns ExitStatus whether it be 0 or !=0
-    fn status_or_panic(&mut self) -> ExitStatus {
+    /// Doesn't show you what will be executed and doesn't check args.
+    /// (not meant to be used outside)
+    fn just_status_or_panic(&mut self) -> ExitStatus {
         // Call the original status() method and handle the potential error
         self.status().unwrap_or_else(|err| {
-            let (p_prog, how_many_args, formatted_args) = self.get_what_will_run();
-            panic!(
-                "Failed to run compilation command '{}' with '{}' args: '{}', reason: '{}'",
-                p_prog, how_many_args, formatted_args, err
-            )
+            self.panic(err, "compilation"); //TODO: let caller provide this?!
         })
     }
+
+    /// Shows command that will execute and checks args, only after this
+    /// it's gonna be trying to do .status()
+    /// Panics if status would've returned an Err
+    fn status_or_panic(&mut self) -> ExitStatus {
+        self.show_what_will_run()
+            .assert_no_nul_in_args()
+            .just_status_or_panic()
+    }
+
+    /// Used only for build.rs tests:
+    /// this should be exactly like status_or_panic() except it won't check that args
+    /// aren't nul-containing and thus won't panic before the original status() gets run, thus
+    /// allowing it to panic on nul.
+    /// (not meant to be used outside)
+    fn status_or_panic_but_no_check_args(&mut self) -> ExitStatus {
+        self.show_what_will_run().just_status_or_panic()
+    }
+
+    /// (not meant to be used outside)
+    fn panic<T: std::fmt::Display>(&mut self, err: T, what_type_of_command: &str) -> ! {
+        let (p_prog, how_many_args, formatted_args) = self.get_what_will_run();
+        let extra_space = if what_type_of_command.is_empty() {
+            ""
+        } else {
+            " "
+        };
+        panic!(
+            "Failed to run {}{}command '{}' with '{}' args: '{}', reason: '{}'",
+            what_type_of_command, extra_space, p_prog, how_many_args, formatted_args, err
+        )
+    }
+
+    /// shows on stderr, which command will be executed.
     fn show_what_will_run(&mut self) -> &mut Self {
         let (exe_name, how_many_args, formatted_args) = self.get_what_will_run();
         eprintln!(
-            "Next, attempting to run compilation command '{}' with '{}' args: '{}'",
+            "!! Next, attempting to run compilation command '{}' with '{}' args: '{}'",
             exe_name, how_many_args, formatted_args
         );
         self
@@ -907,7 +1093,7 @@ fn test_panic_for_command_non_zero_exit() {
         command.args(args_fail);
         command.success_or_panic();
     });
-    let expected_panic_msg = "Compiler failed with exit code 43. Is ncurses installed? pkg-config or pkgconf too? it's 'ncurses-devel' on Fedora; run `nix-shell` first, on NixOS. Or maybe it failed for different reasons which are seen in the errored output above.";
+    let expected_panic_msg = "!!! Compiler failed with exit code 43. Is ncurses installed? pkg-config or pkgconf too? it's 'ncurses-devel' on Fedora; run `nix-shell` first, on NixOS. Or maybe it failed for different reasons which are seen in the errored output above.";
     expect_panic(result, expected_panic_msg);
 }
 
@@ -956,7 +1142,7 @@ fn test_nul_in_arg_unchecked() {
             OsString::from("a\0rg2"),
             OsString::from_vec(b"my\xffarg3".to_vec()),
         ]);
-        command.status_or_panic();
+        command.status_or_panic_but_no_check_args();
     });
     expect_panic(result,
          "Failed to run compilation command 'test_nul_in_arg_unchecked.exe' with '3' args: '\"arg1\" \"<string-with-nul>\" \"my\\xFFarg3\"', reason: 'nul byte found in provided data'"

From b484d3328285309e1a84df7453edf697f84dfdd9 Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Fri, 19 Apr 2024 12:51:16 +0200
Subject: [PATCH 34/54] make undefined symbols more useful in dependants

When a crate(like 'cursive') that uses our crate(ncurses) wants to use
a symbol that we haven't defined because the system installed ncurses
header didn't define, such as BUTTON5_PRESSED, then show a better
compile time error like [1] instead of the usual and more vague one [2]

[1]:
   Compiling cursive v0.20.0 (/Users/user/sandbox/25/ncurses_things/cursive/cursive)
error[E0605]: non-primitive cast: `Your_ncurses_installation_is_too_old_and_it_does_not_have_this_underlined_identifier_defined_in_its_header_file_therefore_the_ncurses_crate_did_not_include_it_because_it_tries_to_be_compatible_however_this_crate_in_which_you_see_the_error_it_needs_the_identifier__If_you_are_on_MacOS_then_use_the_brew_version_of_ncurses_and_set_PKG_CONFIG_PATH_to_the_pkgconfig_dir_from_within_it` as `u32`
   --> cursive/src/backends/curses/n.rs:266:43
    |
266 | ....bstate == ncurses::BUTTON5_DOUBLE_CLICKED as mmask_t)
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error[E0308]: `match` arms have incompatible types
   --> cursive/src/backends/curses/n.rs:363:31
    |
357 |           let style = match effect {
    |  _____________________-
358 | |             Effect::Reverse => ncurses::A_REVERSE,
359 | |             Effect::Simple => ncurses::A_NORMAL,
360 | |             Effect::Dim => ncurses::A_DIM,
361 | |             Effect::Bold => ncurses::A_BOLD,
362 | |             Effect::Blink => ncurses::A_BLINK,
    | |                              ---------------- this and all prior arms are found to be of type `u32`
363 | |             Effect::Italic => ncurses::A_ITALIC,
    | |                               ^^^^^^^^^^^^^^^^^ expected `u32`, found `Your_ncurses_installation_is_too_old_and_it_does_not_have_this_underlined_identifier_defined_in_its_header_file_therefore_the_ncurses_crate_did_not_include_it_because_it_tries_to_be_compatible_however_this_crate_in_which_you_see_the_error_it_needs_the_identifier__If_you_are_on_MacOS_then_use_the_brew_version_of_ncurses_and_set_PKG_CONFIG_PATH_to_the_pkgconfig_dir_from_within_it`
364 | |             Effect::Strikethrough => ncurses::A_NORMAL,
365 | |             Effect::Underline => ncurses::A_UNDERLINE,
366 | |         };
    | |_________- `match` arms have incompatible types

error[E0308]: `match` arms have incompatible types
   --> cursive/src/backends/curses/n.rs:377:31
    |
371 |           let style = match effect {
    |  _____________________-
372 | |             Effect::Reverse => ncurses::A_REVERSE,
373 | |             Effect::Simple => ncurses::A_NORMAL,
374 | |             Effect::Dim => ncurses::A_DIM,
375 | |             Effect::Bold => ncurses::A_BOLD,
376 | |             Effect::Blink => ncurses::A_BLINK,
    | |                              ---------------- this and all prior arms are found to be of type `u32`
377 | |             Effect::Italic => ncurses::A_ITALIC,
    | |                               ^^^^^^^^^^^^^^^^^ expected `u32`, found `Your_ncurses_installation_is_too_old_and_it_does_not_have_this_underlined_identifier_defined_in_its_header_file_therefore_the_ncurses_crate_did_not_include_it_because_it_tries_to_be_compatible_however_this_crate_in_which_you_see_the_error_it_needs_the_identifier__If_you_are_on_MacOS_then_use_the_brew_version_of_ncurses_and_set_PKG_CONFIG_PATH_to_the_pkgconfig_dir_from_within_it`
378 | |             Effect::Strikethrough => ncurses::A_NORMAL,
379 | |             Effect::Underline => ncurses::A_UNDERLINE,
380 | |         };
    | |_________- `match` arms have incompatible types

error[E0308]: mismatched types
   --> cursive/src/backends/curses/n.rs:448:9
    |
427 |     match bare_event {
    |           ---------- this expression has type `i32`
...
448 |         ncurses::BUTTON5_RELEASED
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `Your_ncurses_installation_is_too_old_and_it_does_not_have_this_underlined_identifier_defined_in_its_header_file_therefore_the_ncurses_crate_did_not_include_it_because_it_tries_to_be_compatible_however_this_crate_in_which_you_see_the_error_it_needs_the_identifier__If_you_are_on_MacOS_then_use_the_brew_version_of_ncurses_and_set_PKG_CONFIG_PATH_to_the_pkgconfig_dir_from_within_it`

error[E0308]: mismatched types
   --> cursive/src/backends/curses/n.rs:449:11
    |
427 |     match bare_event {
    |           ---------- this expression has type `i32`
...
449 |         | ncurses::BUTTON5_PRESSED
    |           ^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `Your_ncurses_installation_is_too_old_and_it_does_not_have_this_underlined_identifier_defined_in_its_header_file_therefore_the_ncurses_crate_did_not_include_it_because_it_tries_to_be_compatible_however_this_crate_in_which_you_see_the_error_it_needs_the_identifier__If_you_are_on_MacOS_then_use_the_brew_version_of_ncurses_and_set_PKG_CONFIG_PATH_to_the_pkgconfig_dir_from_within_it`

error[E0308]: mismatched types
   --> cursive/src/backends/curses/n.rs:450:11
    |
427 |     match bare_event {
    |           ---------- this expression has type `i32`
...
450 |         | ncurses::BUTTON5_CLICKED
    |           ^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `Your_ncurses_installation_is_too_old_and_it_does_not_have_this_underlined_identifier_defined_in_its_header_file_therefore_the_ncurses_crate_did_not_include_it_because_it_tries_to_be_compatible_however_this_crate_in_which_you_see_the_error_it_needs_the_identifier__If_you_are_on_MacOS_then_use_the_brew_version_of_ncurses_and_set_PKG_CONFIG_PATH_to_the_pkgconfig_dir_from_within_it`

error[E0308]: mismatched types
   --> cursive/src/backends/curses/n.rs:451:11
    |
427 |     match bare_event {
    |           ---------- this expression has type `i32`
...
451 |         | ncurses::BUTTON5_DOUBLE_CLICKED
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `Your_ncurses_installation_is_too_old_and_it_does_not_have_this_underlined_identifier_defined_in_its_header_file_therefore_the_ncurses_crate_did_not_include_it_because_it_tries_to_be_compatible_however_this_crate_in_which_you_see_the_error_it_needs_the_identifier__If_you_are_on_MacOS_then_use_the_brew_version_of_ncurses_and_set_PKG_CONFIG_PATH_to_the_pkgconfig_dir_from_within_it`

error[E0308]: mismatched types
   --> cursive/src/backends/curses/n.rs:452:11
    |
427 |     match bare_event {
    |           ---------- this expression has type `i32`
...
452 |         | ncurses::BUTTON5_TRIPLE_CLICKED => MouseButton::Button5,
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `Your_ncurses_installation_is_too_old_and_it_does_not_have_this_underlined_identifier_defined_in_its_header_file_therefore_the_ncurses_crate_did_not_include_it_because_it_tries_to_be_compatible_however_this_crate_in_which_you_see_the_error_it_needs_the_identifier__If_you_are_on_MacOS_then_use_the_brew_version_of_ncurses_and_set_PKG_CONFIG_PATH_to_the_pkgconfig_dir_from_within_it`

error[E0308]: mismatched types
   --> cursive/src/backends/curses/n.rs:477:9
    |
469 |     match bare_event {
    |           ---------- this expression has type `i32`
...
477 |         ncurses::BUTTON5_PRESSED => f(MouseEvent::WheelDown),
    |         ^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `Your_ncurses_installation_is_too_old_and_it_does_not_have_this_underlined_identifier_defined_in_its_header_file_therefore_the_ncurses_crate_did_not_include_it_because_it_tries_to_be_compatible_however_this_crate_in_which_you_see_the_error_it_needs_the_identifier__If_you_are_on_MacOS_then_use_the_brew_version_of_ncurses_and_set_PKG_CONFIG_PATH_to_the_pkgconfig_dir_from_within_it`

Some errors have detailed explanations: E0308, E0605.
For more information about an error, try `rustc --explain E0308`.
error: could not compile `cursive` (lib) due to 9 previous errors
warning: build failed, waiting for other jobs to finish...
users-iMac:cursive user$

[2]:
   Compiling cursive v0.20.0 (/Users/user/sandbox/25/ncurses_things/cursive/cursive)
error[E0425]: cannot find value `BUTTON5_DOUBLE_CLICKED` in crate `ncurses`
   --> cursive/src/backends/curses/n.rs:266:52
    |
266 | ...bstate == ncurses::BUTTON5_DOUBLE_CLICKED as mmask_t)
    |                       ^^^^^^^^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `BUTTON1_DOUBLE_CLICKED`
    |
   ::: /Users/user/sandbox/25/ncurses_things/cursive/target/debug/build/ncurses-30bbd0fd652fa9fc/out/raw_constants.rs:129:1
    |
129 | pub const BUTTON1_DOUBLE_CLICKED: i32 = 8;
    | ------------------------------------- similarly named constant `BUTTON1_DOUBLE_CLICKED` defined here

error[E0425]: cannot find value `A_ITALIC` in crate `ncurses`
   --> cursive/src/backends/curses/n.rs:363:40
    |
363 |             Effect::Italic => ncurses::A_ITALIC,
    |                                        ^^^^^^^^ not found in `ncurses`

error[E0425]: cannot find value `A_ITALIC` in crate `ncurses`
   --> cursive/src/backends/curses/n.rs:377:40
    |
377 |             Effect::Italic => ncurses::A_ITALIC,
    |                                        ^^^^^^^^ not found in `ncurses`

error[E0531]: cannot find unit struct, unit variant or constant `BUTTON5_RELEASED` in crate `ncurses`
   --> cursive/src/backends/curses/n.rs:448:18
    |
448 |         ncurses::BUTTON5_RELEASED
    |                  ^^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `BUTTON1_RELEASED`
    |
   ::: /Users/user/sandbox/25/ncurses_things/cursive/target/debug/build/ncurses-30bbd0fd652fa9fc/out/raw_constants.rs:126:1
    |
126 | pub const BUTTON1_RELEASED: i32 = 1;
    | ------------------------------- similarly named constant `BUTTON1_RELEASED` defined here

error[E0531]: cannot find unit struct, unit variant or constant `BUTTON5_PRESSED` in crate `ncurses`
   --> cursive/src/backends/curses/n.rs:449:20
    |
449 |         | ncurses::BUTTON5_PRESSED
    |                    ^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `BUTTON1_PRESSED`
    |
   ::: /Users/user/sandbox/25/ncurses_things/cursive/target/debug/build/ncurses-30bbd0fd652fa9fc/out/raw_constants.rs:127:1
    |
127 | pub const BUTTON1_PRESSED: i32 = 2;
    | ------------------------------ similarly named constant `BUTTON1_PRESSED` defined here

error[E0531]: cannot find unit struct, unit variant or constant `BUTTON5_CLICKED` in crate `ncurses`
   --> cursive/src/backends/curses/n.rs:450:20
    |
450 |         | ncurses::BUTTON5_CLICKED
    |                    ^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `BUTTON1_CLICKED`
    |
   ::: /Users/user/sandbox/25/ncurses_things/cursive/target/debug/build/ncurses-30bbd0fd652fa9fc/out/raw_constants.rs:128:1
    |
128 | pub const BUTTON1_CLICKED: i32 = 4;
    | ------------------------------ similarly named constant `BUTTON1_CLICKED` defined here

error[E0531]: cannot find unit struct, unit variant or constant `BUTTON5_DOUBLE_CLICKED` in crate `ncurses`
   --> cursive/src/backends/curses/n.rs:451:20
    |
451 |         | ncurses::BUTTON5_DOUBLE_CLICKED
    |                    ^^^^^^^^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `BUTTON1_DOUBLE_CLICKED`
    |
   ::: /Users/user/sandbox/25/ncurses_things/cursive/target/debug/build/ncurses-30bbd0fd652fa9fc/out/raw_constants.rs:129:1
    |
129 | pub const BUTTON1_DOUBLE_CLICKED: i32 = 8;
    | ------------------------------------- similarly named constant `BUTTON1_DOUBLE_CLICKED` defined here

error[E0531]: cannot find unit struct, unit variant or constant `BUTTON5_TRIPLE_CLICKED` in crate `ncurses`
   --> cursive/src/backends/curses/n.rs:452:20
    |
452 |         | ncurses::BUTTON5_TRIPLE_CLICKED => MouseButton::Button5,
    |                    ^^^^^^^^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `BUTTON1_TRIPLE_CLICKED`
    |
   ::: /Users/user/sandbox/25/ncurses_things/cursive/target/debug/build/ncurses-30bbd0fd652fa9fc/out/raw_constants.rs:130:1
    |
130 | pub const BUTTON1_TRIPLE_CLICKED: i32 = 16;
    | ------------------------------------- similarly named constant `BUTTON1_TRIPLE_CLICKED` defined here

error[E0531]: cannot find unit struct, unit variant or constant `BUTTON5_PRESSED` in crate `ncurses`
   --> cursive/src/backends/curses/n.rs:477:18
    |
477 |         ncurses::BUTTON5_PRESSED => f(MouseEvent::WheelDown),
    |                  ^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `BUTTON1_PRESSED`
    |
   ::: /Users/user/sandbox/25/ncurses_things/cursive/target/debug/build/ncurses-30bbd0fd652fa9fc/out/raw_constants.rs:127:1
    |
127 | pub const BUTTON1_PRESSED: i32 = 2;
    | ------------------------------ similarly named constant `BUTTON1_PRESSED` defined here

Some errors have detailed explanations: E0425, E0531.
For more information about an error, try `rustc --explain E0425`.
error: could not compile `cursive` (lib) due to 9 previous errors
warning: build failed, waiting for other jobs to finish...
users-iMac:cursive user$
---
 src/genconstants.c | 126 +++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 122 insertions(+), 4 deletions(-)

diff --git a/src/genconstants.c b/src/genconstants.c
index c6cf0516..a86ed3b9 100644
--- a/src/genconstants.c
+++ b/src/genconstants.c
@@ -1,15 +1,67 @@
+#include <stdio.h> // for printf/fprintf but curses.h already includes this(everywhere?)
 #include <curses.h>
 
 #define PCONST(ty, NAME) printf("pub const " #NAME ": " #ty " = %lld;\n", (long long) (NAME))
 #define PCONSTU(ty, NAME) printf("pub const " #NAME ": " #ty " = %llu;\n", (unsigned long long) (NAME))
 
-int main() {
+//XXX: If NAME isn't defined via #define or anything in the ncurses.h file, instead of not defining it at all in our ncurses crate, we define it as being of a specific type(seen below as long snakecase text) which when used by any other crates(like the 'cursive' crate) will compile error in a helpful manner(the type itself is the error message and gives an idea on how to fix it)
+
+// This long snakecase text below, is a type in rust which will be shown when a crate(like cursive) that uses our crate compiles on a system with old ncurses(like macos Mojave 10.14.6 with its native ncurses version instead of the homebrew ncurses version installed), whereby one or more macro definitions like A_ITALIC aren't defined in ncurses.h
+#define ERROR_MSG_TYPE "Your_ncurses_installation_is_too_old_and_it_does_not_have_this_underlined_identifier_defined_in_its_header_file_therefore_the_ncurses_crate_did_not_include_it_because_it_tries_to_be_compatible_however_this_crate_in_which_you_see_the_error_it_needs_the_identifier__If_you_are_on_MacOS_then_use_the_brew_version_of_ncurses_and_set_PKG_CONFIG_PATH_to_the_pkgconfig_dir_from_within_it"
+//using these two(alias,constructor) in .rs avoids duplication of the long-named type for every .c defined that we wanna handle
+#define ERROR_MSG_TYPE_ALIAS "TypeAliasForErrorMsgType"
+#define ERROR_MSG_TYPE_CONSTRUCTOR "ERROR_MSG_TYPE_CONSTRUCTOR"
+
+//Same deal as before except this(error) is for defined in ncurses.h file that are expected to be missing in latest ncurses version installed in the system...
+#define ERROR_MSG_TYPE_EXPECTED_MISS "The_ncurses_crate_did_not_define_this_underlined_identifier_because_your_ncurses_installation_is_up_to_date_and_expectedly_did_not_have_it__however_the_crate_where_you_see_this_error_requires_this_identifier__so_either_upgrade_or_fix_this_crate__or_downgrade_your_ncurses_installation_and_cargo_clean_before_retrying__or_alternatively_try_using_an_older_ncurses_crate_if_you_know_that_worked_before"
+#define ERROR_MSG_EXPECTED_MISS_TYPE_ALIAS "TypeAliasForErrorMsgWhenExpectedMissType"
+#define ERROR_MSG_EXPECTED_MISS_TYPE_CONSTRUCTOR "ERROR_MSG_EXPECTED_MISS_TYPE_CONSTRUCTOR"
+
+//Don't forget to call this in main(), one time.
+#define DEFINE_RS_TYPES \
+  do {\
+    printf("/// For MacOS: `brew install ncurses` then `export PKG_CONFIG_PATH=\"/usr/local/opt/ncurses/lib/pkgconfig\"`\n/// that will give you a compatible/newer ncurses installation.\n");\
+    printf("#[derive(Debug)] // derive to avoid a warning\n\
+#[allow(non_camel_case_types)] \
+pub struct "ERROR_MSG_TYPE";\n\n\
+type "ERROR_MSG_TYPE_ALIAS" = "ERROR_MSG_TYPE";\n\n\
+#[allow(dead_code)]\n\
+const "ERROR_MSG_TYPE_CONSTRUCTOR": "ERROR_MSG_TYPE_ALIAS" = "ERROR_MSG_TYPE";\n\n\n");\
+printf("///Typically, the crate that errors with the following, should be patched to not use the identifier that's tagged with this type, because the latest ncurses installation doesn't have that identifier definition(anymore).\n");\
+printf("#[derive(Debug)] // derive to avoid a warning\n\
+#[allow(non_camel_case_types)] \
+pub struct "ERROR_MSG_TYPE_EXPECTED_MISS";\n\n\
+type "ERROR_MSG_EXPECTED_MISS_TYPE_ALIAS" = "ERROR_MSG_TYPE_EXPECTED_MISS";\n\n\
+#[allow(dead_code)]\n\
+const "ERROR_MSG_EXPECTED_MISS_TYPE_CONSTRUCTOR": "ERROR_MSG_EXPECTED_MISS_TYPE_ALIAS" = "ERROR_MSG_TYPE_EXPECTED_MISS";\n\n\
+\n\n");\
+  } while(0)
+
+#define UNEXPECTED_MISS(NAME) \
+  do {\
+    fprintf(stderr,"Unexpected missing def: " #NAME "\n");\
+    printf("pub const " #NAME ": " ERROR_MSG_TYPE_ALIAS " = " ERROR_MSG_TYPE_CONSTRUCTOR ";\n");\
+  } while(0)
+
+#define EXPECT_MISS(NAME) \
+  do {\
+    fprintf(stderr,"Missing def(but it's expected to be missing): " #NAME "\n");\
+    printf("pub const " #NAME ": " ERROR_MSG_EXPECTED_MISS_TYPE_ALIAS " = " ERROR_MSG_EXPECTED_MISS_TYPE_CONSTRUCTOR ";\n");\
+  } while(0)
+
+//#warning "This warning is unseen during `cargo build` unless compilation fails somewhere at build.rs time"
+
+int main(void) {
+	printf("/* Commented out ncurses initialization chars: '");
+
+	//fflush(stdout);fflush(stderr);*((int *)0) = 42; //segfault(on purpose for manual testing purposes from build.rs) here before terminal gets messed up needing a `reset` shell command to restore! and after something's printed to stdout.
+
 	/* some values aren't set until after this is run */
-	printf("//");
-	//fflush(stdout);fflush(stderr);*((int *)0) = 42; //segfault(on purpose for testing purposes) before terminal gets messed up needing a `reset` shell command to restore!
 	initscr();
 	endwin();
-	printf("\n");
+	printf("' */\n");
+
+  DEFINE_RS_TYPES;
 
 	/* Success/Failure. */
 	PCONST(i32, ERR);
@@ -20,6 +72,8 @@ int main() {
 	/* Attributes. */
 #ifdef NCURSES_ATTR_SHIFT
 	PCONST(u32, NCURSES_ATTR_SHIFT);
+#else
+  UNEXPECTED_MISS(NCURSES_ATTR_SHIFT);
 #endif
 
 	/* Colors */
@@ -35,30 +89,44 @@ int main() {
 	/* Values for the _flags member */
 #ifdef _SUBWIN
 	PCONST(i32, _SUBWIN);
+#else
+  UNEXPECTED_MISS(_SUBWIN);
 #endif
 
 #ifdef _ENDLINE
 	PCONST(i32, _ENDLINE);
+#else
+  UNEXPECTED_MISS(_ENDLINE);
 #endif
 
 #ifdef _FULLWIN
 	PCONST(i32, _FULLWIN);
+#else
+  UNEXPECTED_MISS(_FULLWIN);
 #endif
 
 #ifdef _SCROLLWIN
 	PCONST(i32, _SCROLLWIN);
+#else
+  UNEXPECTED_MISS(_SCROLLWIN);
 #endif
 
 #ifdef _ISPAD
 	PCONST(i32, _ISPAD);
+#else
+  UNEXPECTED_MISS(_ISPAD);
 #endif
 
 #ifdef _HASMOVED
 	PCONST(i32, _HASMOVED);
+#else
+  UNEXPECTED_MISS(_HASMOVED);
 #endif
 
 #ifdef _WRAPPED
 	PCONST(i32, _WRAPPED);
+#else
+  UNEXPECTED_MISS(_WRAPPED);
 #endif
 
 	/*
@@ -67,6 +135,8 @@ int main() {
 	 */
 #ifdef _NOCHANGE
 	PCONST(i32, _NOCHANGE);
+#else
+  UNEXPECTED_MISS(_NOCHANGE);
 #endif
 
 	/*
@@ -75,6 +145,8 @@ int main() {
 	 */
 #ifdef _NEWINDEX
 	PCONST(i32, _NEWINDEX);
+#else
+  UNEXPECTED_MISS(_NEWINDEX);
 #endif
 
 	/* Keys */
@@ -110,18 +182,28 @@ int main() {
 	PCONST(i32, KEY_LL);
 #ifdef KEY_A1
 	PCONST(i32, KEY_A1);
+#else
+  UNEXPECTED_MISS(KEY_A1);
 #endif
 #ifdef KEY_A3
 	PCONST(i32, KEY_A3);
+#else
+  UNEXPECTED_MISS(KEY_A3);
 #endif
 #ifdef KEY_B2
 	PCONST(i32, KEY_B2);
+#else
+  UNEXPECTED_MISS(KEY_B2);
 #endif
 #ifdef KEY_C1
 	PCONST(i32, KEY_C1);
+#else
+  UNEXPECTED_MISS(KEY_C1);
 #endif
 #ifdef KEY_C3
 	PCONST(i32, KEY_C3);
+#else
+  UNEXPECTED_MISS(KEY_C3);
 #endif
 	PCONST(i32, KEY_BTAB);
 	PCONST(i32, KEY_BEG);
@@ -181,46 +263,68 @@ int main() {
 	PCONST(i32, KEY_UNDO);
 	PCONST(i32, KEY_MOUSE);
 	PCONST(i32, KEY_RESIZE);
+
+//TODO: make this 5 line block a 1 line(macro-like) and have rust preprocess it into the 5 lines, so that eg. KEY_EVENT is used only once to avoid duplication and typo or copy/paste mistakes when repeating it.
 #ifdef KEY_EVENT
 	PCONST(i32, KEY_EVENT);
+#else
+  EXPECT_MISS(KEY_EVENT);
 #endif
 	PCONST(i32, KEY_MAX);
 
 #ifdef NCURSES_MOUSE_VERSION
 	PCONST(i32, NCURSES_MOUSE_VERSION);
+#else
+  UNEXPECTED_MISS(NCURSES_MOUSE_VERSION);
 #endif
 
 #ifdef MASK_SHIFT
 	PCONST(i32, MASK_SHIFT);
+#else
+  EXPECT_MISS(MASK_SHIFT);
 #endif
 
 #ifdef MODIFIER_SHIFT
 	PCONST(i32, MODIFIER_SHIFT);
+#else
+  EXPECT_MISS(MODIFIER_SHIFT);
 #endif
 
 	/* Mouse Support */
 #ifdef NCURSES_BUTTON_RELEASED
 	PCONST(i32, NCURSES_BUTTON_RELEASED);
+#else
+  UNEXPECTED_MISS(NCURSES_BUTTON_RELEASED);
 #endif
 
 #ifdef NCURSES_BUTTON_PRESSED
 	PCONST(i32, NCURSES_BUTTON_PRESSED);
+#else
+  UNEXPECTED_MISS(NCURSES_BUTTON_PRESSED);
 #endif
 
 #ifdef NCURSES_BUTTON_CLICKED
 	PCONST(i32, NCURSES_BUTTON_CLICKED);
+#else
+  UNEXPECTED_MISS(NCURSES_BUTTON_CLICKED);
 #endif
 
 #ifdef NCURSES_DOUBLE_CLICKED
 	PCONST(i32, NCURSES_DOUBLE_CLICKED);
+#else
+  UNEXPECTED_MISS(NCURSES_DOUBLE_CLICKED);
 #endif
 
 #ifdef NCURSES_TRIPLE_CLICKED
 	PCONST(i32, NCURSES_TRIPLE_CLICKED);
+#else
+  UNEXPECTED_MISS(NCURSES_TRIPLE_CLICKED);
 #endif
 
 #ifdef NCURSES_RESERVED_EVENT
 	PCONST(i32, NCURSES_RESERVED_EVENT);
+#else
+  UNEXPECTED_MISS(NCURSES_RESERVED_EVENT);
 #endif
 
 	/* event masks */
@@ -250,22 +354,32 @@ int main() {
 
 #ifdef BUTTON5_RELEASED
 	PCONST(i32, BUTTON5_RELEASED);
+#else
+  UNEXPECTED_MISS(BUTTON5_RELEASED);
 #endif
 
 #ifdef BUTTON5_PRESSED
 	PCONST(i32, BUTTON5_PRESSED);
+#else
+  UNEXPECTED_MISS(BUTTON5_PRESSED);
 #endif
 
 #ifdef BUTTON5_CLICKED
 	PCONST(i32, BUTTON5_CLICKED);
+#else
+  UNEXPECTED_MISS(BUTTON5_CLICKED);
 #endif
 
 #ifdef BUTTON5_DOUBLE_CLICKED
 	PCONST(i32, BUTTON5_DOUBLE_CLICKED);
+#else
+  UNEXPECTED_MISS(BUTTON5_DOUBLE_CLICKED);
 #endif
 
 #ifdef BUTTON5_TRIPLE_CLICKED
 	PCONST(i32, BUTTON5_TRIPLE_CLICKED);
+#else
+  UNEXPECTED_MISS(BUTTON5_TRIPLE_CLICKED);
 #endif
 
 	PCONST(i32, BUTTON_CTRL);
@@ -281,6 +395,8 @@ int main() {
 	PCONSTU(crate::ll::chtype, A_UNDERLINE);
 #ifdef A_ITALIC
 	PCONSTU(crate::ll::chtype, A_ITALIC);
+#else
+  UNEXPECTED_MISS(A_ITALIC);
 #endif
 	PCONSTU(crate::ll::chtype, A_REVERSE);
 	PCONSTU(crate::ll::chtype, A_BLINK);
@@ -289,6 +405,8 @@ int main() {
 
 #ifdef A_BLANK
 	PCONSTU(crate::ll::chtype, A_BLANK);
+#else
+  EXPECT_MISS(A_BLANK);
 #endif
 
 	PCONSTU(crate::ll::chtype, A_INVIS);

From d0e98eea6085b91fb76262fb855ef35b096f10d0 Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Fri, 19 Apr 2024 14:07:22 +0200
Subject: [PATCH 35/54] ensure cargo:warning doesn't contain \n

(by converting it to space)
or else anything after it won't be seen in the warning.

and add a fixme/todo
---
 build.rs | 58 +++++++++++++++++++++++++++++++++++++++-----------------
 1 file changed, 41 insertions(+), 17 deletions(-)

diff --git a/build.rs b/build.rs
index 8928eb70..ef24a84d 100644
--- a/build.rs
+++ b/build.rs
@@ -123,14 +123,36 @@ const TINFO_LIB_NAMES: &[&str] = if IS_WIDE_AND_NOT_ON_MACOS {
 /// finds and emits cargo:rustc-link-lib=
 fn find_library(names: &[&str]) -> Option<Library> {
     for name in names {
-        //println!("cargo:warning=Trying lib '{}'",name);
+        //cargo_warn!("Trying lib '{}'",name);
         if let Ok(lib) = pkg_config::probe_library(name) {
-            //println!("cargo:warning=Found lib '{}' '{:?}'",name, lib);
+            //cargo_warn!("Found lib '{}' '{:?}'",name, lib);
             return Some(lib);
         }
     }
     None
 }
+
+/// Emits the passed string(s) prefixed by 'cargo:warning=' on stdout,
+/// which cargo will transform into a warning.
+/// It acts like println!() macro, so you can call it the same way to do formatting!
+/// Will replace newlines in the warning message with spaces,
+/// otherwise the text after would not have been seen in the warning.
+macro_rules! cargo_warn {
+    ($($arg:tt)*) => {
+        cargo_warn_unformatted(format!("{}", format_args!($($arg)*)));
+    };
+}
+
+/// Pass the string to be emitted as a cargo warning.
+/// Presumably you've already used format!() on it.
+/// Will replace newlines in the warning message with spaces,
+/// otherwise the text after would not have been seen in the warning.
+fn cargo_warn_unformatted(warn_msg: String) {
+    // Replace '\r' with nothing
+    // Replace '\n' with space
+    let warn_msg = warn_msg.replace('\r', "").replace('\n', " ");
+    println!("cargo:warning={}", warn_msg);
+}
 // -----------------------------------------------------------------
 // This is the normal build.rs main(),
 // it's only disabled when you used: `cargo build --feature=test_build_rs_of_ncurses_rs`
@@ -148,15 +170,21 @@ fn main() {
     if cfg!(feature = "menu") {
         if find_library(MENU_LIB_NAMES).is_none() {
             let fallback_lib_name = MENU_LIB_NAME_FALLBACK;
+            //FIXME: on openbsd(at least), the 'menu' linking fails because it depends on ncurses
+            //also being linked in, so we must always link with ncurses lib on try_link() which
+            //also means we must know if we have to use ncurses lib override before even trying
+            //menu,panel,tinfo, and thus pass the ncurses lib name to try_link as third arg.
             if try_link(fallback_lib_name, &ncurses_lib) {
-                println!("cargo:warning=Using lib fallback '{}' which links successfully. You might be missing `pkg-config`/`pkgconf`.", fallback_lib_name);
+                cargo_warn!("Using lib fallback '{}' which links successfully. You might be missing `pkg-config`/`pkgconf`.", fallback_lib_name);
             } else {
-                println!("cargo:warning=Possibly missing lib for the '{}' feature, and couldn't find its fallback lib name '{}' but we're gonna use it anyway thus compilation is likely to fail below because of this.\n
-                         You might need installed ncurses and pkg-config/pkgconf to fix this.", "menu", fallback_lib_name);
+                //TODO: find out why this works on openbsd, maybe missing -L paths to the lib which
+                //cargo somehow has and uses, despite pkg-config saying it has none.
+                cargo_warn!("Possibly missing lib for the '{}' feature, and couldn't find its fallback lib name '{}' but we're gonna use it anyway thus compilation is likely to fail below because of this(and yet it works fine on, at least, OpenBSD). You might need installed ncurses and pkg-config/pkgconf to fix this.", "menu", fallback_lib_name);
             }
             //We still try linking with it anyway, in case our try_link() code is somehow wrong,
             //like it doesn't include some link searchdir paths that are somehow included
-            //otherwise.
+            //otherwise. Or, it fails to link because libmenu fails to link without libncurses also
+            //being linked!(happens on openbsd, fixing by always linking with libncurses via try_link())
             println!("cargo:rustc-link-lib={}", fallback_lib_name);
         }
     }
@@ -165,10 +193,9 @@ fn main() {
         if find_library(PANEL_LIB_NAMES).is_none() {
             let fallback_lib_name = PANEL_LIB_NAME_FALLBACK;
             if try_link(fallback_lib_name, &ncurses_lib) {
-                println!("cargo:warning=Using lib fallback '{}' which links successfully. You might be missing `pkg-config`/`pkgconf`.", fallback_lib_name);
+                cargo_warn!("Using lib fallback '{}' which links successfully. You might be missing `pkg-config`/`pkgconf`.", fallback_lib_name);
             } else {
-                println!("cargo:warning=Possibly missing lib for the '{}' feature, and couldn't find its fallback lib name '{}' but we're gonna use it anyway thus compilation is likely to fail below because of this.\n
-                         You might need installed ncurses and pkg-config/pkgconf to fix this.", "panel", fallback_lib_name);
+                cargo_warn!("Possibly missing lib for the '{}' feature, and couldn't find its fallback lib name '{}' but we're gonna use it anyway thus compilation is likely to fail below because of this. You might need installed ncurses and pkg-config/pkgconf to fix this.", "panel", fallback_lib_name);
             }
             //We still try linking with it anyway, in case our try_link() code is somehow wrong,
             //like it doesn't include some link searchdir paths that are somehow included
@@ -223,10 +250,7 @@ fn main() {
             .find(|&each| {
                 let ret: bool = try_link(each, &ncurses_lib);
                 if ret {
-                    println!(
-                        "cargo:warning=Using lib fallback '{}' which links successfully.",
-                        each
-                    );
+                    cargo_warn!("Using lib fallback '{}' which links successfully.", each);
                     println!("cargo:rustc-link-lib={}", each);
                 }
                 ret
@@ -238,10 +262,10 @@ fn main() {
         && tinfo_name == "tinfo"
         && std::env::var("TINFOW_NO_PKG_CONFIG").is_ok()
     {
-        println!("cargo:warning=Looks like you're using wide(and are not on macos) and you've set TINFOW_NO_PKG_CONFIG but have NOT set TINFO_NO_PKG_CONFIG too, so you're linking tinfo(no w) with other wide libs like ncursesw, which will cause '{}' eg. for example ex_5 when trying to run it. This is a warning not a panic because we assume you know what you're doing, and besides this works on Fedora (even if that env. var isn't set)!","Segmentation fault (core dumped)");
+        cargo_warn!("Looks like you're using wide(and are not on macos) and you've set TINFOW_NO_PKG_CONFIG but have NOT set TINFO_NO_PKG_CONFIG too, so you're linking tinfo(no w) with other wide libs like ncursesw, which will cause '{}' eg. for example ex_5 when trying to run it. This is a warning not a panic because we assume you know what you're doing, and besides this works on Fedora (even if that env. var isn't set)!","Segmentation fault (core dumped)");
     }
     //TODO: test on macos-es. When not using the brew ncurses, it won't have A_ITALIC and BUTTON5_*
-    //thus cursive will fail compilation. TODO: detect this and issue cargo:warning from here.
+    //thus cursive will fail compilation. donedifferentlyTODO: detect this and issue cargo:warning from here.
 
     // Gets the name of ncurses lib found by pkg-config, if it found any!
     // else (warns and)returns the default one like 'ncurses' or 'ncursesw'
@@ -324,7 +348,7 @@ fn get_out_dir() -> &'static str {
     //^ Rust automatically coerces the &String reference to a &str reference, making the function return type &'static str valid without any additional explicit conversion. This behavior is possible due to Deref coercion.
 }
 
-/// Tries to see if linker can find/link with the named library.
+/// Tries to see if linker can find/link with the named library, to create a binary.
 /// Uses ncurses lib searchdirs(if any found by pkg-config) to find that lib.
 /// This is mainly used when pkg-config is missing.
 /// Should still work if pkg-config exists though(except it will be missing the found link searchdirs and thus might fail? TODO: test this on NixOS, with NCURSES(W)_NO_PKG_CONFIG=1 env.var, for something like menu(w) or panel(w) )
@@ -658,7 +682,7 @@ fn get_ncurses_lib_name(ncurses_lib: &Option<Library>) -> String {
                 // that is, when pkgconf or pkg-config are missing, yet the libs are there.
                 // Print the warning message, but use old style warning with one ":" not two "::",
                 // because old cargos(pre 23 Dec 2023) will simply ignore it and show no warning if it's "::"
-                println!("cargo:warning=Using (untested)fallback lib name '{}' but if compilation fails below(like when linking ex_5 with 'menu' feature), that is why. It's likely you have not installed one of ['pkg-config' or 'pkgconf'], and/or 'ncurses' (it's package 'ncurses-devel' on Fedora). This seems to work fine on FreeBSD 14 regardless, however to not see this warning and to ensure 100% compatibility(on any OS) be sure to install, on FreeBSD, at least `pkgconf` if not both ie. `# pkg install ncurses pkgconf`.", what_lib);
+                cargo_warn!("Using (untested)fallback lib name '{}' but if compilation fails below(like when linking ex_5 with 'menu' feature), that is why. It's likely you have not installed one of ['pkg-config' or 'pkgconf'], and/or 'ncurses' (it's package 'ncurses-devel' on Fedora). This seems to work fine on FreeBSD 14 regardless, however to not see this warning and to ensure 100% compatibility(on any OS) be sure to install, on FreeBSD, at least `pkgconf` if not both ie. `# pkg install ncurses pkgconf`.", what_lib);
                 //fallback lib name: 'ncurses' or 'ncursesw'
                 //if this fails later, there's the warning above to get an idea as to why.
                 lib_name = what_lib;

From bc272eb49d589f873f826284188bdc74d4c81c2e Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Sat, 20 Apr 2024 01:01:37 +0200
Subject: [PATCH 36/54] fix the try_link() logic in build.rs

* on OpenBSD libmenu and libpanel both require linking with libncurses
lib, else they'll have undefined symbols.
This works on other distros/OSes because libmenu for example has a
dynamic link dependency on libncurses marked inside itself as NEEDED,
but not on OpenBSD 7.5. So try_link() will retry a failed linkage with
-lncurses too, before returning the result.
This required the order of the libs that we try(and tell cargo about to
link) to change from menu,panel,tinfo,ncurses to: ncurses first.

* also show current dir and any set env. vars for commands executed
  during build.rs (they're tipically unset/empty though, ie. inherited
  from parent)
* some fixmes added
---
 build.rs | 204 ++++++++++++++++++++++++++++++++++++++++++++-----------
 1 file changed, 165 insertions(+), 39 deletions(-)

diff --git a/build.rs b/build.rs
index ef24a84d..14a7c24b 100644
--- a/build.rs
+++ b/build.rs
@@ -164,27 +164,56 @@ fn main() {
     watch_env_var("PKG_CONFIG_PATH");
 
     let ncurses_lib = find_library(NCURSES_LIB_NAMES);
+    // Gets the name of ncurses lib found by pkg-config, if it found any!
+    // else (warns and)returns the default one like 'ncurses' or 'ncursesw'
+    // and emits cargo:rustc-link-lib= for it unless already done.
+    let lib_name = get_ncurses_lib_name(&ncurses_lib);
+    //XXX: cargo seems to use --as-needed (arg for 'ld' linker) which isn't easy to figure out(had
+    //to replace /usr/bin/ld temporarily, it won't work with just setting PATH because cc calls
+    //sibbling ld disregarding PATH), but this means the order in which
+    //we try to find the libs here matters(in theory): now it's ncurses,menu,panel,tinfo
+    //Not entirely sure here if this will break things in practice(our case), as we previously used:
+    //menu,panel,tinfo,ncurses order
+    // https://wiki.gentoo.org/wiki/Project:Quality_Assurance/As-needed#Importance_of_linking_order
+    // So in theory(untested), if a bin linked with cargo and only used symbols from menu not from ncurses,
+    // and since menu wanted symbols from ncurses (like it does on OpenBSD), due to
+    // -Wl,--as-needed, ncurses lib won't be linked in final bin(because bin doesn't use symbols
+    // from it) thus cause the bin to fail with unresolved symbols at runtime.
+    // However, in practice, we're "lucky" that anything(presumably), like any bin we make that uses our
+    // ncurses rust crate, will also use ncurses lib thus forcing it to be linked,
+    // thus menu or panel libs that require it will always have it (dyn)linked in the bin. (use ldd on it to see)
 
     //TODO: dedup, unmessify
     //TODO: dedup warning msgs and see when to still emit them.
     if cfg!(feature = "menu") {
         if find_library(MENU_LIB_NAMES).is_none() {
             let fallback_lib_name = MENU_LIB_NAME_FALLBACK;
-            //FIXME: on openbsd(at least), the 'menu' linking fails because it depends on ncurses
-            //also being linked in, so we must always link with ncurses lib on try_link() which
-            //also means we must know if we have to use ncurses lib override before even trying
-            //menu,panel,tinfo, and thus pass the ncurses lib name to try_link as third arg.
-            if try_link(fallback_lib_name, &ncurses_lib) {
-                cargo_warn!("Using lib fallback '{}' which links successfully. You might be missing `pkg-config`/`pkgconf`.", fallback_lib_name);
+            //doneFIXME: on openbsd(at least), the 'menu' linking via try_link() (ie. just -lmenu)
+            //fails because it depends on ncurses also being linked in (via -lncurses)
+            //because 'menu' lib doesn't have ncurses as a dynamic lib need, as it does on other OS-es like Gentoo
+            //which you can see via readelf -d /usr/lib/libmenu.so.7.0 it's missing a line like:
+            //(NEEDED)             Shared library: [libncurses.so.6]
+            //which exists on Gentoo/NixOS for example.
+            //so we must link with ncurses lib on try_link() to avoid unresolved symbols
+            //from 'menu' lib (which,again, needs ncurses, but doesn't say(inside it) that it does)
+            //which also means we must know if we have to use ncurses lib override before even trying
+            //to link menu,panel,tinfo, and thus need to pass the ncurses lib name to try_link() as third arg.
+            if let Some(needed_ncurses) = try_link(fallback_lib_name, &ncurses_lib, &lib_name) {
+                let extra: String = if needed_ncurses {
+                    format!(", but needed '{}' to link without undefined symbols(known to be true on OpenBSD)", lib_name)
+                } else {
+                    "".to_string()
+                };
+                cargo_warn!("Using lib fallback '{}' which links successfully{}. The need for fallback suggests that you might be missing `pkg-config`/`pkgconf`.", fallback_lib_name, extra);
             } else {
-                //TODO: find out why this works on openbsd, maybe missing -L paths to the lib which
-                //cargo somehow has and uses, despite pkg-config saying it has none.
-                cargo_warn!("Possibly missing lib for the '{}' feature, and couldn't find its fallback lib name '{}' but we're gonna use it anyway thus compilation is likely to fail below because of this(and yet it works fine on, at least, OpenBSD). You might need installed ncurses and pkg-config/pkgconf to fix this.", "menu", fallback_lib_name);
+                let feature_name = "menu";
+                cargo_warn!("Possibly missing lib for the '{}' feature, and couldn't find its fallback lib name '{}' but we're gonna use it anyway thus compilation is likely to fail below because of this. You might need installed ncurses and pkg-config/pkgconf to fix this.", feature_name, fallback_lib_name);
             }
             //We still try linking with it anyway, in case our try_link() code is somehow wrong,
             //like it doesn't include some link searchdir paths that are somehow included
-            //otherwise. Or, it fails to link because libmenu fails to link without libncurses also
-            //being linked!(happens on openbsd, fixing by always linking with libncurses via try_link())
+            //otherwise. Or, as it used to happen before i fixed it: it fails to link because
+            //libmenu has undefined symbols if not also linked with libncurses which is what
+            //happens on openbsd; fixed now by always linking with libncurses via try_link() above
             println!("cargo:rustc-link-lib={}", fallback_lib_name);
         }
     }
@@ -192,10 +221,16 @@ fn main() {
     if cfg!(feature = "panel") {
         if find_library(PANEL_LIB_NAMES).is_none() {
             let fallback_lib_name = PANEL_LIB_NAME_FALLBACK;
-            if try_link(fallback_lib_name, &ncurses_lib) {
-                cargo_warn!("Using lib fallback '{}' which links successfully. You might be missing `pkg-config`/`pkgconf`.", fallback_lib_name);
+            if let Some(needed_ncurses) = try_link(fallback_lib_name, &ncurses_lib, &lib_name) {
+                let extra: String = if needed_ncurses {
+                    format!(", but needed '{}' to link without undefined symbols(known to be true on OpenBSD)", lib_name)
+                } else {
+                    "".to_string()
+                };
+                cargo_warn!("Using lib fallback '{}' which links successfully{}. The need for fallback suggests that you might be missing `pkg-config`/`pkgconf`.", fallback_lib_name, extra);
             } else {
-                cargo_warn!("Possibly missing lib for the '{}' feature, and couldn't find its fallback lib name '{}' but we're gonna use it anyway thus compilation is likely to fail below because of this. You might need installed ncurses and pkg-config/pkgconf to fix this.", "panel", fallback_lib_name);
+                let feature_name = "panel";
+                cargo_warn!("Possibly missing lib for the '{}' feature, and couldn't find its fallback lib name '{}' but we're gonna use it anyway thus compilation is likely to fail below because of this. You might need installed ncurses and pkg-config/pkgconf to fix this.", feature_name, fallback_lib_name);
             }
             //We still try linking with it anyway, in case our try_link() code is somehow wrong,
             //like it doesn't include some link searchdir paths that are somehow included
@@ -248,14 +283,19 @@ fn main() {
         TINFO_LIB_NAMES
             .iter()
             .find(|&each| {
-                let ret: bool = try_link(each, &ncurses_lib);
-                if ret {
-                    cargo_warn!("Using lib fallback '{}' which links successfully.", each);
+                let ret: bool = if let Some(needed_ncurses)=try_link(each, &ncurses_lib, &lib_name) {
+                    let extra:String=if needed_ncurses {
+                        format!(", but needed '{}' to link without undefined symbols", lib_name)
+                    } else {
+                        "".to_string()
+                    };
+                    cargo_warn!("Using lib fallback '{}' which links successfully{}. The need for fallback suggests that you might be missing `pkg-config`/`pkgconf`.", each, extra);
                     println!("cargo:rustc-link-lib={}", each);
-                }
+                    true
+                } else { false };
                 ret
             })
-            .unwrap_or_else(|| &"")
+            .unwrap_or_else(|| &"") // found no tinfo that links without errors.
             .to_string()
     };
     if IS_WIDE_AND_NOT_ON_MACOS
@@ -267,11 +307,6 @@ fn main() {
     //TODO: test on macos-es. When not using the brew ncurses, it won't have A_ITALIC and BUTTON5_*
     //thus cursive will fail compilation. donedifferentlyTODO: detect this and issue cargo:warning from here.
 
-    // Gets the name of ncurses lib found by pkg-config, if it found any!
-    // else (warns and)returns the default one like 'ncurses' or 'ncursesw'
-    // and emits cargo:rustc-link-lib= for it unless already done.
-    let lib_name = get_ncurses_lib_name(&ncurses_lib);
-
     watch_env_var(ENV_VAR_NAME_FOR_NCURSES_RS_RUSTC_FLAGS);
     if let Ok(x) = std::env::var(ENV_VAR_NAME_FOR_NCURSES_RS_RUSTC_FLAGS) {
         println!("cargo:rustc-flags={}", x);
@@ -352,9 +387,20 @@ fn get_out_dir() -> &'static str {
 /// Uses ncurses lib searchdirs(if any found by pkg-config) to find that lib.
 /// This is mainly used when pkg-config is missing.
 /// Should still work if pkg-config exists though(except it will be missing the found link searchdirs and thus might fail? TODO: test this on NixOS, with NCURSES(W)_NO_PKG_CONFIG=1 env.var, for something like menu(w) or panel(w) )
-/// Returns true if linking succeeded, false otherwise.
-fn try_link(lib_name: &str, ncurses_lib: &Option<Library>) -> bool {
+/// Returns Some(nn) if linking succeeded, None otherwise, nn is a bool saying if ncurses was needed to can link.
+/// Will try to link twice if linking with only that lib fails, the second try adds ncurses lib to
+/// linking command, because the lib might depend on it even though it doesn't say(inside it) that
+/// it does (this is what happens on OpenBSD).
+fn try_link(
+    lib_name: &str,
+    ncurses_lib: &Option<Library>,
+    ncurses_lib_name_to_use: &str,
+) -> Option<bool> {
     let out_dir = get_out_dir();
+    assert!(
+        !ncurses_lib_name_to_use.is_empty(),
+        "You passed empty ncurses lib name string."
+    );
 
     //We won't execute it though, so doesn't matter if it's .exe for Windows
     let out_bin_fname = format!("try_link_with_{}", lib_name);
@@ -374,6 +420,8 @@ fn try_link(lib_name: &str, ncurses_lib: &Option<Library>) -> bool {
     //Add linker paths from ncurses lib, if any found! ie. -L
     //(this likely will be empty if pkg-config doesn't exist)
     //Include paths(for headers) don't matter! ie. -I
+    //Presumably the other libs(menu,panel,tinfo) are in the same dir(s) as the ncurses lib,
+    //because they're part of ncurses even though they're split on some distros/OSs.
     if let Some(lib) = ncurses_lib {
         for link_path in &lib.link_paths {
             linker_searchdir_args.push("-L".to_string());
@@ -391,14 +439,34 @@ fn try_link(lib_name: &str, ncurses_lib: &Option<Library>) -> bool {
     //though it wouldn't matter here if it's bin or lib, I'm
     //not sure how to find its exact output name after, to delete it.
     //Adding the relevant args for the libs that we depend upon such as ncurses
+    //
+    //First we try to link just the requested lib, eg. 'menu' or 'panel' or 'tinfo'
+    //if this fails, then we try adding 'ncurses' to libs to link, thus
+    //on OpenBSD for example, where libmenu doesn't say it depends on the 'ncurses' lib
+    //it can link successfully because we manually link with it, thus linker won't fail with unresolved symbols.
     command
         .arg("-o")
         .arg_checked(&out_bin_full)
         .arg_checked(&out_src_full)
-        .args_checked(["-l", lib_name])
+        .args_checked(["-l", lib_name]) //this might require the ncurses lib below(on openbsd for sure!)
         .args_checked(linker_searchdir_args);
-    let exit_status = command.status_or_panic(); //runs compiler
-    let ret: bool = exit_status.success();
+    //this copy will link only the lib, without ncurses
+    let mut command_copy: Command = command.make_a_partial_copy(); //woulda been too easy if had .clone()
+
+    //we add ncurses to linked libs, but we only call this if the first try(ie. that copy) fails.
+    command.args_checked(["-l", ncurses_lib_name_to_use]);
+    let exit_status = command_copy.status_or_panic(); //runs compiler
+    let mut ret: bool = exit_status.success();
+    let mut requires_ncurses_lib: bool = false;
+    if !ret {
+        //first try failed, try second with -lncurses(w) added.
+        let exit_status = command.status_or_panic(); //runs compiler
+        ret = exit_status.success();
+        if ret {
+            //cargo_warn!("");
+            requires_ncurses_lib = true;
+        }
+    }
 
     if DELETE_GENERATEDS {
         if ret {
@@ -418,7 +486,12 @@ fn try_link(lib_name: &str, ncurses_lib: &Option<Library>) -> bool {
             )
         });
     }
-    return ret;
+
+    return if ret {
+        Some(requires_ncurses_lib)
+    } else {
+        None
+    };
 }
 
 //TODO: change this to apply to anything that's emitted for cargo to consume, except warnings, and
@@ -567,6 +640,7 @@ fn gen_rs(
 
 fn check_chtype_size(ncurses_lib: &Option<Library>) {
     let out_dir = get_out_dir();
+    //FIXME: see if .display() is a good idea, maybe can avoid it.
     let src_full = Path::new(&out_dir)
         .join("chtype_size.c")
         .display()
@@ -690,7 +764,7 @@ fn get_ncurses_lib_name(ncurses_lib: &Option<Library>) -> String {
         }
     };
     if !already_printed {
-        //TODO: try_link() ? then refactor the warning messages.
+        //TODO: try_link() ? then refactor the warning messages. Well, now that try_link already links ncurses lib, this isn't needed? or if it is, don't specify -l twice for it inside try_link
         println!("cargo:rustc-link-lib={}", lib_name);
     }
     lib_name
@@ -738,7 +812,7 @@ trait MyCompilerCommand {
     fn status_or_panic_but_no_check_args(&mut self) -> ExitStatus;
     fn show_what_will_run(&mut self) -> &mut Self;
     fn get_program_or_panic(&self) -> &str;
-    fn get_what_will_run(&self) -> (String, usize, String);
+    fn get_what_will_run(&self) -> (String, usize, String, Option<&Path>, String);
     fn assert_no_nul_in_args(&mut self) -> &mut Self;
     /// Panics if arg has \0 in it.
     fn args_checked<I, S>(&mut self, args: I) -> &mut Command
@@ -750,6 +824,7 @@ trait MyCompilerCommand {
     /// Doesn't do any other checks, passes it to Command::arg()
     fn arg_checked<S: AsRef<OsStr>>(&mut self, arg: S) -> &mut Command;
     fn panic<T: std::fmt::Display>(&mut self, err: T, what_type_of_command: &str) -> !;
+    fn make_a_partial_copy(&self) -> Self;
 }
 
 fn has_null_byte<S: AsRef<OsStr>>(arg: S) -> bool {
@@ -798,7 +873,6 @@ impl MyCompilerCommand for std::process::Command {
         let and_panic = || -> ! {
             panic!(
                 "due to the above-reported error while executing '{}'.",
-                //self.get_program_or_panic()
                 prog
             );
         };
@@ -908,7 +982,7 @@ impl MyCompilerCommand for std::process::Command {
         p_prog
     }
 
-    fn get_what_will_run(&self) -> (String, usize, String) {
+    fn get_what_will_run(&self) -> (String, usize, String, Option<&Path>, String) {
         let p_prog = self.get_program_or_panic();
         let args = self.get_args();
         let how_many_args: usize = args.len();
@@ -941,11 +1015,31 @@ impl MyCompilerCommand for std::process::Command {
         //TODO: maybe a better way to get the args as a Vec<String> and impl Display ? but not
         //for the generic Vec<String> i think. Then, we won't have to return how_many_args!
 
+        let cur_dir = self.get_current_dir();
+        let env_vars: Vec<(&OsStr, Option<&OsStr>)> = self.get_envs().collect();
+        let mut formatted_env_vars = String::new(); //empty string if no env vars set
+        if !formatted_env_vars.is_empty() {
+            for (key, value) in env_vars {
+                match value {
+                    Some(value) => formatted_env_vars.push_str(&format!(
+                        "(set) {}={}\n",
+                        key.to_string_lossy(),
+                        value.to_string_lossy()
+                    )),
+                    None => {
+                        formatted_env_vars.push_str(&format!("(del) {}\n", key.to_string_lossy()))
+                    } // Key was removed
+                }
+            }
+        };
+        //FIXME: make this a struct so the order doesn't get confused in callers.
         //return this tuple
         (
             p_prog.to_string(),
             how_many_args,
             format!("\"{}\"", formatted_args),
+            cur_dir,
+            formatted_env_vars,
         )
     }
 
@@ -981,7 +1075,8 @@ impl MyCompilerCommand for std::process::Command {
 
     /// (not meant to be used outside)
     fn panic<T: std::fmt::Display>(&mut self, err: T, what_type_of_command: &str) -> ! {
-        let (p_prog, how_many_args, formatted_args) = self.get_what_will_run();
+        //FIXME: show cur_dir and envs too? but don't dup code from show_what_will_run()
+        let (p_prog, how_many_args, formatted_args, _cur_dir, _envs) = self.get_what_will_run();
         let extra_space = if what_type_of_command.is_empty() {
             ""
         } else {
@@ -995,13 +1090,44 @@ impl MyCompilerCommand for std::process::Command {
 
     /// shows on stderr, which command will be executed.
     fn show_what_will_run(&mut self) -> &mut Self {
-        let (exe_name, how_many_args, formatted_args) = self.get_what_will_run();
+        let (exe_name, how_many_args, formatted_args, cur_dir, formatted_env_vars) =
+            self.get_what_will_run();
+        let cur_dir: String = if let Some(dir) = cur_dir {
+            format!(", in current dir: '{}'", dir.display())
+        } else {
+            ", in unspecified current dir".to_string()
+        };
+        let formatted_env_vars: String = if formatted_env_vars.is_empty() {
+            ", with no extra env.vars added or deleted".to_string()
+        } else {
+            format!(", with env.vars: '{}'", formatted_env_vars)
+        };
         eprintln!(
-            "!! Next, attempting to run compilation command '{}' with '{}' args: '{}'",
-            exe_name, how_many_args, formatted_args
+            "!! Next, attempting to run command '{}' with '{}' args: '{}'{}{}.",
+            exe_name, how_many_args, formatted_args, cur_dir, formatted_env_vars
         );
         self
     }
+
+    /// copies exe,args,pwd and env.vars
+    fn make_a_partial_copy(&self) -> Self {
+        let prog = self.get_program();
+        let mut r#new = Command::new(prog);
+        r#new.args_checked(self.get_args());
+        //r#new.envs(self.get_envs().collect::<Vec<_>>());
+        for (k, v) in self.get_envs() {
+            if let Some(v) = v {
+                r#new.env(k, v);
+            } else {
+                r#new.env_remove(k);
+            }
+        }
+        if let Some(cd) = self.get_current_dir() {
+            r#new.current_dir(cd);
+        }
+
+        r#new
+    }
 }
 
 /// This is used to test build.rs, run with: cargo build --features=test_build_rs_of_ncurses_rs
@@ -1214,7 +1340,7 @@ fn test_get_what_will_run() {
         OsString::from("arg4"),
     ]);
     command.arg_checked(OsString::from_vec(b"my\xffarg3".to_vec()));
-    let (prog, how_many_args, formatted_args) = command.get_what_will_run();
+    let (prog, how_many_args, formatted_args, _cur_dir, _envs) = command.get_what_will_run();
     let expected_hma = 4;
     let expected_fa = "\"arg1\" \"my\\xFFarg3\" \"arg4\" \"my\\xFFarg3\"";
     assert_eq!(prog, expected_prog);

From 66298272bb45085d18194e04e75b5abaaa2f38b4 Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Sat, 20 Apr 2024 14:28:58 +0200
Subject: [PATCH 37/54] cargo-warn when using non-utf8 LANG for wide feat.

OpenBSD has none of these vars set and thus wide char support looks
broken: LC_ALL, LC_CTYPE and LANG
Setting any to "en_US.UTF-8" will make wide chars display properly,
however the UTF-8 part is case sensitive and can't be without dash*,
but the en_US part is case insensitive. True on OpenBSD 7.5, but
wholly different on Gentoo for example.

* we warn about this part, on openbsd.

The need for one of these vars for wide chars support to be displayed
correctly is true apparently on every other OS/distro, but they typically
have at least LANG set properly to something UTF-8 like.

We detect/warn for such cases, at compile time, at least can serve as a reminder.

This affects only runtime though. But in order for the cargo warning to
go away, we rebuild when any of those env. vars change, else same
warning would always show when doing same `cargo run` for example.
---
 build.rs | 68 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 68 insertions(+)

diff --git a/build.rs b/build.rs
index 14a7c24b..067793fe 100644
--- a/build.rs
+++ b/build.rs
@@ -182,6 +182,74 @@ fn main() {
     // However, in practice, we're "lucky" that anything(presumably), like any bin we make that uses our
     // ncurses rust crate, will also use ncurses lib thus forcing it to be linked,
     // thus menu or panel libs that require it will always have it (dyn)linked in the bin. (use ldd on it to see)
+    // An unrelated note: on OpenBSD 7.5 linking with -lncursesw links with `/usr/lib/libcurses.so.15.0` which is a hardlink to `/usr/lib/libncursesw.so.15.0`, same happens for -lcurses and -lncurses, they link to the same lib, as if both normal and wide char should support should already be inside it(and they are). Same holds for libmenu(w).so.7.0 and libpanel(w).so.7.0
+
+    if IS_WIDE {
+        // A binary that uses ncurses with wide feature, is affected by the value of the following env. vars:
+        // "LC_ALL", "LC_CTYPE", "LANG", they should be set to eg. en_US.UTF-8
+        // info from: https://invisible-island.net/ncurses/ncurses-openbsd.html#problem_locales
+        // and from: https://github.com/mimblewimble/grin/issues/3776#issuecomment-1826805985
+
+        // Every other distro already has at least LANG set, but is otherwise affected the same if
+        // for example LANG is unset or LANG=C is used, when running the binary with wide feature.
+
+        //TODO: need a better way to detect if it's UTF-8 capable and correctly set. Maybe some
+        //locale crate.
+
+        //This is the order of precedence, if any are set, the one leftmost in this list overrides
+        //the others that come after it;
+        let env_vars = vec!["LC_ALL", "LC_CTYPE", "LANG"];
+        for var in &env_vars {
+            //tell cargo to rebuild if they change, else we see same warning on every `cargo run`
+            watch_env_var(var);
+        }
+        //the first one(from the above) that's set, overrides the rest, so ignore the rest.
+        let mut first_one_set: Option<(bool, &str, String)> = None;
+
+        /// Function to check if a string ends with the substring "UTF-8"
+        /// case sensitive(true) or insensitive(false) is selected by bool arg.
+        fn ends_in_utf8(value: &str, case_sensitive: bool) -> bool {
+            let ci: String = if !case_sensitive {
+                value.to_uppercase()
+            } else {
+                value.to_string()
+            };
+            //Gentoo can take both utf8 and utf-8, case insesitive
+            //but the en_US part is case sensitive!
+            //OpenBSD 7.5 can only take uppercase UTF-8
+            //but the en_US part is case INsensitive!
+            ci.ends_with("UTF-8") || ci.ends_with("UTF8")
+        }
+
+        for var in &env_vars {
+            if let Ok(value) = env::var(var) {
+                //we make sure to warn on openbsd if we don't find UTF-8 exactly!
+                //on others, we just case insensitively check if it ends with utf-8/utf8
+                const CASENESS: bool = if cfg!(target_os = "openbsd") {
+                    true
+                } else {
+                    false
+                };
+                if ends_in_utf8(&value, CASENESS) {
+                    first_one_set = Some((true, var, value));
+                } else {
+                    first_one_set = Some((false, var, value));
+                }
+
+                break;
+            }
+        }
+        let extra=" Note that, at least on OpenBSD 7.5, you must set the 'UTF-8' part to be all uppercase as it seems to be case sensitive so uTf-8, Utf-8, utf-8 or even UTF8 without dash, won't work but the 'en_US' part can be any case, apparently. On Gentoo however, even utf8 without a dash works(as also with a dash like uTf-8) and it's case insensitive, however the en_US part is case sensitive! Check your distro for the correct form maybe.";
+        if let Some((is_utf8, var_name, var_value)) = first_one_set {
+            if !is_utf8 {
+                cargo_warn!("You've enabled the 'wide' feature but you've set environment variable '{}={}', which isn't UTF-8, apparently, so wide characters will look garbled when you run your resulting ncurses-using binary unless you set one of these environment vars {:?} to, for example, \"en_US.UTF-8\". This affects the binary at runtime not at compile time.{}",var_name,var_value, &env_vars, extra);
+            }
+            //if it is utf8, then we're all good
+        } else {
+            // no env.vars are set, is this OpenBSD?! applies to any OS though.
+            cargo_warn!("You've enabled the 'wide' feature but you've not set any environment variables from the set of these {:?}, so unless you set one of them to for example \"en_US.UTF-8\" then wide characters will look garbled when you run your resulting ncurses-using binary. This affects the binary at runtime not at compile time.{}", &env_vars, extra);
+        }
+    } // is wide
 
     //TODO: dedup, unmessify
     //TODO: dedup warning msgs and see when to still emit them.

From 3fd8920f8eeae1446a23f73c0662a4cf5e14c5a3 Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Sat, 20 Apr 2024 15:20:50 +0200
Subject: [PATCH 38/54] suggest libncurses-dev package on Ubuntu

or else can't find the header at compile time
---
 build.rs | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/build.rs b/build.rs
index 067793fe..ec785efe 100644
--- a/build.rs
+++ b/build.rs
@@ -861,6 +861,7 @@ impl MyExitStatus for std::process::ExitStatus {
                 "!!! Compiler failed{} Is ncurses installed? \
         pkg-config or pkgconf too? \
         it's 'ncurses-devel' on Fedora; \
+        and 'libncurses-dev' on Ubuntu; \
         run `nix-shell` first, on NixOS. \
         Or maybe it failed for different reasons which are seen in the errored output above.",
                 how
@@ -1311,7 +1312,7 @@ fn test_panic_for_command_non_zero_exit() {
         command.args(args_fail);
         command.success_or_panic();
     });
-    let expected_panic_msg = "!!! Compiler failed with exit code 43. Is ncurses installed? pkg-config or pkgconf too? it's 'ncurses-devel' on Fedora; run `nix-shell` first, on NixOS. Or maybe it failed for different reasons which are seen in the errored output above.";
+    let expected_panic_msg = "!!! Compiler failed with exit code 43. Is ncurses installed? pkg-config or pkgconf too? it's 'ncurses-devel' on Fedora; and 'libncurses-dev' on Ubuntu; run `nix-shell` first, on NixOS. Or maybe it failed for different reasons which are seen in the errored output above.";
     expect_panic(result, expected_panic_msg);
 }
 

From d50e3ab42d72c59c1f7557d6ca997c05373fa0a6 Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Sat, 20 Apr 2024 22:36:13 +0200
Subject: [PATCH 39/54] dedup build.rs code for menu/panel lib finding

---
 build.rs | 113 +++++++++++++++++++++++++++++--------------------------
 1 file changed, 60 insertions(+), 53 deletions(-)

diff --git a/build.rs b/build.rs
index ec785efe..f70ef015 100644
--- a/build.rs
+++ b/build.rs
@@ -96,7 +96,7 @@ const PANEL_LIB_NAMES: &[&str] = if IS_WIDE_AND_NOT_ON_MACOS {
 
 const TINFO_LIB_NAMES: &[&str] = if IS_WIDE_AND_NOT_ON_MACOS {
     //elements order here matters, because:
-    //Fedora has ncursesw+tinfo(without w) for wide!
+    //Fedora/Ubuntu has ncursesw+tinfo(without w) for wide!
     //and -ltinfow fails to link on NixOS and Fedora! so -ltinfo must be used even tho wide.
     //(presumably because tinfo doesn't depend on wideness?)
     //NixOS has only ncursesw(tinfo is presumably inside it) but -ltinfo still works for it(it's a
@@ -196,11 +196,12 @@ fn main() {
         //TODO: need a better way to detect if it's UTF-8 capable and correctly set. Maybe some
         //locale crate.
 
-        //This is the order of precedence, if any are set, the one leftmost in this list overrides
+        //This is the order of precedence, if any/all are set, the one leftmost in this list overrides
         //the others that come after it;
         let env_vars = vec!["LC_ALL", "LC_CTYPE", "LANG"];
         for var in &env_vars {
             //tell cargo to rebuild if they change, else we see same warning on every `cargo run`
+            //even though it doesn't(presumably) affect the build, but only the bin at runtime.
             watch_env_var(var);
         }
         //the first one(from the above) that's set, overrides the rest, so ignore the rest.
@@ -251,60 +252,24 @@ fn main() {
         }
     } // is wide
 
-    //TODO: dedup, unmessify
-    //TODO: dedup warning msgs and see when to still emit them.
     if cfg!(feature = "menu") {
-        if find_library(MENU_LIB_NAMES).is_none() {
-            let fallback_lib_name = MENU_LIB_NAME_FALLBACK;
-            //doneFIXME: on openbsd(at least), the 'menu' linking via try_link() (ie. just -lmenu)
-            //fails because it depends on ncurses also being linked in (via -lncurses)
-            //because 'menu' lib doesn't have ncurses as a dynamic lib need, as it does on other OS-es like Gentoo
-            //which you can see via readelf -d /usr/lib/libmenu.so.7.0 it's missing a line like:
-            //(NEEDED)             Shared library: [libncurses.so.6]
-            //which exists on Gentoo/NixOS for example.
-            //so we must link with ncurses lib on try_link() to avoid unresolved symbols
-            //from 'menu' lib (which,again, needs ncurses, but doesn't say(inside it) that it does)
-            //which also means we must know if we have to use ncurses lib override before even trying
-            //to link menu,panel,tinfo, and thus need to pass the ncurses lib name to try_link() as third arg.
-            if let Some(needed_ncurses) = try_link(fallback_lib_name, &ncurses_lib, &lib_name) {
-                let extra: String = if needed_ncurses {
-                    format!(", but needed '{}' to link without undefined symbols(known to be true on OpenBSD)", lib_name)
-                } else {
-                    "".to_string()
-                };
-                cargo_warn!("Using lib fallback '{}' which links successfully{}. The need for fallback suggests that you might be missing `pkg-config`/`pkgconf`.", fallback_lib_name, extra);
-            } else {
-                let feature_name = "menu";
-                cargo_warn!("Possibly missing lib for the '{}' feature, and couldn't find its fallback lib name '{}' but we're gonna use it anyway thus compilation is likely to fail below because of this. You might need installed ncurses and pkg-config/pkgconf to fix this.", feature_name, fallback_lib_name);
-            }
-            //We still try linking with it anyway, in case our try_link() code is somehow wrong,
-            //like it doesn't include some link searchdir paths that are somehow included
-            //otherwise. Or, as it used to happen before i fixed it: it fails to link because
-            //libmenu has undefined symbols if not also linked with libncurses which is what
-            //happens on openbsd; fixed now by always linking with libncurses via try_link() above
-            println!("cargo:rustc-link-lib={}", fallback_lib_name);
-        }
+        find_sublib(
+            "menu",
+            MENU_LIB_NAMES,
+            MENU_LIB_NAME_FALLBACK,
+            &ncurses_lib,
+            &lib_name,
+        );
     }
 
     if cfg!(feature = "panel") {
-        if find_library(PANEL_LIB_NAMES).is_none() {
-            let fallback_lib_name = PANEL_LIB_NAME_FALLBACK;
-            if let Some(needed_ncurses) = try_link(fallback_lib_name, &ncurses_lib, &lib_name) {
-                let extra: String = if needed_ncurses {
-                    format!(", but needed '{}' to link without undefined symbols(known to be true on OpenBSD)", lib_name)
-                } else {
-                    "".to_string()
-                };
-                cargo_warn!("Using lib fallback '{}' which links successfully{}. The need for fallback suggests that you might be missing `pkg-config`/`pkgconf`.", fallback_lib_name, extra);
-            } else {
-                let feature_name = "panel";
-                cargo_warn!("Possibly missing lib for the '{}' feature, and couldn't find its fallback lib name '{}' but we're gonna use it anyway thus compilation is likely to fail below because of this. You might need installed ncurses and pkg-config/pkgconf to fix this.", feature_name, fallback_lib_name);
-            }
-            //We still try linking with it anyway, in case our try_link() code is somehow wrong,
-            //like it doesn't include some link searchdir paths that are somehow included
-            //otherwise.
-            println!("cargo:rustc-link-lib={}", fallback_lib_name);
-        }
+        find_sublib(
+            "panel",
+            PANEL_LIB_NAMES,
+            PANEL_LIB_NAME_FALLBACK,
+            &ncurses_lib,
+            &lib_name,
+        );
     }
 
     //This comment block is about libtinfo.
@@ -363,7 +328,7 @@ fn main() {
                 } else { false };
                 ret
             })
-            .unwrap_or_else(|| &"") // found no tinfo that links without errors.
+            .unwrap_or_else(|| &"") // found no tinfo that links without errors which may be ok(eg. on Nixos)
             .to_string()
     };
     if IS_WIDE_AND_NOT_ON_MACOS
@@ -407,6 +372,48 @@ fn main() {
 }
 // -----------------------------------------------------------------
 
+/// This is for menu and panel to see if pkg-config finds them and if not then see
+/// which fallback lib name links successfully and whether or not also needs ncurses(w)
+/// to successfully link.
+fn find_sublib(
+    feature_name: &str,
+    sublibs_list: &[&str],
+    sublib_fallback_name: &str,
+    ncurses_lib: &Option<Library>,
+    ncurses_lib_name_to_use: &str,
+) {
+    if find_library(sublibs_list).is_none() {
+        //On openbsd(at least), the 'menu' lib linking via try_link() (ie. just -lmenu)
+        //fails because it depends on ncurses also being linked in (via -lncurses)
+        //because 'menu' lib doesn't have ncurses as a dynamic lib need, as it does on other OS-es like Gentoo
+        //which you can see via readelf -d /usr/lib/libmenu.so.7.0 it's missing a line like:
+        //(NEEDED)             Shared library: [libncurses.so.6]
+        //which exists on Gentoo/NixOS for example.
+        //So we must link with ncurses lib on try_link() to avoid unresolved symbols
+        //from 'menu' lib (which we do now as second try if just -lmenu linking fails),
+        //which also means we must know if we have to use ncurses lib override before even trying
+        //to link menu,panel,tinfo, and thus need to pass the ncurses lib name to try_link() as third arg.
+        if let Some(needed_ncurses) =
+            try_link(sublib_fallback_name, &ncurses_lib, &ncurses_lib_name_to_use)
+        {
+            let extra: String = if needed_ncurses {
+                format!(", but needed '{}' to link  without undefined symbols(known to be true on OpenBSD)", ncurses_lib_name_to_use)
+            } else {
+                "".to_string()
+            };
+            cargo_warn!("Using lib fallback '{}' which links successfully{}. The need for fallback suggests that you might be missing `pkg-config`/`pkgconf` or if they're not missing then you might not have a file named '{}.pc'.", sublib_fallback_name, extra, sublib_fallback_name);
+        } else {
+            cargo_warn!("Possibly missing lib for the '{}' feature, and couldn't find its fallback lib name '{}' but we're gonna use it anyway thus compilation is likely to fail below because of this. You might need installed ncurses and pkg-config/pkgconf to fix this.", feature_name, sublib_fallback_name);
+        }
+        //We still try linking with it anyway, in case our try_link() code is somehow wrong,
+        //like it doesn't include some link searchdir paths that are somehow included
+        //otherwise. Or, as it used to happen before i fixed it: it fails to link because
+        //libmenu has undefined symbols if not also linked with libncurses which is what
+        //happens on openbsd; fixed now by always linking with libncurses via try_link() above
+        println!("cargo:rustc-link-lib={}", sublib_fallback_name);
+    } // else,if found, it's already emitted the println to tell cargo to link what it found.
+}
+
 //TODO: look into how to make doc tests and if they'd work with build.rs
 /// Creates file with the specified contents.
 /// Any existing file with that name is lost.

From e3ae3e2283f39e2d8b04157de9cc39f08b284a22 Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Sun, 21 Apr 2024 10:04:59 +0200
Subject: [PATCH 40/54] get rid of Path::display() in build.rs
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

to avoid errors slipping by unnoticed and triggering other errors,
because in the output of path.display() \0 wouldn't be visible(on
terminal) and invalid UTF-8 like \xFF would be converted into the
replacement character:

U+FFFD, &#65533; 0xFFFD, \0177775, UTF-8: ef bf bd, UTF-16BE: fffd
Width: 1 (2 in CJK context), prints as 
Quotes as \u{fffd}
Unicode name: REPLACEMENT CHARACTER

For example:
Debug output {:?} of path_buf: "/s\0ome/path/to/d\xFFirectory"
Output of path_buf.display() : /some/path/to/directory

There's an actual nul byte put there when displayed,
which I didn't include here in the commit message,
but it's just as invisible on the terminal.
However in the debug output it's shown as escaped(using the two chars
\ and 0) which makes it clear that it exists there.
---
 build.rs | 149 ++++++++++++++++++++++++++++---------------------------
 1 file changed, 76 insertions(+), 73 deletions(-)

diff --git a/build.rs b/build.rs
index f70ef015..f4b15aec 100644
--- a/build.rs
+++ b/build.rs
@@ -116,8 +116,8 @@ const TINFO_LIB_NAMES: &[&str] = if IS_WIDE_AND_NOT_ON_MACOS {
 //TODO: why are we trying the v5 of the lib first instead of v6 (which is the second/last in list),
 //was v5 newer than the next in list? is it so on other systems?
 //like: was it ever ncurses5 newer than ncurses ?
-//Since we're trying v5 and it finds it, it will use it and stop looking, even though the next one
-//might be v6
+//Since we're trying v5 and it finds it, it will use it and stop looking,
+//even though the next one in list might be v6
 //This is the commit that added this v5 then v6 way: https://github.com/jeaye/ncurses-rs/commit/daddcbb557169cfac03af9667ef7aefed19f9409
 
 /// finds and emits cargo:rustc-link-lib=
@@ -337,7 +337,7 @@ fn main() {
     {
         cargo_warn!("Looks like you're using wide(and are not on macos) and you've set TINFOW_NO_PKG_CONFIG but have NOT set TINFO_NO_PKG_CONFIG too, so you're linking tinfo(no w) with other wide libs like ncursesw, which will cause '{}' eg. for example ex_5 when trying to run it. This is a warning not a panic because we assume you know what you're doing, and besides this works on Fedora (even if that env. var isn't set)!","Segmentation fault (core dumped)");
     }
-    //TODO: test on macos-es. When not using the brew ncurses, it won't have A_ITALIC and BUTTON5_*
+    //done1TODO: test on macos-es. When not using the brew ncurses, it won't have A_ITALIC and BUTTON5_*
     //thus cursive will fail compilation. donedifferentlyTODO: detect this and issue cargo:warning from here.
 
     watch_env_var(ENV_VAR_NAME_FOR_NCURSES_RS_RUSTC_FLAGS);
@@ -414,54 +414,77 @@ fn find_sublib(
     } // else,if found, it's already emitted the println to tell cargo to link what it found.
 }
 
-//TODO: look into how to make doc tests and if they'd work with build.rs
+//cargo won't run doc tests inside build.rs
 /// Creates file with the specified contents.
 /// Any existing file with that name is lost.
 /// Panics if file_name isn't prefixed by the value of OUT_DIR (at runtime) for extra safety.
-fn overwrite_file_contents(file_name: &str, contents: &[u8]) {
+fn overwrite_file_contents<P: AsRef<Path>>(file_name: P, contents: &[u8]) {
     //Note: asserts in build.rs appear to be enabled even for cargo build --release, and can't be disabled(which is good, we want them on, always)
+    let file_name = file_name.as_ref();
     assert!(
         file_name.starts_with(&get_out_dir()),
-        "The file name you wanted to create '{}' should be created in OUT_DIR only",
+        "The file name you wanted to create {:?} should be created in OUT_DIR only",
         file_name
     );
-    //FIXME: Maybe don't require utf-8 valid paths? by requiring &str here,
-    //the caller would do PathBuf::display() which replaces '\xFF' with the placeholder char
-    //which is the replacement character \u{FFFD}
-    //Many other programs break at compile time if path contains non-utf8 chars, before we even get here!
+    //PathBuf::display() replaces '\xFF' with the placeholder char which is the replacement character \u{FFFD}
+    //and also \0 aren't seen at all in the output. Therefore it's best to use {:?} debug to see
+    //them escaped! Debug already shows double quotes around it.
+    //On another note: many other programs break at compile time if path contains non-utf8 chars,
+    //before we even get here in this build.rs!
     let mut file = File::create(file_name)
-        .unwrap_or_else(|err| panic!("Couldn't create file '{}', reason: '{}'", file_name, err));
+        .unwrap_or_else(|err| panic!("Couldn't create file {:?}, reason: '{}'", file_name, err));
 
     file.write_all(contents).unwrap_or_else(|err| {
         panic!(
-            "Couldn't write contents to file '{}', reason: '{}'",
+            "Couldn't write contents to file {:?}, reason: '{}'",
             file_name, err
         )
     });
     drop(file); //explicit file close, not needed since it's in a function now!
 }
 
-fn get_out_dir() -> &'static str {
+fn get_out_dir() -> impl AsRef<Path> {
+    use std::path::PathBuf;
     use std::sync::OnceLock;
-    static LOCK: OnceLock<String> = OnceLock::new();
+    static LOCK: OnceLock<PathBuf> = OnceLock::new();
 
     //OUT_DIR is set by cargo during build
     const ENV_NAME_OF_OUT_DIR: &str = "OUT_DIR";
-    LOCK.get_or_init(|| {
-        env::var(ENV_NAME_OF_OUT_DIR).unwrap_or_else(|err| {
+    let pb_ref:&PathBuf = LOCK.get_or_init(|| {
+        let out_dir=env::var(ENV_NAME_OF_OUT_DIR).unwrap_or_else(|err| {
             panic!(
                 "Cannot get env.var. '{}', reason: '{}'. Use `cargo build` instead of running this build script binary directly!",
                 ENV_NAME_OF_OUT_DIR, err
             )
-        })
-    })
-    //^ Rust automatically coerces the &String reference to a &str reference, making the function return type &'static str valid without any additional explicit conversion. This behavior is possible due to Deref coercion.
+        });
+        PathBuf::from(out_dir)
+    });
+    pb_ref
+    //^ &PathBuf implements AsRef<Path>
+}
+
+fn get_linker_searchdirs(from_lib: &Option<Library>) -> Vec<String> {
+    let mut linker_searchdir_args: Vec<String> = Vec::new();
+    if let Some(lib) = from_lib {
+        for link_path in &lib.link_paths {
+            linker_searchdir_args.push("-L".to_string());
+            //Must not use link_path.display() which does lossy conversion to UTF-8, else errors
+            //might slip through unnoticed and might be harder to track, when paths aren't UTF-8 valid.
+            //Can however use .display() in other parts of the code that only need to
+            //show the path in a message.
+            linker_searchdir_args.push(link_path.to_str().unwrap_or_else(|| {
+                //XXX: We use debug {:?} to show the path because .display() wouldn't show for example
+                //\0 in the path.
+                panic!("!!! Lib link path {:?} contains invalid UTF-8. This is likely an existing path on you system, so to get rid of this, you'd have to fix/rename the path to be UTF-8. This path was likely found via `pkg-config`.", link_path);
+            }).to_string());
+        }
+    }
+    linker_searchdir_args
 }
 
 /// Tries to see if linker can find/link with the named library, to create a binary.
 /// Uses ncurses lib searchdirs(if any found by pkg-config) to find that lib.
-/// This is mainly used when pkg-config is missing.
-/// Should still work if pkg-config exists though(except it will be missing the found link searchdirs and thus might fail? TODO: test this on NixOS, with NCURSES(W)_NO_PKG_CONFIG=1 env.var, for something like menu(w) or panel(w) )
+/// This is mainly used when pkg-config is missing but should still work if pkg-config exists.
 /// Returns Some(nn) if linking succeeded, None otherwise, nn is a bool saying if ncurses was needed to can link.
 /// Will try to link twice if linking with only that lib fails, the second try adds ncurses lib to
 /// linking command, because the lib might depend on it even though it doesn't say(inside it) that
@@ -481,35 +504,17 @@ fn try_link(
     let out_bin_fname = format!("try_link_with_{}", lib_name);
 
     //we'll generate this .c file with our contents
-    let out_src_full = Path::new(&out_dir)
-        .join(format!("{}.c", out_bin_fname))
-        .display()
-        .to_string();
+    let out_src_full = Path::new(out_dir.as_ref()).join(format!("{}.c", out_bin_fname));
 
     let source_code = b"int main(void) { return 0; }";
     overwrite_file_contents(&out_src_full, source_code);
     //TODO: remove commented out code everywhere in build.rs
 
     let build = cc::Build::new();
-    let mut linker_searchdir_args: Vec<String> = Vec::new();
-    //Add linker paths from ncurses lib, if any found! ie. -L
-    //(this likely will be empty if pkg-config doesn't exist)
-    //Include paths(for headers) don't matter! ie. -I
-    //Presumably the other libs(menu,panel,tinfo) are in the same dir(s) as the ncurses lib,
-    //because they're part of ncurses even though they're split on some distros/OSs.
-    if let Some(lib) = ncurses_lib {
-        for link_path in &lib.link_paths {
-            linker_searchdir_args.push("-L".to_string());
-            linker_searchdir_args.push(link_path.display().to_string());
-        }
-    }
 
     let mut command = get_the_compiler_command_from_build(build);
 
-    let out_bin_full = Path::new(&out_dir)
-        .join(out_bin_fname)
-        .display()
-        .to_string();
+    let out_bin_full = Path::new(out_dir.as_ref()).join(out_bin_fname);
     //Create a bin(not a lib) from a .c file
     //though it wouldn't matter here if it's bin or lib, I'm
     //not sure how to find its exact output name after, to delete it.
@@ -523,8 +528,18 @@ fn try_link(
         .arg("-o")
         .arg_checked(&out_bin_full)
         .arg_checked(&out_src_full)
-        .args_checked(["-l", lib_name]) //this might require the ncurses lib below(on openbsd for sure!)
-        .args_checked(linker_searchdir_args);
+        .args_checked(["-l", lib_name]); //this might require the ncurses lib below(on openbsd for sure!)
+
+    //Add linker paths from ncurses lib, if any found! ie. -L
+    //(this likely will be empty if pkg-config doesn't exist)
+    //Include paths(for headers) don't matter! ie. -I
+    //Presumably the other libs(menu,panel,tinfo) are in the same dir(s) as the ncurses lib,
+    //because they're part of ncurses even though they're split on some distros/OSs.
+    let linker_searchdir_args: Vec<String> = get_linker_searchdirs(&ncurses_lib);
+    if !linker_searchdir_args.is_empty() {
+        command.args_checked(linker_searchdir_args);
+    }
+
     //this copy will link only the lib, without ncurses
     let mut command_copy: Command = command.make_a_partial_copy(); //woulda been too easy if had .clone()
 
@@ -548,7 +563,7 @@ fn try_link(
             //delete temporary bin that we successfully generated
             std::fs::remove_file(&out_bin_full).unwrap_or_else(|err| {
                 panic!(
-                    "Cannot delete generated bin file '{}', reason: '{}'",
+                    "Cannot delete generated bin file {:?}, reason: '{}'",
                     out_bin_full, err
                 )
             });
@@ -556,7 +571,7 @@ fn try_link(
         //delete the .c that we generated
         std::fs::remove_file(&out_src_full).unwrap_or_else(|err| {
             panic!(
-                "Cannot delete generated C file '{}', reason: '{}'",
+                "Cannot delete generated C file {:?}, reason: '{}'",
                 out_src_full, err
             )
         });
@@ -610,6 +625,8 @@ fn new_build(lib: &Option<Library>) -> cc::Build {
     }
     build.opt_level(1); //else is 0, causes warning on NixOS: _FORTIFY_SOURCE requires compiling with optimization (-O)
 
+    build.define("DEBUG", None); //-DDEBUG so that asserts are enabled for sure!
+
     //XXX:Don't have to emit cargo:rerun-if-env-changed= here because try_flags_from_environment()
     //below does it for us, however it does it on every call! (unless Build::emit_rerun_if_env_changed(false))
     //but if an overriding variant of it is defined like NCURSES_RS_CFLAGS_x86_64_unknown_linux_gnu
@@ -665,24 +682,14 @@ fn gen_rs(
     ncurses_lib: &Option<Library>,
     lib_name: &str,
 ) {
-    //TODO: see if build.file() already emits this!
+    //Build::file() doesn't already emit this:
     println!("cargo:rerun-if-changed={}", source_c_file);
     let out_dir = get_out_dir();
     #[cfg(windows)]
     let out_bin_fname = format!("{}.exe", out_bin_fname); //shadowed
-    let bin_full = Path::new(&out_dir)
-        .join(out_bin_fname)
-        .display()
-        .to_string();
+    let bin_full = Path::new(out_dir.as_ref()).join(out_bin_fname);
 
     let build = new_build(ncurses_lib);
-    let mut linker_searchdir_args: Vec<String> = Vec::new();
-    if let Some(lib) = ncurses_lib {
-        for link_path in &lib.link_paths {
-            linker_searchdir_args.push("-L".to_string());
-            linker_searchdir_args.push(link_path.display().to_string());
-        }
-    }
 
     let mut command = get_the_compiler_command_from_build(build);
 
@@ -692,8 +699,11 @@ fn gen_rs(
         .arg("-o")
         .arg_checked(&bin_full)
         .arg_checked(source_c_file)
-        .args_checked(["-l", lib_name])
-        .args_checked(linker_searchdir_args);
+        .args_checked(["-l", lib_name]);
+    let linker_searchdir_args: Vec<String> = get_linker_searchdirs(&ncurses_lib);
+    if !linker_searchdir_args.is_empty() {
+        command.args_checked(linker_searchdir_args);
+    }
     command.success_or_panic(); //runs compiler
 
     //Execute the compiled binary, panicking if non-zero exit code, else compilation will fail
@@ -704,10 +714,7 @@ fn gen_rs(
 
     //Write the output from executing the binary into a new rust source file .rs
     //That .rs file is later used outside of this build.rs, in the normal build
-    let gen_rust_file_full_path = Path::new(&out_dir)
-        .join(gen_rust_file)
-        .display()
-        .to_string();
+    let gen_rust_file_full_path = Path::new(out_dir.as_ref()).join(gen_rust_file);
     overwrite_file_contents(&gen_rust_file_full_path, &output.stdout);
     //we ignore stderr.
     //we don't delete this file because it's used to compile the rest of the crate.
@@ -715,17 +722,13 @@ fn gen_rs(
 
 fn check_chtype_size(ncurses_lib: &Option<Library>) {
     let out_dir = get_out_dir();
-    //FIXME: see if .display() is a good idea, maybe can avoid it.
-    let src_full = Path::new(&out_dir)
-        .join("chtype_size.c")
-        .display()
-        .to_string();
+    let src_full = Path::new(out_dir.as_ref()).join("chtype_size.c");
     let bin_name = if cfg!(windows) {
         "chtype_size.exe"
     } else {
         "chtype_size"
     };
-    let bin_full = Path::new(&out_dir).join(bin_name).display().to_string();
+    let bin_full = Path::new(out_dir.as_ref()).join(bin_name);
 
     let contents = br#"// autogenerated by build.rs
 #include <assert.h>
@@ -769,13 +772,13 @@ int main(void)
     if DELETE_GENERATEDS {
         std::fs::remove_file(&src_full).unwrap_or_else(|err| {
             panic!(
-                "Cannot delete generated C file '{}', reason: '{}'",
+                "Cannot delete generated C file {:?}, reason: '{}'",
                 src_full, err
             )
         });
         std::fs::remove_file(&bin_full).unwrap_or_else(|err| {
             panic!(
-                "cannot delete compiled bin file '{}', reason: '{}'",
+                "cannot delete compiled bin file {:?}, reason: '{}'",
                 bin_full, err
             )
         });
@@ -980,7 +983,7 @@ impl MyCompilerCommand for std::process::Command {
             );
             show_stdout_stderr();
             eprintln!(
-                //FIXME: this msg can't be part of the (future)extension trait impl, it's for src/genconstants.c only.
+                //FIXME: this msg can't be part of the extension trait impl, it's for src/genconstants.c only.
                 "!! Maybe you need to try a different value for the TERM environment variable !!"
             );
             and_panic();
@@ -1169,7 +1172,7 @@ impl MyCompilerCommand for std::process::Command {
         let (exe_name, how_many_args, formatted_args, cur_dir, formatted_env_vars) =
             self.get_what_will_run();
         let cur_dir: String = if let Some(dir) = cur_dir {
-            format!(", in current dir: '{}'", dir.display())
+            format!(", in current dir: {:?}", dir)
         } else {
             ", in unspecified current dir".to_string()
         };

From 2a49edb4c93566a8edbfc09b08a0e9ec6ebbcf97 Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Sun, 21 Apr 2024 13:39:33 +0200
Subject: [PATCH 41/54] small build.rs improvements

* some todos/fixmes got addressed
---
 build.rs | 275 ++++++++++++++++++++++++++++++++++++++-----------------
 1 file changed, 190 insertions(+), 85 deletions(-)

diff --git a/build.rs b/build.rs
index f4b15aec..1bad99b1 100644
--- a/build.rs
+++ b/build.rs
@@ -29,7 +29,7 @@ use std::process::ExitStatus;
 //Decide whether or not to delete .c and bin files generated by build.rs once they're not needed.
 //Defaulting to 'false' because it's a job for 'cargo clean' and
 //it might help with debugging build issues if we keep them around.
-//even if this were true, we're already keeping 'libwrap.a', so FIXME: if this is set true.
+//Even if this were true, we're already keeping 'libwrap.a' which we can't delete because cargo needs.
 const DELETE_GENERATEDS: bool = false;
 
 // Optional environment variables:
@@ -55,17 +55,17 @@ const ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS: &str = "NCURSES_RS_CFLAGS";
 
 const IS_WIDE: bool = cfg!(feature = "wide");
 const IS_MACOS: bool = cfg!(target_os = "macos");
-// Why also not on macos? see: https://github.com/jeaye/ncurses-rs/issues/151
+// Why _also_ not on macos? see: https://github.com/jeaye/ncurses-rs/issues/151
 const IS_WIDE_AND_NOT_ON_MACOS: bool = IS_WIDE && !IS_MACOS;
 
-// Will search for these lib names and if not found via pkg-config
-// then use the fallback name and still try linking with it
-// because in most cases it will work anyway.
 const NCURSES_LIB_NAME_FALLBACK: &str = if IS_WIDE_AND_NOT_ON_MACOS {
     "ncursesw"
 } else {
     "ncurses"
 };
+// Will search for these lib names and if not found via pkg-config
+// then use the fallback name and still try linking with it
+// because in most cases it will work anyway.
 const NCURSES_LIB_NAMES: &[&str] = if IS_WIDE_AND_NOT_ON_MACOS {
     &["ncursesw5", NCURSES_LIB_NAME_FALLBACK]
 } else {
@@ -358,6 +358,7 @@ fn main() {
         "raw_constants.rs",
         &ncurses_lib,
         &lib_name,
+        "!! Maybe you need to try a different value for the TERM environment variable !!",
     );
 
     gen_rs(
@@ -366,6 +367,7 @@ fn main() {
         "menu_constants.rs",
         &ncurses_lib,
         &lib_name,
+        "",
     );
 
     build_wrap(&ncurses_lib);
@@ -474,7 +476,7 @@ fn get_linker_searchdirs(from_lib: &Option<Library>) -> Vec<String> {
             //show the path in a message.
             linker_searchdir_args.push(link_path.to_str().unwrap_or_else(|| {
                 //XXX: We use debug {:?} to show the path because .display() wouldn't show for example
-                //\0 in the path.
+                //\0 in the path, well, it's invisible on the terminal.
                 panic!("!!! Lib link path {:?} contains invalid UTF-8. This is likely an existing path on you system, so to get rid of this, you'd have to fix/rename the path to be UTF-8. This path was likely found via `pkg-config`.", link_path);
             }).to_string());
         }
@@ -545,12 +547,12 @@ fn try_link(
 
     //we add ncurses to linked libs, but we only call this if the first try(ie. that copy) fails.
     command.args_checked(["-l", ncurses_lib_name_to_use]);
-    let exit_status = command_copy.status_or_panic(); //runs compiler
+    let exit_status = command_copy.status_or_panic("compilation(without ncurses lib)"); //runs compiler
     let mut ret: bool = exit_status.success();
     let mut requires_ncurses_lib: bool = false;
     if !ret {
         //first try failed, try second with -lncurses(w) added.
-        let exit_status = command.status_or_panic(); //runs compiler
+        let exit_status = command.status_or_panic("compilation(with ncurses lib)"); //runs compiler
         ret = exit_status.success();
         if ret {
             //cargo_warn!("");
@@ -584,8 +586,8 @@ fn try_link(
     };
 }
 
-//TODO: change this to apply to anything that's emitted for cargo to consume, except warnings, and
-//make it HashMap with a counter.
+//TODO: maybe change this to apply to anything that's emitted for cargo to consume, except warnings,
+//and make it HashMap with a counter.
 /// Emits "cargo:rerun-if-env-changed=ENV_VAR" on stdout
 /// only once for each ENV_VAR
 /// regardless of how many times it gets called.
@@ -681,6 +683,7 @@ fn gen_rs(
     gen_rust_file: &str,
     ncurses_lib: &Option<Library>,
     lib_name: &str,
+    additional_msg_when_non_zero_exit_code: &str,
 ) {
     //Build::file() doesn't already emit this:
     println!("cargo:rerun-if-changed={}", source_c_file);
@@ -704,13 +707,19 @@ fn gen_rs(
     if !linker_searchdir_args.is_empty() {
         command.args_checked(linker_searchdir_args);
     }
-    command.success_or_panic(); //runs compiler
+    command.success_or_panic("compilation"); //runs compiler
 
     //Execute the compiled binary, panicking if non-zero exit code, else compilation will fail
     //later with things like: "error[E0432]: unresolved import `constants::TRUE`" in the case of
     //generating raw_constants.rs which would be empty due to 'genconstants' having failed with exit
     //code 1 because env.var. TERM=a_terminal_not_in_term_database
-    let output: std::process::Output = Command::new(&bin_full).output_success_or_panic();
+    let output: std::process::Output = Command::new(&bin_full).output_success_or_panic(
+        &format!(
+            "the binary(compiled from the existing C file '{}')",
+            source_c_file
+        ),
+        additional_msg_when_non_zero_exit_code,
+    );
 
     //Write the output from executing the binary into a new rust source file .rs
     //That .rs file is later used outside of this build.rs, in the normal build
@@ -722,11 +731,13 @@ fn gen_rs(
 
 fn check_chtype_size(ncurses_lib: &Option<Library>) {
     let out_dir = get_out_dir();
-    let src_full = Path::new(out_dir.as_ref()).join("chtype_size.c");
+    let basename = "chtype_size";
+    let src_file_name = format!("{}.c", basename);
+    let src_full = Path::new(out_dir.as_ref()).join(&src_file_name);
     let bin_name = if cfg!(windows) {
-        "chtype_size.exe"
+        format!("{}.exe", basename)
     } else {
-        "chtype_size"
+        basename.to_string()
     };
     let bin_full = Path::new(out_dir.as_ref()).join(bin_name);
 
@@ -737,8 +748,14 @@ fn check_chtype_size(ncurses_lib: &Option<Library>) {
 
 #include <ncurses.h>
 
+//#include <stdlib.h> //for exit() below, else shows warnings.
+
 int main(void)
 {
+    //foofoo //uncomment to see what happens if compiler fails to compile
+    //assert(false);//to test what happens if execution fails when killed by signal 6
+    //exit(23);//to test if bin execution fails with exit code != 0
+
     if (sizeof(chtype)*CHAR_BIT == 64) {
         puts("cargo:rustc-cfg=feature=\"wide_chtype\"");
     } else {
@@ -762,9 +779,15 @@ int main(void)
         .arg("-o")
         .arg_checked(&bin_full)
         .arg_checked(&src_full);
-    command.success_or_panic(); //runs compiler
-
-    let features = Command::new(&bin_full).output_success_or_panic();
+    command.success_or_panic("compilation"); //runs compiler
+
+    let features = Command::new(&bin_full).output_success_or_panic(
+        &format!(
+            "the binary(compiled from the generated C file '{}' in the same dir)",
+            &src_file_name
+        ),
+        "",
+    );
 
     //for cargo to consume
     print!("{}", String::from_utf8_lossy(&features.stdout));
@@ -785,7 +808,7 @@ int main(void)
     }
 }
 
-//call this only once, to avoid re-printing "cargo:rustc-link-lib=" // FIXME
+// you must call this only once, to avoid re-printing "cargo:rustc-link-lib=" // FIXME
 fn get_ncurses_lib_name(ncurses_lib: &Option<Library>) -> String {
     //Was it found(and thus printed) by pkg_config::probe_library() ?
     let mut already_printed: bool = false;
@@ -882,13 +905,18 @@ impl MyExitStatus for std::process::ExitStatus {
 
 // Define an extension trait for Command
 trait MyCompilerCommand {
-    fn output_or_panic(&mut self) -> std::process::Output;
-    fn output_success_or_panic(&mut self) -> std::process::Output;
-    fn success_or_panic(&mut self) -> ExitStatus;
+    fn output_or_panic(&mut self, what_kind_of_process_is_it: &str) -> std::process::Output;
+    fn output_success_or_panic(
+        &mut self,
+        what_kind_of_process_is_it: &str,
+        additional_msg_when_non_zero: &str,
+    ) -> std::process::Output;
+    fn success_or_panic(&mut self, what_kind_of_command_is_it: &str) -> ExitStatus;
     //fn success_or_else<F: FnOnce(ExitStatus) -> ExitStatus>(&mut self, op: F) -> ExitStatus;
-    fn just_status_or_panic(&mut self) -> ExitStatus;
-    fn status_or_panic(&mut self) -> ExitStatus;
-    fn status_or_panic_but_no_check_args(&mut self) -> ExitStatus;
+    fn just_status_or_panic(&mut self, what_kind_of_command_is_it: &str) -> ExitStatus;
+    fn status_or_panic(&mut self, what_kind_of_command_is_it: &str) -> ExitStatus;
+    fn status_or_panic_but_no_check_args(&mut self, what_kind_of_command_is_it: &str)
+        -> ExitStatus;
     fn show_what_will_run(&mut self) -> &mut Self;
     fn get_program_or_panic(&self) -> &str;
     fn get_what_will_run(&self) -> (String, usize, String, Option<&Path>, String);
@@ -924,16 +952,21 @@ const REPLACEMENT_FOR_ARG_THAT_HAS_NUL: &str = "<string-with-nul>";
 impl MyCompilerCommand for std::process::Command {
     /// Executes Command::output() and gives you Output struct or panics
     /// but the exit code may not have been 0
-    fn output_or_panic(&mut self) -> std::process::Output {
+    fn output_or_panic(&mut self, what_kind_of_process_is_it: &str) -> std::process::Output {
         self.output().unwrap_or_else(|err| {
-            self.panic(err, "generated bin"); //TODO: let caller provide this
+            self.panic(err, what_kind_of_process_is_it);
         })
     }
 
     /// Executes Command::output() and gives you Output struct or panics
     /// also panics if exit code was not 0 and shows you stdout/stderr if so.
-    fn output_success_or_panic(&mut self) -> std::process::Output {
-        let output = self.output_or_panic();
+    /// The extra args are to be displayed in cases of errors.
+    fn output_success_or_panic(
+        &mut self,
+        what_kind_of_process_is_it: &str,
+        additional_msg_when_non_zero_exit_code: &str,
+    ) -> std::process::Output {
+        let output = self.output_or_panic(what_kind_of_process_is_it);
         // test this with: `$ TERM=foo cargo build`
         let show_stdout_stderr = || {
             //XXX: presumably eprintln! and std::io::stderr().write_all().unwrap() write to same stderr
@@ -951,8 +984,8 @@ impl MyCompilerCommand for std::process::Command {
         let prog = self.get_program_or_panic();
         let and_panic = || -> ! {
             panic!(
-                "due to the above-reported error while executing '{}'.",
-                prog
+                "due to the above-reported error while executing {} '{}'.",
+                what_kind_of_process_is_it, prog
             );
         };
 
@@ -962,15 +995,16 @@ impl MyCompilerCommand for std::process::Command {
             //To test this branch uncomment a segfault line early in src/genconstants.c then `cargo build`
 
             let basename=Path::new(prog).file_name().unwrap_or_else(|| {
-                eprintln!("Couldn't get basename for '{}'", prog);
+                eprintln!("Couldn't get basename for {} '{}'", what_kind_of_process_is_it,prog);
                 OsStr::new("") //refusing to panic over this
             });
             let basename=basename.to_str().unwrap_or_else(|| {
-                eprintln!("Couldn't convert OsStr '{:?}' to &str", basename);
+                eprintln!("Couldn't convert OsStr '{:?}' to &str, while processing the file name of {} '{}'", basename, what_kind_of_process_is_it,prog);
                 "" //refusing to panic over this
             });
             eprintln!(
-                "!!! Execution of '{}' failed, likely killed by signal! Maybe check 'dmesg' for the word \"segfault\" or \"{}\". We can't know here, which signal happened.",
+                "!!! Execution of {} '{}' failed, likely killed by signal! Maybe check 'dmesg' for the word \"segfault\" or \"{}\". We can't know here, which signal happened.",
+                what_kind_of_process_is_it,
                 prog, basename
                 );
             show_stdout_stderr();
@@ -978,14 +1012,11 @@ impl MyCompilerCommand for std::process::Command {
         });
         if 0 != exit_code {
             eprintln!(
-                "!!! Execution of '{}' failed with exit code '{}'",
-                prog, exit_code
+                "!!! Execution of {} '{}' failed with exit code '{}'",
+                what_kind_of_process_is_it, prog, exit_code
             );
             show_stdout_stderr();
-            eprintln!(
-                //FIXME: this msg can't be part of the extension trait impl, it's for src/genconstants.c only.
-                "!! Maybe you need to try a different value for the TERM environment variable !!"
-            );
+            eprintln!("{}", additional_msg_when_non_zero_exit_code);
             and_panic();
         } else {
             return output;
@@ -995,8 +1026,10 @@ impl MyCompilerCommand for std::process::Command {
     /// Executes Command::status().success() and panics if it any fail
     /// This means exit code 0 is ensured.
     /// Note: You can't use an arg value "<string-with-nul>", or this will panic.
-    fn success_or_panic(&mut self) -> ExitStatus {
-        let exit_status: ExitStatus = self.status_or_panic().success_or_panic();
+    fn success_or_panic(&mut self, what_kind_of_command_is_it: &str) -> ExitStatus {
+        let exit_status: ExitStatus = self
+            .status_or_panic(what_kind_of_command_is_it)
+            .success_or_panic();
         exit_status
     }
 
@@ -1023,7 +1056,7 @@ impl MyCompilerCommand for std::process::Command {
             //The found arg here will be shown with \0 in this Debug way.
             panic!(
                 "Found arg '{:?}' that has at least one \\0 aka nul in it! \
-                   This would've been replaced with '{}'.",
+                   This would've been silently replaced with '{}' and error later if at all.",
                 arg.as_ref(),
                 REPLACEMENT_FOR_ARG_THAT_HAS_NUL
             );
@@ -1056,8 +1089,7 @@ impl MyCompilerCommand for std::process::Command {
         let program = self.get_program();
         let p_prog = program
             .to_str()
-            .unwrap_or_else(|| panic!("Compiler executable {:?} isn't valid rust string", program));
-        //TODO: "Compiler" is too specific here, could be we're running just a bin we created!
+            .unwrap_or_else(|| panic!("Executable {:?} isn't valid rust string", program));
         p_prog
     }
 
@@ -1127,20 +1159,20 @@ impl MyCompilerCommand for std::process::Command {
     /// returns ExitStatus whether it be 0 or !=0
     /// Doesn't show you what will be executed and doesn't check args.
     /// (not meant to be used outside)
-    fn just_status_or_panic(&mut self) -> ExitStatus {
+    fn just_status_or_panic(&mut self, what_kind_of_command_is_it: &str) -> ExitStatus {
         // Call the original status() method and handle the potential error
         self.status().unwrap_or_else(|err| {
-            self.panic(err, "compilation"); //TODO: let caller provide this?!
+            self.panic(err, what_kind_of_command_is_it);
         })
     }
 
     /// Shows command that will execute and checks args, only after this
     /// it's gonna be trying to do .status()
     /// Panics if status would've returned an Err
-    fn status_or_panic(&mut self) -> ExitStatus {
+    fn status_or_panic(&mut self, what_kind_of_command_is_it: &str) -> ExitStatus {
         self.show_what_will_run()
             .assert_no_nul_in_args()
-            .just_status_or_panic()
+            .just_status_or_panic(what_kind_of_command_is_it)
     }
 
     /// Used only for build.rs tests:
@@ -1148,22 +1180,36 @@ impl MyCompilerCommand for std::process::Command {
     /// aren't nul-containing and thus won't panic before the original status() gets run, thus
     /// allowing it to panic on nul.
     /// (not meant to be used outside)
-    fn status_or_panic_but_no_check_args(&mut self) -> ExitStatus {
-        self.show_what_will_run().just_status_or_panic()
+    fn status_or_panic_but_no_check_args(
+        &mut self,
+        what_kind_of_command_is_it: &str,
+    ) -> ExitStatus {
+        self.show_what_will_run()
+            .just_status_or_panic(what_kind_of_command_is_it)
     }
 
     /// (not meant to be used outside)
+    //panic(  <- for search
     fn panic<T: std::fmt::Display>(&mut self, err: T, what_type_of_command: &str) -> ! {
-        //FIXME: show cur_dir and envs too? but don't dup code from show_what_will_run()
-        let (p_prog, how_many_args, formatted_args, _cur_dir, _envs) = self.get_what_will_run();
+        let (p_prog, how_many_args, formatted_args, cur_dir, formatted_env_vars) =
+            self.get_what_will_run();
         let extra_space = if what_type_of_command.is_empty() {
             ""
         } else {
             " "
         };
+        let (cur_dir_for_print, env_vars_for_print) =
+            get_cd_and_env_for_print(cur_dir, formatted_env_vars);
         panic!(
-            "Failed to run {}{}command '{}' with '{}' args: '{}', reason: '{}'",
-            what_type_of_command, extra_space, p_prog, how_many_args, formatted_args, err
+            "Failed to run {}{}command '{}' with '{}' args: '{}'{}{}, reason: '{}'",
+            what_type_of_command,
+            extra_space,
+            p_prog,
+            how_many_args,
+            formatted_args,
+            cur_dir_for_print,
+            env_vars_for_print,
+            err
         )
     }
 
@@ -1171,24 +1217,16 @@ impl MyCompilerCommand for std::process::Command {
     fn show_what_will_run(&mut self) -> &mut Self {
         let (exe_name, how_many_args, formatted_args, cur_dir, formatted_env_vars) =
             self.get_what_will_run();
-        let cur_dir: String = if let Some(dir) = cur_dir {
-            format!(", in current dir: {:?}", dir)
-        } else {
-            ", in unspecified current dir".to_string()
-        };
-        let formatted_env_vars: String = if formatted_env_vars.is_empty() {
-            ", with no extra env.vars added or deleted".to_string()
-        } else {
-            format!(", with env.vars: '{}'", formatted_env_vars)
-        };
+        let (cur_dir_for_print, env_vars_for_print) =
+            get_cd_and_env_for_print(cur_dir, formatted_env_vars);
         eprintln!(
             "!! Next, attempting to run command '{}' with '{}' args: '{}'{}{}.",
-            exe_name, how_many_args, formatted_args, cur_dir, formatted_env_vars
+            exe_name, how_many_args, formatted_args, cur_dir_for_print, env_vars_for_print
         );
         self
     }
 
-    /// copies exe,args,pwd and env.vars
+    /// copies exe,args,cwd and env.vars
     fn make_a_partial_copy(&self) -> Self {
         let prog = self.get_program();
         let mut r#new = Command::new(prog);
@@ -1209,6 +1247,27 @@ impl MyCompilerCommand for std::process::Command {
     }
 }
 
+fn get_cd_and_env_for_print(
+    cur_dir: Option<&Path>,
+    formatted_env_vars: String,
+) -> (String, String) {
+    let cur_dir_for_print: String = if let Some(dir) = cur_dir {
+        format!(", in current dir: {:?}", dir)
+    } else {
+        format!(
+            ", in unspecified current dir(but the actual cwd is currently {:?})",
+            env::current_dir()
+        )
+    };
+    let formatted_env_vars_for_print: String = if formatted_env_vars.is_empty() {
+        ", with no extra env.vars added or deleted(so all are inherited from parent process)"
+            .to_string()
+    } else {
+        format!(", with env.vars: '{}'", formatted_env_vars)
+    };
+    (cur_dir_for_print, formatted_env_vars_for_print)
+}
+
 /// This is used to test build.rs, run with: cargo build --features=test_build_rs_of_ncurses_rs
 /// This won't happen if you use --all-features
 #[cfg(all(
@@ -1217,6 +1276,7 @@ impl MyCompilerCommand for std::process::Command {
 ))]
 fn main() {
     test_assert_works();
+    test_match_with_placeholders();
     test_invalid_utf8_in_program();
     test_nul_in_arg_unchecked();
     test_nul_in_arg();
@@ -1260,7 +1320,7 @@ fn test_no_panic_in_command() {
         let mut command = Command::new(cmd);
         command.args(args_ok);
         //execute: sh -c 'exit 0'`
-        command.status_or_panic();
+        command.status_or_panic("test1");
     });
     let fail_msg = format!(
         "!!! This should not have panicked! Unless you don't have '{}' command, in PATH={:?} !!!",
@@ -1274,7 +1334,7 @@ fn test_no_panic_in_command() {
         let mut command = Command::new(cmd);
         command.args(args_ok);
         //execute: sh -c 'exit 0'`
-        command.success_or_panic();
+        command.success_or_panic("test2");
     });
     assert!(result.is_ok(), "{}", fail_msg);
 
@@ -1283,7 +1343,7 @@ fn test_no_panic_in_command() {
         let mut command = Command::new(cmd);
         command.args(args_fail);
         //execute: sh -c 'exit 42'`
-        let exit_status = command.status_or_panic();
+        let exit_status = command.status_or_panic("test3");
         assert_eq!(
             exit_status.code().expect("was command killed by a signal?"),
             expected_ec,
@@ -1299,16 +1359,16 @@ fn test_panic_for_not_found_command() {
     let result = std::panic::catch_unwind(|| {
         let mut command = Command::new("some non-exitent command");
         command.args([OsString::from("arg1")]);
-        command.status_or_panic();
+        command.status_or_panic("inexistent");
     });
     let expected_panic_msg=
-     "Failed to run compilation command 'some non-exitent command' with '1' args: '\"arg1\"', reason: 'No such file or directory (os error 2)'";
+     "Failed to run inexistent command 'some non-exitent command' with '1' args: '\"arg1\"', in unspecified current dir(but the actual cwd is currently Ok({})), with no extra env.vars added or deleted(so all are inherited from parent process), reason: 'No such file or directory (os error 2)'";
     expect_panic(result, expected_panic_msg);
 
     let result = std::panic::catch_unwind(|| {
         let mut command = Command::new("some non-exitent command");
         command.args([OsString::from("arg1")]);
-        command.success_or_panic();
+        command.success_or_panic("inexistent");
     });
     expect_panic(result, expected_panic_msg);
 }
@@ -1320,7 +1380,7 @@ fn test_panic_for_command_non_zero_exit() {
     let result = std::panic::catch_unwind(|| {
         let mut command = Command::new(cmd);
         command.args(args_fail);
-        command.success_or_panic();
+        command.success_or_panic("shell-type");
     });
     let expected_panic_msg = "!!! Compiler failed with exit code 43. Is ncurses installed? pkg-config or pkgconf too? it's 'ncurses-devel' on Fedora; and 'libncurses-dev' on Ubuntu; run `nix-shell` first, on NixOS. Or maybe it failed for different reasons which are seen in the errored output above.";
     expect_panic(result, expected_panic_msg);
@@ -1336,23 +1396,67 @@ fn test_invalid_utf8_in_program() {
             OsString::from("arg1"),
             OsString::from_vec(b"my\xffarg3".to_vec()),
         ]);
-        command.status_or_panic();
+        command.status_or_panic("test-type");
     });
     expect_panic(
         result,
-        "Compiler executable \"test_invalid_utf8_\\xFFin_program\" isn't valid rust string",
+        "Executable \"test_invalid_utf8_\\xFFin_program\" isn't valid rust string",
     );
 }
+#[allow(dead_code)]
+fn test_match_with_placeholders() {
+    let str1 = "abc";
+    let str2 = "abc";
+    let str3 = "a{}bc";
+    let str4 = "a{}c";
+    assert!(match_with_placeholders(str1, str2));
+    assert!(match_with_placeholders(str1, str3));
+    assert!(match_with_placeholders(str1, str4));
+    let str5 = "";
+    let str6 = "{}";
+    let str7 = "{}{}{}";
+    let str8 = "{}a{}{}{}b{}{}c{}{}";
+    assert!(match_with_placeholders(str5, str5));
+    assert!(match_with_placeholders(str5, str6));
+    assert!(match_with_placeholders(str5, str7));
+    assert!(match_with_placeholders(str1, str8));
+
+    let p_msg = "some random thing";
+    let r: Result<(), Box<dyn std::any::Any + Send>> = Err(Box::new(p_msg.to_string()));
+    expect_panic(r, "some {} thing");
+}
 
+fn match_with_placeholders(pristine_str: &str, placeholdery_str: &str) -> bool {
+    // Split placeholdery_str into substrings based on {}
+    let placeholders: Vec<&str> = placeholdery_str.split("{}").collect();
+
+    // Check if pristine_str contains all the substrings in order
+    let mut index = 0;
+    for &placeholder in &placeholders {
+        match pristine_str[index..].find(placeholder) {
+            Some(pos) => index += pos + placeholder.len(),
+            None => {
+                return false;
+            }
+        }
+    }
+    true
+}
+
+/// Panics if the 'result' has a different panic message than the expected one.
+/// The {} in the expected message string can match anything, including empty string.
 fn expect_panic(result: Result<(), Box<dyn std::any::Any + Send>>, expected_panic_message: &str) {
     if result.is_err() {
         if let Some(err) = result.unwrap_err().downcast_ref::<String>() {
             // Uncomment this to can copy/paste it for asserts:
             //println!("!!!!!!!!!! Panic message: {:?}", err);
-            assert_eq!(
-                err, expected_panic_message,
-                "!!! Got different panic message than expected !!!"
-            );
+
+            if !match_with_placeholders(err, expected_panic_message) {
+                panic!(
+                "!!! Got different panic message than expected !!!\n\nExpected: '{}'\n\n     Got: '{}'\n",
+                expected_panic_message, err
+                );
+            }
         }
     } else {
         panic!(
@@ -1371,10 +1475,10 @@ fn test_nul_in_arg_unchecked() {
             OsString::from("a\0rg2"),
             OsString::from_vec(b"my\xffarg3".to_vec()),
         ]);
-        command.status_or_panic_but_no_check_args();
+        command.status_or_panic_but_no_check_args("funky");
     });
     expect_panic(result,
-         "Failed to run compilation command 'test_nul_in_arg_unchecked.exe' with '3' args: '\"arg1\" \"<string-with-nul>\" \"my\\xFFarg3\"', reason: 'nul byte found in provided data'"
+         "Failed to run funky command 'test_nul_in_arg_unchecked.exe' with '3' args: '\"arg1\" \"<string-with-nul>\" \"my\\xFFarg3\"', in unspecified current dir(but the actual cwd is currently Ok({}), with no extra env.vars added or deleted(so all are inherited from parent process), reason: 'nul byte found in provided data'"
         );
 }
 
@@ -1389,10 +1493,10 @@ fn test_nul_in_arg() {
             OsString::from("a\0rg2"),
         );
         command.arg_checked(OsString::from_vec(b"my\xffarg3".to_vec()));
-        command.status_or_panic();
+        command.status_or_panic("test-type");
     });
     let expected_panic_msg=
-         "Found arg '\"a\\0rg2\"' that has at least one \\0 aka nul in it! This would've been replaced with '<string-with-nul>'.";
+         "Found arg '\"a\\0rg2\"' that has at least one \\0 aka nul in it! This would've been silently replaced with '<string-with-nul>' and error later if at all.";
     expect_panic(result, expected_panic_msg);
     //via .args()
     let result = std::panic::catch_unwind(|| {
@@ -1403,7 +1507,7 @@ fn test_nul_in_arg() {
             OsString::from("a\0rg2"),
             OsString::from_vec(b"my\xffarg3".to_vec()),
         ]);
-        command.status_or_panic();
+        command.status_or_panic("test-type");
     });
     expect_panic(result, expected_panic_msg);
 }
@@ -1447,3 +1551,4 @@ fn test_assert_no_nul_in_args() {
     });
     assert!(result.is_ok(), "!!! This should not have panicked !!!");
 }
+//TODO: test more functionality.

From 7bd7980cfeaf378293ea1e09dd15e9265f844019 Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Sun, 21 Apr 2024 16:51:38 +0200
Subject: [PATCH 42/54] use addr_of!() to get rid of warning; set MSRV.

* the use addr_of!() macro requires minimum supported rust version(MSRV)
to be set to 1.51.0, which is now set in Cargo.toml as rust-version=
however, using rust-version= requires 1.56.0 MSRV

* it's unclear what the MSRV was before this change, but it wasn't
  specified in Cargo.toml, and now due to the dep 'cc' being at 1.0.95
  it requires MSRV 1.63.0 (as Cargo.lock doesn't exist and 'cc' dep
  version in Cargo.toml here wasn't pinned to a specific 'cc' version)

* due to build.rs 's use of OnceLock the MSRV must be 1.70.0, and is
  thus set now.

The warning was this (not shown with rustc 1.76.0 but seen with 1.79.0):

   Compiling ncurses v6.0.0 (/home/user/sandbox/37/ncurses-rs)
warning: creating a shared reference to mutable static is discouraged
  --> src/constants.rs:61:9
   |
61 |         &wrapped::acs_map as *const chtype
   |         ^^^^^^^^^^^^^^^^^ shared reference to mutable static
   |
   = note: for more information, see issue #114447 <https://github.com/rust-lang/rust/issues/114447>
   = note: this will be a hard error in the 2024 edition
   = note: this shared reference has lifetime `'static`, but if the static ever gets mutated, or a mutable reference is created, then any further use of this shared reference is Undefined Behavior
   = note: `#[warn(static_mut_refs)]` on by default
help: use `addr_of!` instead to create a raw pointer
   |
61 |         addr_of!(wrapped::acs_map) as *const chtype
   |         ~~~~~~~~~~~~~~~~~~~~~~~~~~

warning: `ncurses` (lib) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.63s
---
 Cargo.toml       | 9 +++++++++
 src/constants.rs | 4 +++-
 2 files changed, 12 insertions(+), 1 deletion(-)

diff --git a/Cargo.toml b/Cargo.toml
index 96a1d791..a57b3f18 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -10,6 +10,15 @@ readme = "README.md"
 keywords = ["ncurses","TUI"]
 license = "MIT"
 build = "build.rs"
+#https://doc.rust-lang.org/cargo/reference/manifest.html#the-rust-version-field
+rust-version = "1.70.0"
+#Using this key rust-version= here aka MSRV, makes 1.56.0 be the minimum supported rust version(MSRV)
+#The first version of Cargo that supports this field was released with Rust 1.56.0. In older releases, the field will be ignored, and Cargo will display a warning.
+#Due to addr_of!() MSRV 1.51.0 is required minimum.
+#cc 1.0.92 requires 1.53.0 MSRV, however `cargo build` will pull latest cc due to
+# Cargo.lock missing(on first repo clone) and cc version specified isn't fixed like cc="=1.0.92", so:
+#due to latest cc pulled being 1.0.95(21Apr2024) it requires 1.63.0 MSRV (ie: `cargo msrv list`)
+#Due to build.rs OnceLock() 1.70.0 is required minimum.
 
 [build-dependencies]
 cc = "1.0.92"
diff --git a/src/constants.rs b/src/constants.rs
index 9d6487b5..4ffb313c 100644
--- a/src/constants.rs
+++ b/src/constants.rs
@@ -58,7 +58,9 @@ wrap_extern!(LINES: c_int);
 wrap_extern!(TABSIZE: c_int);
 pub fn acs_map() -> *const chtype {
     unsafe {
-        &wrapped::acs_map as *const chtype
+        std::ptr::addr_of!(wrapped::acs_map) as *const chtype
+        // addr_of! needs minimum rust 1.51.0, if want lower, try this instead:
+        // &wrapped::acs_map as *const chtype
     }
 }
 

From 3543ea613faac3d6cb1a7ea950ef3ed091b20f25 Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Sun, 21 Apr 2024 19:02:59 +0200
Subject: [PATCH 43/54] feature not_OnceLock allows MSRV as low as 1.57.0

but you'd have to pin cc to =1.0.92 too, then also
set rust-version="1.57.0", in Cargo.toml

otherwise cc will be 1.0.95 (because Cargo.lock isn't saved in repo,
or the cc version pinned to 1.0.92) which requires MSRV 1.63.0,
and OnceLock usage in build.rs requires 1.70.0 MSRV
and rust-version="1.70.0" is already set in Cargo.toml
---
 Cargo.toml | 13 +++++++++--
 build.rs   | 63 ++++++++++++++++++++++++++++++++++++++++++------------
 2 files changed, 60 insertions(+), 16 deletions(-)

diff --git a/Cargo.toml b/Cargo.toml
index a57b3f18..35859347 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -11,7 +11,7 @@ keywords = ["ncurses","TUI"]
 license = "MIT"
 build = "build.rs"
 #https://doc.rust-lang.org/cargo/reference/manifest.html#the-rust-version-field
-rust-version = "1.70.0"
+rust-version = "1.70.0" #but can be 1.57.0, see feature not_OnceLock
 #Using this key rust-version= here aka MSRV, makes 1.56.0 be the minimum supported rust version(MSRV)
 #The first version of Cargo that supports this field was released with Rust 1.56.0. In older releases, the field will be ignored, and Cargo will display a warning.
 #Due to addr_of!() MSRV 1.51.0 is required minimum.
@@ -19,6 +19,10 @@ rust-version = "1.70.0"
 # Cargo.lock missing(on first repo clone) and cc version specified isn't fixed like cc="=1.0.92", so:
 #due to latest cc pulled being 1.0.95(21Apr2024) it requires 1.63.0 MSRV (ie: `cargo msrv list`)
 #Due to build.rs OnceLock() 1.70.0 is required minimum.
+#But you can use --features=not_OnceLock to get MSRV to 1.57.0 or lower
+#Due to build.rs' use of std::process::Command::get_*() MSRV is 1.57.0
+#To minimize MSRV further you can set `cc = "=1.0.92"` (not the extra "=") below then run `cargo update`
+# that makes MSRV be 1.53.0 minimum, but other things will raise it at 1.57.0
 
 [build-dependencies]
 cc = "1.0.92"
@@ -39,8 +43,13 @@ wide_chtype = []
 mouse_v1 = []
 extended_colors = ["wide"]
 
+# Use this feature to reduce MSRV to 1.57.0, it only affects build.rs code anyway,
+#but you've to set cc="=1.0.92" too, and rust-version="1.57.0" above.
+# This isn't picked up with --all-features; if all is wanted, you've to specify each by hand via --features=
+not_OnceLock = []
+
 #Internal features used in 'build.rs' only:
-test_build_rs_of_ncurses_rs = []
+test_build_rs_of_ncurses_rs = [] #<- not picked up by --all-features
 dummy_feature_to_detect_that_--all-features_arg_was_used= []
 
 [lib]
diff --git a/build.rs b/build.rs
index 1bad99b1..f3d8f349 100644
--- a/build.rs
+++ b/build.rs
@@ -445,22 +445,40 @@ fn overwrite_file_contents<P: AsRef<Path>>(file_name: P, contents: &[u8]) {
     drop(file); //explicit file close, not needed since it's in a function now!
 }
 
+//OUT_DIR is set by cargo during `cargo build` while build.rs' bin gets executed, but not during
+//the compilation(ie. env!("OUT_DIR") isn't set!)
+const ENV_NAME_OF_OUT_DIR: &str = "OUT_DIR";
+#[inline]
+fn internal_get_out_dir() -> impl AsRef<Path> {
+    let out_dir=env::var(ENV_NAME_OF_OUT_DIR).unwrap_or_else(|err| {
+        panic!(
+            "Cannot get env.var. '{}', reason: '{}'. Use `cargo build` instead of running this build script binary directly!",
+            ENV_NAME_OF_OUT_DIR, err
+            )
+    });
+    out_dir
+}
+
+/// attempts to lower MSRV by not using OnceLock
+#[cfg(all(
+    feature = "not_OnceLock",
+    not(feature = "dummy_feature_to_detect_that_--all-features_arg_was_used")
+))]
+fn get_out_dir() -> impl AsRef<Path> {
+    std::path::PathBuf::from(internal_get_out_dir().as_ref())
+}
+
+/// thread safe memoizing func(via OnceLock) for returning OUT_DIR env. var. value
+#[cfg(any(
+    not(feature = "not_OnceLock"),
+    feature = "dummy_feature_to_detect_that_--all-features_arg_was_used"
+))]
 fn get_out_dir() -> impl AsRef<Path> {
     use std::path::PathBuf;
     use std::sync::OnceLock;
     static LOCK: OnceLock<PathBuf> = OnceLock::new();
 
-    //OUT_DIR is set by cargo during build
-    const ENV_NAME_OF_OUT_DIR: &str = "OUT_DIR";
-    let pb_ref:&PathBuf = LOCK.get_or_init(|| {
-        let out_dir=env::var(ENV_NAME_OF_OUT_DIR).unwrap_or_else(|err| {
-            panic!(
-                "Cannot get env.var. '{}', reason: '{}'. Use `cargo build` instead of running this build script binary directly!",
-                ENV_NAME_OF_OUT_DIR, err
-            )
-        });
-        PathBuf::from(out_dir)
-    });
+    let pb_ref: &PathBuf = LOCK.get_or_init(|| PathBuf::from(internal_get_out_dir().as_ref()));
     pb_ref
     //^ &PathBuf implements AsRef<Path>
 }
@@ -586,11 +604,28 @@ fn try_link(
     };
 }
 
+#[inline]
+fn internal_watch_var(env_var: &'static str) {
+    println!("cargo:rerun-if-env-changed={}", env_var);
+}
+/// attempts to lower MSRV by not using OnceLock
+#[cfg(all(
+    feature = "not_OnceLock",
+    not(feature = "dummy_feature_to_detect_that_--all-features_arg_was_used")
+))]
+fn watch_env_var(env_var: &'static str) {
+    internal_watch_var(env_var);
+}
+
 //TODO: maybe change this to apply to anything that's emitted for cargo to consume, except warnings,
 //and make it HashMap with a counter.
 /// Emits "cargo:rerun-if-env-changed=ENV_VAR" on stdout
-/// only once for each ENV_VAR
-/// regardless of how many times it gets called.
+/// only once for each ENV_VAR regardless of how many times it gets called.
+/// uses OnceLock internally.
+#[cfg(any(
+    not(feature = "not_OnceLock"),
+    feature = "dummy_feature_to_detect_that_--all-features_arg_was_used"
+))]
 fn watch_env_var(env_var: &'static str) {
     assert!(!env_var.is_empty(), "Passed empty env.var. to watch for.");
     use std::collections::HashSet;
@@ -604,7 +639,7 @@ fn watch_env_var(env_var: &'static str) {
     if let Ok(mut guard) = hs.write() {
         // Critical section where the lock is held
         if !guard.contains(env_var) {
-            println!("cargo:rerun-if-env-changed={}", env_var);
+            internal_watch_var(env_var);
             guard.insert(env_var);
         }
     } //lock released here

From 3b9c481be097812b44ef67c0f23a47af82fca257 Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Mon, 22 Apr 2024 06:55:44 +0200
Subject: [PATCH 44/54] small comments&text corrections in build.rs

---
 build.rs | 33 ++++++++++++++++++++-------------
 1 file changed, 20 insertions(+), 13 deletions(-)

diff --git a/build.rs b/build.rs
index f3d8f349..3b8f8616 100644
--- a/build.rs
+++ b/build.rs
@@ -120,7 +120,9 @@ const TINFO_LIB_NAMES: &[&str] = if IS_WIDE_AND_NOT_ON_MACOS {
 //even though the next one in list might be v6
 //This is the commit that added this v5 then v6 way: https://github.com/jeaye/ncurses-rs/commit/daddcbb557169cfac03af9667ef7aefed19f9409
 
-/// finds and emits cargo:rustc-link-lib=
+/// Uses pkg-config to find the lib and then emits cargo:rustc-link-lib= for it
+/// eg. `pkg-config ncurses --libs`
+/// link searchdirs and header include dirs, if any, are also in the result.
 fn find_library(names: &[&str]) -> Option<Library> {
     for name in names {
         //cargo_warn!("Trying lib '{}'",name);
@@ -163,6 +165,7 @@ fn cargo_warn_unformatted(warn_msg: String) {
 fn main() {
     watch_env_var("PKG_CONFIG_PATH");
 
+    //This is what pkg-config finds, if any, including link searchdirs and include dirs for it!
     let ncurses_lib = find_library(NCURSES_LIB_NAMES);
     // Gets the name of ncurses lib found by pkg-config, if it found any!
     // else (warns and)returns the default one like 'ncurses' or 'ncursesw'
@@ -193,8 +196,8 @@ fn main() {
         // Every other distro already has at least LANG set, but is otherwise affected the same if
         // for example LANG is unset or LANG=C is used, when running the binary with wide feature.
 
-        //TODO: need a better way to detect if it's UTF-8 capable and correctly set. Maybe some
-        //locale crate.
+        //TODO: maybe need a better way to detect if it's UTF-8 capable and correctly set.
+        //Perhaps some locale crate.
 
         //This is the order of precedence, if any/all are set, the one leftmost in this list overrides
         //the others that come after it;
@@ -240,7 +243,7 @@ fn main() {
                 break;
             }
         }
-        let extra=" Note that, at least on OpenBSD 7.5, you must set the 'UTF-8' part to be all uppercase as it seems to be case sensitive so uTf-8, Utf-8, utf-8 or even UTF8 without dash, won't work but the 'en_US' part can be any case, apparently. On Gentoo however, even utf8 without a dash works(as also with a dash like uTf-8) and it's case insensitive, however the en_US part is case sensitive! Check your distro for the correct form maybe.";
+        let extra=" Note that, at least on OpenBSD 7.5, you must set the 'UTF-8' part to be all uppercase as it seems to be case sensitive so uTf-8, Utf-8, utf-8 or even UTF8 without dash, won't work but the 'en_US' part can be any text or even empty, apparently. On Gentoo however, even utf8 without a dash works(as also with a dash like uTf-8) and it's case insensitive, however the en_US part is case sensitive! Check your distro for the correct form maybe.";
         if let Some((is_utf8, var_name, var_value)) = first_one_set {
             if !is_utf8 {
                 cargo_warn!("You've enabled the 'wide' feature but you've set environment variable '{}={}', which isn't UTF-8, apparently, so wide characters will look garbled when you run your resulting ncurses-using binary unless you set one of these environment vars {:?} to, for example, \"en_US.UTF-8\". This affects the binary at runtime not at compile time.{}",var_name,var_value, &env_vars, extra);
@@ -274,8 +277,8 @@ fn main() {
 
     //This comment block is about libtinfo.
     //If pkg-config can't find it, use fallback: 'tinfo' or 'tinfow'
-    //if cargo can't find it it will ignore it gracefully - NO IT WON'T!
-    //if it can find it, it will link it.
+    //If we tell cargo about it via cargo:rustc-link-lib=tinfo,
+    //and it can find it, it will link it, else it will err.
     //It's needed for ex_5 to can link  when pkg-config is missing,
     //otherwise you get this: undefined reference to symbol 'noraw'
     //Thus w/o this block, the following command would be needed to run ex_5
@@ -285,13 +288,13 @@ fn main() {
     // $ NCURSES_NO_PKG_CONFIG=1 NCURSESW_NO_PKG_CONFIG=1 NCURSES5_NO_PKG_CONFIG=1 NCURSESW5_NO_PKG_CONFIG=1 the_rest_of_the_command_here
     // Fedora and Gentoo are two that have both ncurses(w) and tinfo(w), ie. split,
     // however Gentoo has ncurses+tinfo and ncursesw+tinfow,
-    // but Fedora has ncurses+tinfo and ncursesw+tinfo (see 'tinfo' is same! no w)
+    // but Fedora&Ubuntu has ncurses+tinfo and ncursesw+tinfo (see 'tinfo' is same! no w)
     // NixOS has only ncursesw (tinfo is presumably inside?) but -lncurses -lncursesw -ltinfo work!
-    // but -ltinfow doesn't work! on NixOS and Fedora!
-    // On Gentoo -ltinfow works too!
-    // so when pkg-config is missing, how do we know which tinfo to tell cargo to link, if any!
-    // doneFIXME: ^ I guess we gonna have to compile own .c to link with tinfo to see if it fails or
-    // works!
+    // but -ltinfow fails on NixOS and Fedora!
+    // On Gentoo -ltinfow works too(ie. in addition to the other 3 variants)!
+    // So when pkg-config is missing, how do we know which tinfo to tell cargo to link, if any!
+    // we use try_link() which tries to link a dummy .c file with each tinfo variant and pick
+    // the first that links without errors.
     let tinfo_name = if let Some(found) = find_library(TINFO_LIB_NAMES) {
         let libs = found.libs;
         assert_eq!(
@@ -309,7 +312,11 @@ fn main() {
             })
             .clone()
     } else {
-        //None found; but at least on NixOS it works without any tinfo(it's inside ncursesw lib and tinfo/ncurses all symlink to that same ncursesw.so, except tinfow which doesn't exist but pkg-config points it to -lncursesw), so no need to warn that we didn't find any tinfo.
+        //None found; but at least on NixOS it works without any tinfo(it's inside ncursesw lib
+        //and tinfo/ncurses all symlink to that same libncursesw.so, except tinfow,
+        //which doesn't exist but pkg-config points it to -lncursesw),
+        //so no need to warn that we didn't find any tinfo.
+        //
         //Pick the tinfo lib to link with, as fallback,
         //the first one that links successfully!
         //The order in the list matters!

From 05bd45625853f7a540fdf60477eb31d4872510b6 Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Mon, 22 Apr 2024 13:38:10 +0200
Subject: [PATCH 45/54] restructure args/envs getting of cmd in build.rs

The getting or args and env.vars of the current command being executed,
for informational purposes, made more idiomatic.
---
 build.rs | 226 ++++++++++++++++++++++++++++++++++++-------------------
 1 file changed, 150 insertions(+), 76 deletions(-)

diff --git a/build.rs b/build.rs
index 3b8f8616..dfb7409d 100644
--- a/build.rs
+++ b/build.rs
@@ -17,9 +17,10 @@ use pkg_config::Library;
 use std::env;
 use std::ffi::OsStr;
 use std::ffi::OsString;
-use std::fmt::Write as required_for_writeln_macro;
+use std::fmt;
 use std::fs::File;
 use std::io::Write as required_for_write_all_function; //in File
+use std::iter::FromIterator;
 use std::os::unix::ffi::OsStrExt;
 use std::os::unix::ffi::OsStringExt;
 use std::path::Path;
@@ -961,7 +962,7 @@ trait MyCompilerCommand {
         -> ExitStatus;
     fn show_what_will_run(&mut self) -> &mut Self;
     fn get_program_or_panic(&self) -> &str;
-    fn get_what_will_run(&self) -> (String, usize, String, Option<&Path>, String);
+    fn get_what_will_run(&self) -> (String, MyArgs, Option<&Path>, MyEnvVars);
     fn assert_no_nul_in_args(&mut self) -> &mut Self;
     /// Panics if arg has \0 in it.
     fn args_checked<I, S>(&mut self, args: I) -> &mut Command
@@ -1135,65 +1136,23 @@ impl MyCompilerCommand for std::process::Command {
         p_prog
     }
 
-    fn get_what_will_run(&self) -> (String, usize, String, Option<&Path>, String) {
-        let p_prog = self.get_program_or_panic();
-        let args = self.get_args();
-        let how_many_args: usize = args.len();
-        let formatted_args: String = args
-            .map(|arg| {
-                //If the arg had NUL ie. \0  in it then arg got replaced already
-                //with "<string-with-nul>", internally, by std::process::Command::arg()
-                //if it was added via Command::arg() or Command::args().
-                //To prevent that use Command::arg_checked() and ::args_checked()
-                if let Some(fully_utf8_arg) = arg.to_str() {
-                    fully_utf8_arg.to_string()
-                } else {
-                    //None aka not fully utf8 arg
-                    //then we show it as ascii + hex
-                    let mut broken_arg = String::new();
-                    //use std::fmt::Write; // can't globally import this ^, conflicts with std::io::Write
-                    for byte in arg.as_bytes() {
-                        match std::char::from_u32(*byte as u32) {
-                            Some(c) if c.is_ascii() => broken_arg.push(c),
-                            _ => {
-                                write!(&mut broken_arg, "\\x{:02X}", byte).expect("Failed to write")
-                            }
-                        }
-                    }
-                    broken_arg
-                }
-            })
-            .collect::<Vec<String>>()
-            .join("\" \"");
-        //TODO: maybe a better way to get the args as a Vec<String> and impl Display ? but not
-        //for the generic Vec<String> i think. Then, we won't have to return how_many_args!
+    fn get_what_will_run(&self) -> (String, MyArgs, Option<&Path>, MyEnvVars) {
+        let prog = self.get_program_or_panic().to_string();
+
+        //If an arg had NUL ie. \0  in it then arg got replaced already
+        //with "<string-with-nul>", internally, by std::process::Command::arg()
+        //if it was added via Command::arg() or Command::args().
+        //To prevent that use Command::arg_checked() and ::args_checked()
+        let args: MyArgs = self.get_args().collect();
+        //let args: MyArgs = self.get_args().collect::<Vec<&OsStr>>().to_my_args();
 
         let cur_dir = self.get_current_dir();
-        let env_vars: Vec<(&OsStr, Option<&OsStr>)> = self.get_envs().collect();
-        let mut formatted_env_vars = String::new(); //empty string if no env vars set
-        if !formatted_env_vars.is_empty() {
-            for (key, value) in env_vars {
-                match value {
-                    Some(value) => formatted_env_vars.push_str(&format!(
-                        "(set) {}={}\n",
-                        key.to_string_lossy(),
-                        value.to_string_lossy()
-                    )),
-                    None => {
-                        formatted_env_vars.push_str(&format!("(del) {}\n", key.to_string_lossy()))
-                    } // Key was removed
-                }
-            }
-        };
+        let env_vars: MyEnvVars = self.get_envs().collect();
+
         //FIXME: make this a struct so the order doesn't get confused in callers.
+
         //return this tuple
-        (
-            p_prog.to_string(),
-            how_many_args,
-            format!("\"{}\"", formatted_args),
-            cur_dir,
-            formatted_env_vars,
-        )
+        (prog, args, cur_dir, env_vars)
     }
 
     /// just like Command::status() but panics if it can't execute it,
@@ -1233,22 +1192,21 @@ impl MyCompilerCommand for std::process::Command {
     /// (not meant to be used outside)
     //panic(  <- for search
     fn panic<T: std::fmt::Display>(&mut self, err: T, what_type_of_command: &str) -> ! {
-        let (p_prog, how_many_args, formatted_args, cur_dir, formatted_env_vars) =
-            self.get_what_will_run();
+        let (p_prog, args, cur_dir, env_vars) = self.get_what_will_run();
+        let how_many_args = args.len();
         let extra_space = if what_type_of_command.is_empty() {
             ""
         } else {
             " "
         };
-        let (cur_dir_for_print, env_vars_for_print) =
-            get_cd_and_env_for_print(cur_dir, formatted_env_vars);
+        let (cur_dir_for_print, env_vars_for_print) = get_cd_and_env_for_print(cur_dir, env_vars);
         panic!(
             "Failed to run {}{}command '{}' with '{}' args: '{}'{}{}, reason: '{}'",
             what_type_of_command,
             extra_space,
             p_prog,
             how_many_args,
-            formatted_args,
+            args,
             cur_dir_for_print,
             env_vars_for_print,
             err
@@ -1257,13 +1215,12 @@ impl MyCompilerCommand for std::process::Command {
 
     /// shows on stderr, which command will be executed.
     fn show_what_will_run(&mut self) -> &mut Self {
-        let (exe_name, how_many_args, formatted_args, cur_dir, formatted_env_vars) =
-            self.get_what_will_run();
-        let (cur_dir_for_print, env_vars_for_print) =
-            get_cd_and_env_for_print(cur_dir, formatted_env_vars);
+        let (exe_name, args, cur_dir, env_vars) = self.get_what_will_run();
+        let how_many_args = args.len();
+        let (cur_dir_for_print, env_vars_for_print) = get_cd_and_env_for_print(cur_dir, env_vars);
         eprintln!(
             "!! Next, attempting to run command '{}' with '{}' args: '{}'{}{}.",
-            exe_name, how_many_args, formatted_args, cur_dir_for_print, env_vars_for_print
+            exe_name, how_many_args, args, cur_dir_for_print, env_vars_for_print
         );
         self
     }
@@ -1289,10 +1246,126 @@ impl MyCompilerCommand for std::process::Command {
     }
 }
 
-fn get_cd_and_env_for_print(
-    cur_dir: Option<&Path>,
-    formatted_env_vars: String,
-) -> (String, String) {
+//"We can't directly implement Display for Vec<&OsStr> because Vec and OsStr are not types defined in our crate."
+// Define a custom type to represent a vector of OsStr references
+struct MyArgs<'a>(Vec<&'a OsStr>);
+
+fn humanly_visible_os_chars(f: &mut fmt::Formatter<'_>, arg: &OsStr) -> fmt::Result {
+    if let Some(arg_str) = arg.to_str() {
+        // If the argument is valid UTF-8, simply display it
+        write!(f, "\"{}\"", arg_str)?;
+    } else {
+        //None aka not fully utf8 arg
+        //then we show it as ascii + hex
+        write!(f, "\"")?;
+        for byte in arg.as_bytes() {
+            match std::char::from_u32(*byte as u32) {
+                Some(c) if c.is_ascii() => write!(f, "{}", c)?,
+                _ => {
+                    write!(f, "\\x{:02X}", byte)?;
+                }
+            }
+        }
+        write!(f, "\"")?;
+    }
+    Ok(())
+}
+
+// Implement the Display trait for MyArgs
+impl<'a> fmt::Display for MyArgs<'a> {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        let cached_last_index = self.len() - 1;
+        for (index, arg) in self.iter().enumerate() {
+            humanly_visible_os_chars(f, arg)?;
+            // Add a space between arguments, except for the last one
+            if index < cached_last_index {
+                write!(f, " ")?;
+            }
+        }
+        Ok(())
+    }
+}
+
+//// Implement a method to convert Vec<&OsStr> to MyArgs
+//trait ToMyArgs<'a> {
+//    fn to_my_args(self) -> MyArgs<'a>;
+//}
+//
+//impl<'a> ToMyArgs<'a> for Vec<&'a OsStr> {
+//    fn to_my_args(self) -> MyArgs<'a> {
+//        MyArgs(self)
+//    }
+//}
+/// but this is better:
+impl<'a> FromIterator<&'a OsStr> for MyArgs<'a> {
+    fn from_iter<I: IntoIterator<Item = &'a OsStr>>(iter: I) -> Self {
+        MyArgs(iter.into_iter().collect())
+    }
+}
+
+impl<'a> MyArgs<'a> {
+    //    // Implement a method to get the length of the arguments
+    //    pub fn len(&self) -> usize {
+    //        self.0.len()
+    //        //self.len()//won't use deref, but will infinitely recurse (untested)
+    //        //(&*self).len() // same as self.0.len() (untested)
+    //    }
+    pub fn display(&self) -> String {
+        format!("{}", self)
+    }
+}
+
+//so we don't have to use self.0
+impl<'a> std::ops::Deref for MyArgs<'a> {
+    type Target = Vec<&'a OsStr>;
+
+    fn deref(&self) -> &Self::Target {
+        &self.0
+    }
+}
+
+struct MyEnvVars<'a>(Vec<(&'a OsStr, Option<&'a OsStr>)>);
+
+impl<'a> std::ops::Deref for MyEnvVars<'a> {
+    type Target = Vec<(&'a OsStr, Option<&'a OsStr>)>;
+
+    fn deref(&self) -> &Self::Target {
+        &self.0
+    }
+}
+
+impl<'a> FromIterator<(&'a OsStr, Option<&'a OsStr>)> for MyEnvVars<'a> {
+    fn from_iter<I: IntoIterator<Item = (&'a OsStr, Option<&'a OsStr>)>>(iter: I) -> Self {
+        MyEnvVars(iter.into_iter().collect())
+    }
+}
+
+impl<'a> fmt::Display for MyEnvVars<'a> {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        for (key, value) in self.iter() {
+            match value {
+                Some(value) => {
+                    write!(f, "(set) ")?;
+                    humanly_visible_os_chars(f, key)?;
+                    write!(f, "=")?;
+                    humanly_visible_os_chars(f, value)?;
+                    write!(f, "\n")?;
+                }
+                None => {
+                    // This is how an env. var. is said to be removed, apparently.
+                    // ie. if parent had it, it's not inherited? somehow. (untested)
+                    write!(f, "(del) ")?;
+                    humanly_visible_os_chars(f, key)?;
+                    write!(f, "\n")?
+                }
+            }
+        }
+        Ok(())
+    }
+}
+
+///
+fn get_cd_and_env_for_print(cur_dir: Option<&Path>, env_vars: MyEnvVars) -> (String, String) {
     let cur_dir_for_print: String = if let Some(dir) = cur_dir {
         format!(", in current dir: {:?}", dir)
     } else {
@@ -1301,11 +1374,11 @@ fn get_cd_and_env_for_print(
             env::current_dir()
         )
     };
-    let formatted_env_vars_for_print: String = if formatted_env_vars.is_empty() {
+    let formatted_env_vars_for_print: String = if env_vars.is_empty() {
         ", with no extra env.vars added or deleted(so all are inherited from parent process)"
             .to_string()
     } else {
-        format!(", with env.vars: '{}'", formatted_env_vars)
+        format!(", with env.vars: '{}'", env_vars)
     };
     (cur_dir_for_print, formatted_env_vars_for_print)
 }
@@ -1445,6 +1518,7 @@ fn test_invalid_utf8_in_program() {
         "Executable \"test_invalid_utf8_\\xFFin_program\" isn't valid rust string",
     );
 }
+
 #[allow(dead_code)]
 fn test_match_with_placeholders() {
     let str1 = "abc";
@@ -1565,12 +1639,12 @@ fn test_get_what_will_run() {
         OsString::from("arg4"),
     ]);
     command.arg_checked(OsString::from_vec(b"my\xffarg3".to_vec()));
-    let (prog, how_many_args, formatted_args, _cur_dir, _envs) = command.get_what_will_run();
+    let (prog, args, _cur_dir, _envs) = command.get_what_will_run();
     let expected_hma = 4;
     let expected_fa = "\"arg1\" \"my\\xFFarg3\" \"arg4\" \"my\\xFFarg3\"";
     assert_eq!(prog, expected_prog);
-    assert_eq!(how_many_args, expected_hma);
-    assert_eq!(formatted_args, expected_fa);
+    assert_eq!(args.len(), expected_hma);
+    assert_eq!(args.display(), expected_fa);
 }
 
 #[allow(dead_code)]

From a68a85b18ec9223bd66876ebe886a51ee476ec14 Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Mon, 22 Apr 2024 17:18:32 +0200
Subject: [PATCH 46/54] set edition to 2015 to get rid of warning

in rustc 1.79.0 on Fedora

warning: no edition set: defaulting to the 2015 edition while the latest is 2021
---
 Cargo.toml | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/Cargo.toml b/Cargo.toml
index 35859347..74774df2 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -9,6 +9,9 @@ repository = "https://github.com/jeaye/ncurses-rs"
 readme = "README.md"
 keywords = ["ncurses","TUI"]
 license = "MIT"
+#If the edition field is not present in Cargo.toml, then the 2015 edition is assumed for backwards compatibility. 
+#Set to avoid a warning with newer rust:
+edition = "2015"
 build = "build.rs"
 #https://doc.rust-lang.org/cargo/reference/manifest.html#the-rust-version-field
 rust-version = "1.70.0" #but can be 1.57.0, see feature not_OnceLock

From ac86ba99e9392f57e86832f52ff9fc42c143253f Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Mon, 22 Apr 2024 17:33:35 +0200
Subject: [PATCH 47/54] set edition to 2021, with the relevant changes

---
 Cargo.toml           | 6 ++++--
 build.rs             | 1 -
 src/constants.rs     | 4 ++--
 src/menu/ll.rs       | 2 +-
 src/menu/wrapper.rs  | 6 +++---
 src/panel/ll.rs      | 2 +-
 src/panel/wrapper.rs | 6 +++---
 7 files changed, 14 insertions(+), 13 deletions(-)

diff --git a/Cargo.toml b/Cargo.toml
index 74774df2..44bb807a 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -9,9 +9,10 @@ repository = "https://github.com/jeaye/ncurses-rs"
 readme = "README.md"
 keywords = ["ncurses","TUI"]
 license = "MIT"
-#If the edition field is not present in Cargo.toml, then the 2015 edition is assumed for backwards compatibility. 
+#If the edition field is not present in Cargo.toml, then the 2015 edition is assumed for backwards compatibility.
 #Set to avoid a warning with newer rust:
-edition = "2015"
+#The Rust 2021 Edition was introduced in Rust 1.56.0.
+edition = "2021"
 build = "build.rs"
 #https://doc.rust-lang.org/cargo/reference/manifest.html#the-rust-version-field
 rust-version = "1.70.0" #but can be 1.57.0, see feature not_OnceLock
@@ -26,6 +27,7 @@ rust-version = "1.70.0" #but can be 1.57.0, see feature not_OnceLock
 #Due to build.rs' use of std::process::Command::get_*() MSRV is 1.57.0
 #To minimize MSRV further you can set `cc = "=1.0.92"` (not the extra "=") below then run `cargo update`
 # that makes MSRV be 1.53.0 minimum, but other things will raise it at 1.57.0
+#MSRV is 1.56.0 due to the above edition="2021"
 
 [build-dependencies]
 cc = "1.0.92"
diff --git a/build.rs b/build.rs
index dfb7409d..65090662 100644
--- a/build.rs
+++ b/build.rs
@@ -20,7 +20,6 @@ use std::ffi::OsString;
 use std::fmt;
 use std::fs::File;
 use std::io::Write as required_for_write_all_function; //in File
-use std::iter::FromIterator;
 use std::os::unix::ffi::OsStrExt;
 use std::os::unix::ffi::OsStringExt;
 use std::path::Path;
diff --git a/src/constants.rs b/src/constants.rs
index 4ffb313c..7d37b234 100644
--- a/src/constants.rs
+++ b/src/constants.rs
@@ -17,8 +17,8 @@ use super::ll::*;
 
 mod wrapped {
     use libc::{ c_char, c_int };
-    use ll::chtype;
-    use ll::WINDOW;
+    use crate::ll::chtype;
+    use crate::ll::WINDOW;
 
     extern "C"
     {
diff --git a/src/menu/ll.rs b/src/menu/ll.rs
index 1541ab80..c722184c 100644
--- a/src/menu/ll.rs
+++ b/src/menu/ll.rs
@@ -2,7 +2,7 @@
 #![allow(unused_imports)]
 
 use libc::{c_int, c_char, c_void};
-use ll::{WINDOW, chtype, c_bool};
+use crate::ll::{WINDOW, chtype, c_bool};
 
 pub type MENU = *mut i8;
 pub type ITEM = *mut i8;
diff --git a/src/menu/wrapper.rs b/src/menu/wrapper.rs
index 54016c6b..00a334ef 100644
--- a/src/menu/wrapper.rs
+++ b/src/menu/wrapper.rs
@@ -7,9 +7,9 @@ use std::ptr;
 use std::slice;
 use std::ffi::{CStr, CString};
 use libc::*;
-use menu::ll;
-use ll::{WINDOW, chtype, c_bool};
-use constants::TRUE;
+use crate::menu::ll;
+use crate::ll::{WINDOW, chtype, c_bool};
+use crate::constants::TRUE;
 use std::os::raw::c_char;
 
 pub type MENU = ll::MENU;
diff --git a/src/panel/ll.rs b/src/panel/ll.rs
index 30f312ef..348867eb 100644
--- a/src/panel/ll.rs
+++ b/src/panel/ll.rs
@@ -2,7 +2,7 @@
 #![allow(unused_imports)]
 
 use libc::{ c_int, c_void };
-use ll::WINDOW;
+use crate::ll::WINDOW;
 
 pub type PANEL = *mut i8;
 
diff --git a/src/panel/wrapper.rs b/src/panel/wrapper.rs
index 8781220d..3de709cb 100644
--- a/src/panel/wrapper.rs
+++ b/src/panel/wrapper.rs
@@ -1,9 +1,9 @@
 #![allow(dead_code)]
 #![allow(unused_imports)]
 
-use panel::ll;
-use ll::WINDOW;
-use constants::TRUE;
+use crate::panel::ll;
+use crate::ll::WINDOW;
+use crate::constants::TRUE;
 
 pub type PANEL = ll::PANEL;
 

From bd1f1bc4b6635a7180f9a56c73409b3b6a9053c7 Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Mon, 22 Apr 2024 18:09:29 +0200
Subject: [PATCH 48/54] fix `cargo clippy` warnings on build.rs

not a fan but it's more "rusty"
---
 build.rs | 50 ++++++++++++++++++--------------------------------
 1 file changed, 18 insertions(+), 32 deletions(-)

diff --git a/build.rs b/build.rs
index 65090662..aaa5c161 100644
--- a/build.rs
+++ b/build.rs
@@ -229,12 +229,8 @@ fn main() {
             if let Ok(value) = env::var(var) {
                 //we make sure to warn on openbsd if we don't find UTF-8 exactly!
                 //on others, we just case insensitively check if it ends with utf-8/utf8
-                const CASENESS: bool = if cfg!(target_os = "openbsd") {
-                    true
-                } else {
-                    false
-                };
-                if ends_in_utf8(&value, CASENESS) {
+                const CASE_SENSITIVE: bool = cfg!(target_os = "openbsd");
+                if ends_in_utf8(&value, CASE_SENSITIVE) {
                     first_one_set = Some((true, var, value));
                 } else {
                     first_one_set = Some((false, var, value));
@@ -335,7 +331,7 @@ fn main() {
                 } else { false };
                 ret
             })
-            .unwrap_or_else(|| &"") // found no tinfo that links without errors which may be ok(eg. on Nixos)
+            .unwrap_or(&"") // found no tinfo that links without errors which may be ok(eg. on Nixos)
             .to_string()
     };
     if IS_WIDE_AND_NOT_ON_MACOS
@@ -403,7 +399,7 @@ fn find_sublib(
         //which also means we must know if we have to use ncurses lib override before even trying
         //to link menu,panel,tinfo, and thus need to pass the ncurses lib name to try_link() as third arg.
         if let Some(needed_ncurses) =
-            try_link(sublib_fallback_name, &ncurses_lib, &ncurses_lib_name_to_use)
+            try_link(sublib_fallback_name, ncurses_lib, ncurses_lib_name_to_use)
         {
             let extra: String = if needed_ncurses {
                 format!(", but needed '{}' to link  without undefined symbols(known to be true on OpenBSD)", ncurses_lib_name_to_use)
@@ -457,13 +453,12 @@ fn overwrite_file_contents<P: AsRef<Path>>(file_name: P, contents: &[u8]) {
 const ENV_NAME_OF_OUT_DIR: &str = "OUT_DIR";
 #[inline]
 fn internal_get_out_dir() -> impl AsRef<Path> {
-    let out_dir=env::var(ENV_NAME_OF_OUT_DIR).unwrap_or_else(|err| {
+    env::var(ENV_NAME_OF_OUT_DIR).unwrap_or_else(|err| {
         panic!(
             "Cannot get env.var. '{}', reason: '{}'. Use `cargo build` instead of running this build script binary directly!",
             ENV_NAME_OF_OUT_DIR, err
             )
-    });
-    out_dir
+    })
 }
 
 /// attempts to lower MSRV by not using OnceLock
@@ -562,7 +557,7 @@ fn try_link(
     //Include paths(for headers) don't matter! ie. -I
     //Presumably the other libs(menu,panel,tinfo) are in the same dir(s) as the ncurses lib,
     //because they're part of ncurses even though they're split on some distros/OSs.
-    let linker_searchdir_args: Vec<String> = get_linker_searchdirs(&ncurses_lib);
+    let linker_searchdir_args: Vec<String> = get_linker_searchdirs(ncurses_lib);
     if !linker_searchdir_args.is_empty() {
         command.args_checked(linker_searchdir_args);
     }
@@ -604,11 +599,11 @@ fn try_link(
         });
     }
 
-    return if ret {
+    if ret {
         Some(requires_ncurses_lib)
     } else {
         None
-    };
+    }
 }
 
 #[inline]
@@ -688,7 +683,7 @@ fn new_build(lib: &Option<Library>) -> cc::Build {
     //build.flag_if_supported("-Wstrict-prototypes");//maybe fix me: triggers warnings in wrap.c
     build.flag_if_supported("-Weverything"); //only clang
 
-    return build; // explicit return makes it more obvious that the ";" is missing so it's a return!
+    build
 }
 
 fn build_wrap(ncurses_lib: &Option<Library>) {
@@ -710,8 +705,7 @@ fn get_the_compiler_command_from_build(build: cc::Build) -> std::process::Comman
     let compiler = build
         .try_get_compiler()
         .expect("Failed Build::try_get_compiler");
-    let command = compiler.to_command();
-    return command;
+    compiler.to_command()
 }
 
 /// Compiles an existing .c file, runs its bin to generate a .rs file from its output.
@@ -745,7 +739,7 @@ fn gen_rs(
         .arg_checked(&bin_full)
         .arg_checked(source_c_file)
         .args_checked(["-l", lib_name]);
-    let linker_searchdir_args: Vec<String> = get_linker_searchdirs(&ncurses_lib);
+    let linker_searchdir_args: Vec<String> = get_linker_searchdirs(ncurses_lib);
     if !linker_searchdir_args.is_empty() {
         command.args_checked(linker_searchdir_args);
     }
@@ -766,7 +760,7 @@ fn gen_rs(
     //Write the output from executing the binary into a new rust source file .rs
     //That .rs file is later used outside of this build.rs, in the normal build
     let gen_rust_file_full_path = Path::new(out_dir.as_ref()).join(gen_rust_file);
-    overwrite_file_contents(&gen_rust_file_full_path, &output.stdout);
+    overwrite_file_contents(gen_rust_file_full_path, &output.stdout);
     //we ignore stderr.
     //we don't delete this file because it's used to compile the rest of the crate.
 }
@@ -1061,6 +1055,7 @@ impl MyCompilerCommand for std::process::Command {
             eprintln!("{}", additional_msg_when_non_zero_exit_code);
             and_panic();
         } else {
+            #[allow(clippy::needless_return)] // it's more readable
             return output;
         }
     }
@@ -1285,16 +1280,6 @@ impl<'a> fmt::Display for MyArgs<'a> {
     }
 }
 
-//// Implement a method to convert Vec<&OsStr> to MyArgs
-//trait ToMyArgs<'a> {
-//    fn to_my_args(self) -> MyArgs<'a>;
-//}
-//
-//impl<'a> ToMyArgs<'a> for Vec<&'a OsStr> {
-//    fn to_my_args(self) -> MyArgs<'a> {
-//        MyArgs(self)
-//    }
-//}
 /// but this is better:
 impl<'a> FromIterator<&'a OsStr> for MyArgs<'a> {
     fn from_iter<I: IntoIterator<Item = &'a OsStr>>(iter: I) -> Self {
@@ -1304,6 +1289,7 @@ impl<'a> FromIterator<&'a OsStr> for MyArgs<'a> {
 
 impl<'a> MyArgs<'a> {
     //    // Implement a method to get the length of the arguments
+    //    // don't need this because impl Deref!
     //    pub fn len(&self) -> usize {
     //        self.0.len()
     //        //self.len()//won't use deref, but will infinitely recurse (untested)
@@ -1348,14 +1334,14 @@ impl<'a> fmt::Display for MyEnvVars<'a> {
                     humanly_visible_os_chars(f, key)?;
                     write!(f, "=")?;
                     humanly_visible_os_chars(f, value)?;
-                    write!(f, "\n")?;
+                    writeln!(f)?;
                 }
                 None => {
                     // This is how an env. var. is said to be removed, apparently.
                     // ie. if parent had it, it's not inherited? somehow. (untested)
                     write!(f, "(del) ")?;
                     humanly_visible_os_chars(f, key)?;
-                    write!(f, "\n")?
+                    writeln!(f)?;
                 }
             }
         }
@@ -1490,7 +1476,7 @@ fn test_panic_for_not_found_command() {
 #[allow(dead_code)]
 fn test_panic_for_command_non_zero_exit() {
     let cmd = if cfg!(windows) { "cmd" } else { "sh" };
-    let args_fail = &["-c", &format!("exit 43")];
+    let args_fail = &["-c", "exit 43"];
     let result = std::panic::catch_unwind(|| {
         let mut command = Command::new(cmd);
         command.args(args_fail);

From ab9f4bd5864d7213c2011b0c39504331c59e5532 Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Tue, 23 Apr 2024 12:24:38 +0200
Subject: [PATCH 49/54] reduce MSRV to 1.57.0 by removing OnceLock

... it was used in build.rs only and it was overkill anyway!
(and Arc wasn't needed there)
---
 Cargo.toml | 20 +++++--------
 build.rs   | 84 +++++++++---------------------------------------------
 2 files changed, 20 insertions(+), 84 deletions(-)

diff --git a/Cargo.toml b/Cargo.toml
index 44bb807a..994e33b5 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -15,18 +15,17 @@ license = "MIT"
 edition = "2021"
 build = "build.rs"
 #https://doc.rust-lang.org/cargo/reference/manifest.html#the-rust-version-field
-rust-version = "1.70.0" #but can be 1.57.0, see feature not_OnceLock
+rust-version = "1.57.0"
 #Using this key rust-version= here aka MSRV, makes 1.56.0 be the minimum supported rust version(MSRV)
 #The first version of Cargo that supports this field was released with Rust 1.56.0. In older releases, the field will be ignored, and Cargo will display a warning.
 #Due to addr_of!() MSRV 1.51.0 is required minimum.
-#cc 1.0.92 requires 1.53.0 MSRV, however `cargo build` will pull latest cc due to
-# Cargo.lock missing(on first repo clone) and cc version specified isn't fixed like cc="=1.0.92", so:
-#due to latest cc pulled being 1.0.95(21Apr2024) it requires 1.63.0 MSRV (ie: `cargo msrv list`)
-#Due to build.rs OnceLock() 1.70.0 is required minimum.
-#But you can use --features=not_OnceLock to get MSRV to 1.57.0 or lower
+#cc 1.0.92 requires 1.53.0 MSRV(but its `cargo test` passes only with 1.63.0),
+# however `cargo build` will pull latest cc due to Cargo.lock missing(on first repo clone)
+# and cc version specified isn't fixed like cc="=1.0.92", so:
+# due to latest cc pulled being 1.0.95(21Apr2024) it requires 1.63.0 MSRV (ie: `cargo msrv list`)
 #Due to build.rs' use of std::process::Command::get_*() MSRV is 1.57.0
-#To minimize MSRV further you can set `cc = "=1.0.92"` (not the extra "=") below then run `cargo update`
-# that makes MSRV be 1.53.0 minimum, but other things will raise it at 1.57.0
+#To minimize MSRV further you can set `cc = "=1.0.92"` (note the extra "=") below then run `cargo update`
+# that makes MSRV be 1.53.0 minimum, but other things will raise it to 1.57.0
 #MSRV is 1.56.0 due to the above edition="2021"
 
 [build-dependencies]
@@ -48,11 +47,6 @@ wide_chtype = []
 mouse_v1 = []
 extended_colors = ["wide"]
 
-# Use this feature to reduce MSRV to 1.57.0, it only affects build.rs code anyway,
-#but you've to set cc="=1.0.92" too, and rust-version="1.57.0" above.
-# This isn't picked up with --all-features; if all is wanted, you've to specify each by hand via --features=
-not_OnceLock = []
-
 #Internal features used in 'build.rs' only:
 test_build_rs_of_ncurses_rs = [] #<- not picked up by --all-features
 dummy_feature_to_detect_that_--all-features_arg_was_used= []
diff --git a/build.rs b/build.rs
index aaa5c161..6612bbef 100644
--- a/build.rs
+++ b/build.rs
@@ -448,40 +448,20 @@ fn overwrite_file_contents<P: AsRef<Path>>(file_name: P, contents: &[u8]) {
     drop(file); //explicit file close, not needed since it's in a function now!
 }
 
-//OUT_DIR is set by cargo during `cargo build` while build.rs' bin gets executed, but not during
-//the compilation(ie. env!("OUT_DIR") isn't set!)
-const ENV_NAME_OF_OUT_DIR: &str = "OUT_DIR";
-#[inline]
-fn internal_get_out_dir() -> impl AsRef<Path> {
-    env::var(ENV_NAME_OF_OUT_DIR).unwrap_or_else(|err| {
+/// returns value of OUT_DIR env. var. as Path
+fn get_out_dir() -> impl AsRef<Path> {
+    use std::path::PathBuf;
+    //OUT_DIR is set by cargo during `cargo build` while build.rs' bin gets executed, but not during
+    //the compilation(ie. env!("OUT_DIR") isn't set!)
+    const ENV_NAME_OF_OUT_DIR: &str = "OUT_DIR";
+    let env_value:String=env::var(ENV_NAME_OF_OUT_DIR).unwrap_or_else(|err| {
         panic!(
             "Cannot get env.var. '{}', reason: '{}'. Use `cargo build` instead of running this build script binary directly!",
             ENV_NAME_OF_OUT_DIR, err
             )
-    })
-}
-
-/// attempts to lower MSRV by not using OnceLock
-#[cfg(all(
-    feature = "not_OnceLock",
-    not(feature = "dummy_feature_to_detect_that_--all-features_arg_was_used")
-))]
-fn get_out_dir() -> impl AsRef<Path> {
-    std::path::PathBuf::from(internal_get_out_dir().as_ref())
-}
-
-/// thread safe memoizing func(via OnceLock) for returning OUT_DIR env. var. value
-#[cfg(any(
-    not(feature = "not_OnceLock"),
-    feature = "dummy_feature_to_detect_that_--all-features_arg_was_used"
-))]
-fn get_out_dir() -> impl AsRef<Path> {
-    use std::path::PathBuf;
-    use std::sync::OnceLock;
-    static LOCK: OnceLock<PathBuf> = OnceLock::new();
-
-    let pb_ref: &PathBuf = LOCK.get_or_init(|| PathBuf::from(internal_get_out_dir().as_ref()));
-    pb_ref
+    });
+    assert!(!env_value.is_empty(), "OUT_DIR env. var was set to empty.");
+    PathBuf::from(env_value)
     //^ &PathBuf implements AsRef<Path>
 }
 
@@ -606,49 +586,11 @@ fn try_link(
     }
 }
 
-#[inline]
-fn internal_watch_var(env_var: &'static str) {
-    println!("cargo:rerun-if-env-changed={}", env_var);
-}
-/// attempts to lower MSRV by not using OnceLock
-#[cfg(all(
-    feature = "not_OnceLock",
-    not(feature = "dummy_feature_to_detect_that_--all-features_arg_was_used")
-))]
-fn watch_env_var(env_var: &'static str) {
-    internal_watch_var(env_var);
-}
-
-//TODO: maybe change this to apply to anything that's emitted for cargo to consume, except warnings,
-//and make it HashMap with a counter.
-/// Emits "cargo:rerun-if-env-changed=ENV_VAR" on stdout
-/// only once for each ENV_VAR regardless of how many times it gets called.
-/// uses OnceLock internally.
-#[cfg(any(
-    not(feature = "not_OnceLock"),
-    feature = "dummy_feature_to_detect_that_--all-features_arg_was_used"
-))]
+/// Emits "cargo:rerun-if-env-changed=ENV_VAR" on stdout on every call, cargo doesn't mind.
+// cargo doesn't mind repetitions, see this: cargo clean;cargo build -vv |& grep rerun-if-env-changed
 fn watch_env_var(env_var: &'static str) {
     assert!(!env_var.is_empty(), "Passed empty env.var. to watch for.");
-    use std::collections::HashSet;
-    use std::sync::OnceLock;
-    use std::sync::{Arc, RwLock};
-    // static gets inited only once before main() and is scoped only to this function
-    static SHARED_DATA: OnceLock<Arc<RwLock<HashSet<&'static str>>>> = OnceLock::new();
-    //the inner value (hashset) is inited only once on first call of this function
-    let hs = SHARED_DATA.get_or_init(|| Arc::new(RwLock::new(HashSet::new())));
-    // Acquire a write lock to atomically check and insert if necessary
-    if let Ok(mut guard) = hs.write() {
-        // Critical section where the lock is held
-        if !guard.contains(env_var) {
-            internal_watch_var(env_var);
-            guard.insert(env_var);
-        }
-    } //lock released here
-
-    //TODO: can use HashMap(since HashSet I hear is just a HashMap underneath) and keep a counter as val
-    //this way we'd know how many times an env.var. tried to be emitted, but for what reason we'd
-    //wanna know though...
+    println!("cargo:rerun-if-env-changed={}", env_var);
 }
 
 /// set some sensible defaults

From 998358ec540a892807ffe69a25b766da088476a4 Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Tue, 23 Apr 2024 12:59:04 +0200
Subject: [PATCH 50/54] fix some clippy pedantic warnings in build.rs

---
 build.rs | 88 +++++++++++++++++++++++++++++---------------------------
 1 file changed, 45 insertions(+), 43 deletions(-)

diff --git a/build.rs b/build.rs
index 6612bbef..be281883 100644
--- a/build.rs
+++ b/build.rs
@@ -40,7 +40,7 @@ const ENV_VAR_NAME_FOR_NCURSES_RS_RUSTC_FLAGS: &str = "NCURSES_RS_RUSTC_FLAGS";
 
 /// Assuming we want env.var "NCURSES_RS_CFLAGS" here,
 /// and target==host and is "x86_64-unknown-linux-gnu"
-/// then calls to Build::try_flags_from_environment() below in code,
+/// then calls to `Build::try_flags_from_environment()` below in code,
 /// will try the following env.vars in this order:
 /// 1. "NCURSES_RS_CFLAGS_x86_64-unknown-linux-gnu" (notice dashes)
 /// 2. "NCURSES_RS_CFLAGS_x86_64_unknown_linux_gnu" (notice underscores)
@@ -141,7 +141,7 @@ fn find_library(names: &[&str]) -> Option<Library> {
 /// otherwise the text after would not have been seen in the warning.
 macro_rules! cargo_warn {
     ($($arg:tt)*) => {
-        cargo_warn_unformatted(format!("{}", format_args!($($arg)*)));
+        cargo_warn_unformatted(&format!("{}", format_args!($($arg)*)));
     };
 }
 
@@ -149,7 +149,7 @@ macro_rules! cargo_warn {
 /// Presumably you've already used format!() on it.
 /// Will replace newlines in the warning message with spaces,
 /// otherwise the text after would not have been seen in the warning.
-fn cargo_warn_unformatted(warn_msg: String) {
+fn cargo_warn_unformatted(warn_msg: &str) {
     // Replace '\r' with nothing
     // Replace '\n' with space
     let warn_msg = warn_msg.replace('\r', "").replace('\n', " ");
@@ -213,10 +213,10 @@ fn main() {
         /// Function to check if a string ends with the substring "UTF-8"
         /// case sensitive(true) or insensitive(false) is selected by bool arg.
         fn ends_in_utf8(value: &str, case_sensitive: bool) -> bool {
-            let ci: String = if !case_sensitive {
-                value.to_uppercase()
-            } else {
+            let ci: String = if case_sensitive {
                 value.to_string()
+            } else {
+                value.to_uppercase()
             };
             //Gentoo can take both utf8 and utf-8, case insesitive
             //but the en_US part is case sensitive!
@@ -316,14 +316,14 @@ fn main() {
         //Pick the tinfo lib to link with, as fallback,
         //the first one that links successfully!
         //The order in the list matters!
-        TINFO_LIB_NAMES
+        (*TINFO_LIB_NAMES
             .iter()
             .find(|&each| {
                 let ret: bool = if let Some(needed_ncurses)=try_link(each, &ncurses_lib, &lib_name) {
                     let extra:String=if needed_ncurses {
                         format!(", but needed '{}' to link without undefined symbols", lib_name)
                     } else {
-                        "".to_string()
+                        String::new()
                     };
                     cargo_warn!("Using lib fallback '{}' which links successfully{}. The need for fallback suggests that you might be missing `pkg-config`/`pkgconf`.", each, extra);
                     println!("cargo:rustc-link-lib={}", each);
@@ -331,7 +331,7 @@ fn main() {
                 } else { false };
                 ret
             })
-            .unwrap_or(&"") // found no tinfo that links without errors which may be ok(eg. on Nixos)
+            .unwrap_or(&"")) // found no tinfo that links without errors which may be ok(eg. on Nixos)
             .to_string()
     };
     if IS_WIDE_AND_NOT_ON_MACOS
@@ -404,7 +404,7 @@ fn find_sublib(
             let extra: String = if needed_ncurses {
                 format!(", but needed '{}' to link  without undefined symbols(known to be true on OpenBSD)", ncurses_lib_name_to_use)
             } else {
-                "".to_string()
+                String::new()
             };
             cargo_warn!("Using lib fallback '{}' which links successfully{}. The need for fallback suggests that you might be missing `pkg-config`/`pkgconf` or if they're not missing then you might not have a file named '{}.pc'.", sublib_fallback_name, extra, sublib_fallback_name);
         } else {
@@ -422,7 +422,7 @@ fn find_sublib(
 //cargo won't run doc tests inside build.rs
 /// Creates file with the specified contents.
 /// Any existing file with that name is lost.
-/// Panics if file_name isn't prefixed by the value of OUT_DIR (at runtime) for extra safety.
+/// Panics if `file_name` isn't prefixed by the value of OUT_DIR (at runtime) for extra safety.
 fn overwrite_file_contents<P: AsRef<Path>>(file_name: P, contents: &[u8]) {
     //Note: asserts in build.rs appear to be enabled even for cargo build --release, and can't be disabled(which is good, we want them on, always)
     let file_name = file_name.as_ref();
@@ -514,7 +514,7 @@ fn try_link(
 
     let build = cc::Build::new();
 
-    let mut command = get_the_compiler_command_from_build(build);
+    let mut command = get_the_compiler_command_from_build(&build);
 
     let out_bin_full = Path::new(out_dir.as_ref()).join(out_bin_fname);
     //Create a bin(not a lib) from a .c file
@@ -638,7 +638,7 @@ fn build_wrap(ncurses_lib: &Option<Library>) {
     //the resulting lib will be kept until deleted by 'cargo clean'
 }
 
-fn get_the_compiler_command_from_build(build: cc::Build) -> std::process::Command {
+fn get_the_compiler_command_from_build(build: &cc::Build) -> std::process::Command {
     //'cc::Build' can do only lib outputs but we want a binary
     //so we get the command (and args) thus far set and add our own args.
     //Presumably all args will be kept, as per: https://docs.rs/cc/1.0.92/cc/struct.Build.html#method.get_compiler
@@ -672,7 +672,7 @@ fn gen_rs(
 
     let build = new_build(ncurses_lib);
 
-    let mut command = get_the_compiler_command_from_build(build);
+    let mut command = get_the_compiler_command_from_build(&build);
 
     //create a bin(not a lib) from a .c file
     //adding the relevant args for the libs that we depend upon such as ncurses
@@ -751,7 +751,7 @@ int main(void)
 
     let build = new_build(ncurses_lib);
 
-    let mut command = get_the_compiler_command_from_build(build);
+    let mut command = get_the_compiler_command_from_build(&build);
 
     command
         .arg("-o")
@@ -905,8 +905,8 @@ trait MyCompilerCommand {
         I: IntoIterator<Item = S>,
         S: AsRef<OsStr>;
     /// Panics if arg has \0 aka NUL in it,
-    /// otherwise the original Command::arg would've set it to "<string-with-nul>"
-    /// Doesn't do any other checks, passes it to Command::arg()
+    /// otherwise the original `Command::arg()` would've set it to "<string-with-nul>"
+    /// Doesn't do any other checks, passes it to `Command::arg()`
     fn arg_checked<S: AsRef<OsStr>>(&mut self, arg: S) -> &mut Command;
     fn panic<T: std::fmt::Display>(&mut self, err: T, what_type_of_command: &str) -> !;
     fn make_a_partial_copy(&self) -> Self;
@@ -922,13 +922,13 @@ fn has_null_byte<S: AsRef<OsStr>>(arg: S) -> bool {
     false
 }
 
-/// Args with \0 in them, passed to std::process::Command::arg() or ::args()
+/// Args with \0 in them, passed to `std::process::Command::arg()` or `std::process::Command::args()`
 /// get replaced(by those calls)entirely with this: "<string-with-nul>"
 const REPLACEMENT_FOR_ARG_THAT_HAS_NUL: &str = "<string-with-nul>";
 // Implement the extension trait for Command, so you can use methods on a Command instance even
 // though it's a type that's not defined here but in std::process
 impl MyCompilerCommand for std::process::Command {
-    /// Executes Command::output() and gives you Output struct or panics
+    /// Executes `Command::output()` and gives you Output struct or panics
     /// but the exit code may not have been 0
     fn output_or_panic(&mut self, what_kind_of_process_is_it: &str) -> std::process::Output {
         self.output().unwrap_or_else(|err| {
@@ -936,7 +936,7 @@ impl MyCompilerCommand for std::process::Command {
         })
     }
 
-    /// Executes Command::output() and gives you Output struct or panics
+    /// Executes `Command::output()` and gives you Output struct or panics
     /// also panics if exit code was not 0 and shows you stdout/stderr if so.
     /// The extra args are to be displayed in cases of errors.
     fn output_success_or_panic(
@@ -988,21 +988,20 @@ impl MyCompilerCommand for std::process::Command {
             show_stdout_stderr();
             and_panic();
         });
-        if 0 != exit_code {
-            eprintln!(
-                "!!! Execution of {} '{}' failed with exit code '{}'",
-                what_kind_of_process_is_it, prog, exit_code
-            );
-            show_stdout_stderr();
-            eprintln!("{}", additional_msg_when_non_zero_exit_code);
-            and_panic();
-        } else {
+        if 0 == exit_code {
             #[allow(clippy::needless_return)] // it's more readable
             return output;
-        }
+        } // else {
+        eprintln!(
+            "!!! Execution of {} '{}' failed with exit code '{}'",
+            what_kind_of_process_is_it, prog, exit_code
+        );
+        show_stdout_stderr();
+        eprintln!("{}", additional_msg_when_non_zero_exit_code);
+        and_panic();
     }
 
-    /// Executes Command::status().success() and panics if it any fail
+    /// Executes `Command::status().success()` and panics if it any fail
     /// This means exit code 0 is ensured.
     /// Note: You can't use an arg value "<string-with-nul>", or this will panic.
     fn success_or_panic(&mut self, what_kind_of_command_is_it: &str) -> ExitStatus {
@@ -1029,6 +1028,7 @@ impl MyCompilerCommand for std::process::Command {
 
     /// panics if arg has \0 aka nul in it, else Command will panic later, on execution.
     fn arg_checked<S: AsRef<OsStr>>(&mut self, arg: S) -> &mut Command {
+        #[allow(clippy::manual_assert)]
         if has_null_byte(&arg) {
             //If the arg has NUL ie. \0  in it then arg got replaced already
             //with "<string-with-nul>", internally, by std::process::Command::arg() .
@@ -1043,7 +1043,7 @@ impl MyCompilerCommand for std::process::Command {
         self.arg(arg)
     }
 
-    /// Beware if user set the arg on purpose to the value of REPLACEMENT_FOR_ARG_THAT_HAS_NUL
+    /// Beware if user set the arg on purpose to the value of `REPLACEMENT_FOR_ARG_THAT_HAS_NUL`
     /// which is "<string-with-nul>" then this will panic, it's a false positive.
     fn assert_no_nul_in_args(&mut self) -> &mut Self {
         let args = self.get_args();
@@ -1051,6 +1051,7 @@ impl MyCompilerCommand for std::process::Command {
             if let Some(fully_utf8_arg) = arg.to_str() {
                 //If the arg had NUL ie. \0  in it then arg got replaced already
                 //with "<string-with-nul>", internally, by std::process::Command::arg() .
+                #[allow(clippy::manual_assert)]
                 if fully_utf8_arg == REPLACEMENT_FOR_ARG_THAT_HAS_NUL {
                     panic!(
                         "Found arg number '{}' that has \\0 aka NUL in it! \
@@ -1091,9 +1092,9 @@ impl MyCompilerCommand for std::process::Command {
         (prog, args, cur_dir, env_vars)
     }
 
-    /// just like Command::status() but panics if it can't execute it,
-    /// ie. if status() would've returned an Err
-    /// returns ExitStatus whether it be 0 or !=0
+    /// just like `Command::status()` but panics if it can't execute it,
+    /// ie. if `status()` would've returned an Err
+    /// returns `ExitStatus` whether it be 0 or !=0
     /// Doesn't show you what will be executed and doesn't check args.
     /// (not meant to be used outside)
     fn just_status_or_panic(&mut self, what_kind_of_command_is_it: &str) -> ExitStatus {
@@ -1104,7 +1105,7 @@ impl MyCompilerCommand for std::process::Command {
     }
 
     /// Shows command that will execute and checks args, only after this
-    /// it's gonna be trying to do .status()
+    /// it's gonna be trying to do `.status()`
     /// Panics if status would've returned an Err
     fn status_or_panic(&mut self, what_kind_of_command_is_it: &str) -> ExitStatus {
         self.show_what_will_run()
@@ -1113,8 +1114,8 @@ impl MyCompilerCommand for std::process::Command {
     }
 
     /// Used only for build.rs tests:
-    /// this should be exactly like status_or_panic() except it won't check that args
-    /// aren't nul-containing and thus won't panic before the original status() gets run, thus
+    /// this should be exactly like `status_or_panic()` except it won't check that args
+    /// aren't nul-containing and thus won't panic before the original `status()` gets run, thus
     /// allowing it to panic on nul.
     /// (not meant to be used outside)
     fn status_or_panic_but_no_check_args(
@@ -1135,7 +1136,7 @@ impl MyCompilerCommand for std::process::Command {
         } else {
             " "
         };
-        let (cur_dir_for_print, env_vars_for_print) = get_cd_and_env_for_print(cur_dir, env_vars);
+        let (cur_dir_for_print, env_vars_for_print) = get_cd_and_env_for_print(cur_dir, &env_vars);
         panic!(
             "Failed to run {}{}command '{}' with '{}' args: '{}'{}{}, reason: '{}'",
             what_type_of_command,
@@ -1153,7 +1154,7 @@ impl MyCompilerCommand for std::process::Command {
     fn show_what_will_run(&mut self) -> &mut Self {
         let (exe_name, args, cur_dir, env_vars) = self.get_what_will_run();
         let how_many_args = args.len();
-        let (cur_dir_for_print, env_vars_for_print) = get_cd_and_env_for_print(cur_dir, env_vars);
+        let (cur_dir_for_print, env_vars_for_print) = get_cd_and_env_for_print(cur_dir, &env_vars);
         eprintln!(
             "!! Next, attempting to run command '{}' with '{}' args: '{}'{}{}.",
             exe_name, how_many_args, args, cur_dir_for_print, env_vars_for_print
@@ -1195,7 +1196,7 @@ fn humanly_visible_os_chars(f: &mut fmt::Formatter<'_>, arg: &OsStr) -> fmt::Res
         //then we show it as ascii + hex
         write!(f, "\"")?;
         for byte in arg.as_bytes() {
-            match std::char::from_u32(*byte as u32) {
+            match std::char::from_u32(u32::from(*byte)) {
                 Some(c) if c.is_ascii() => write!(f, "{}", c)?,
                 _ => {
                     write!(f, "\\x{:02X}", byte)?;
@@ -1292,7 +1293,7 @@ impl<'a> fmt::Display for MyEnvVars<'a> {
 }
 
 ///
-fn get_cd_and_env_for_print(cur_dir: Option<&Path>, env_vars: MyEnvVars) -> (String, String) {
+fn get_cd_and_env_for_print(cur_dir: Option<&Path>, env_vars: &MyEnvVars) -> (String, String) {
     let cur_dir_for_print: String = if let Some(dir) = cur_dir {
         format!(", in current dir: {:?}", dir)
     } else {
@@ -1494,6 +1495,7 @@ fn expect_panic(result: Result<(), Box<dyn std::any::Any + Send>>, expected_pani
             // Uncomment this to can copy/paste it for asserts:
             //println!("!!!!!!!!!! Panic message: {:?}", err);
 
+            #[allow(clippy::manual_assert)]
             if !match_with_placeholders(err, expected_panic_message) {
                 panic!(
                 "!!! Got different panic message than expected !!!\n\nExpected: '{}'\n\n     Got: '{}'\n",
@@ -1584,7 +1586,7 @@ fn test_assert_no_nul_in_args() {
     });
     expect_panic(
         result,
-        r##"Found arg number '1' that has \0 aka NUL in it! It got replaced with '<string-with-nul>'."##,
+        r"Found arg number '1' that has \0 aka NUL in it! It got replaced with '<string-with-nul>'.",
     );
 
     let result = std::panic::catch_unwind(|| {

From c760a16d652940bb9caab66a2b36e768f77ba31b Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Wed, 24 Apr 2024 14:55:50 +0200
Subject: [PATCH 51/54] inline ncurses::box_(...) too

... since it's calling wborder(...)
---
 src/lib.rs | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/lib.rs b/src/lib.rs
index a5576bdb..83a20f69 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -163,6 +163,7 @@ pub fn border(ls: chtype, rs: chtype, ts: chtype, bs: chtype, tl: chtype, tr: ch
 pub fn r#box(w: WINDOW, v: chtype, h: chtype) -> i32
 { box_(w,v,h) }
 
+#[inline(always)]
 pub fn box_(w: WINDOW, v: chtype, h: chtype) -> i32
 { wborder(w, v, v, h, h, 0, 0, 0, 0) }
 

From 4e984788b31464d3c294c1e8b266f0456cb6885d Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Sat, 27 Apr 2024 14:58:38 +0200
Subject: [PATCH 52/54] say it won't build on windows, but will on WSL

* show a clean compilation error, not followed by other compilation
errors, on native Windows.
---
 build.rs | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/build.rs b/build.rs
index be281883..915cebad 100644
--- a/build.rs
+++ b/build.rs
@@ -10,6 +10,9 @@
 )]
 #![allow(clippy::uninlined_format_args)] // or is it more readable inlined?
 
+#[cfg(target_os = "windows")]
+compile_error!("You can't compile this ncurses crate on native Windows, but you could compile it on Windows Subsystem for Linux aka WSL because that's seen as unix. If you want native Windows then consider using pancurses instead, because it uses pdcurses instead.");
+
 extern crate cc;
 extern crate pkg_config;
 
@@ -20,7 +23,9 @@ use std::ffi::OsString;
 use std::fmt;
 use std::fs::File;
 use std::io::Write as required_for_write_all_function; //in File
+#[cfg(not(target_os = "windows"))]
 use std::os::unix::ffi::OsStrExt;
+#[cfg(not(target_os = "windows"))]
 use std::os::unix::ffi::OsStringExt;
 use std::path::Path;
 use std::process::Command;
@@ -914,6 +919,7 @@ trait MyCompilerCommand {
 
 fn has_null_byte<S: AsRef<OsStr>>(arg: S) -> bool {
     let os_str = arg.as_ref();
+    #[cfg(not(target_os = "windows"))]
     for &byte in os_str.as_bytes() {
         if byte == 0 {
             return true;
@@ -1195,6 +1201,7 @@ fn humanly_visible_os_chars(f: &mut fmt::Formatter<'_>, arg: &OsStr) -> fmt::Res
         //None aka not fully utf8 arg
         //then we show it as ascii + hex
         write!(f, "\"")?;
+        #[cfg(not(target_os = "windows"))]
         for byte in arg.as_bytes() {
             match std::char::from_u32(u32::from(*byte)) {
                 Some(c) if c.is_ascii() => write!(f, "{}", c)?,
@@ -1313,6 +1320,7 @@ fn get_cd_and_env_for_print(cur_dir: Option<&Path>, env_vars: &MyEnvVars) -> (St
 
 /// This is used to test build.rs, run with: cargo build --features=test_build_rs_of_ncurses_rs
 /// This won't happen if you use --all-features
+#[cfg(not(target_os = "windows"))]
 #[cfg(all(
     feature = "test_build_rs_of_ncurses_rs",
     not(feature = "dummy_feature_to_detect_that_--all-features_arg_was_used")
@@ -1430,6 +1438,7 @@ fn test_panic_for_command_non_zero_exit() {
 }
 
 #[allow(dead_code)]
+#[cfg(not(target_os = "windows"))]
 fn test_invalid_utf8_in_program() {
     let result = std::panic::catch_unwind(|| {
         let mut command = Command::new(OsString::from_vec(
@@ -1512,6 +1521,7 @@ fn expect_panic(result: Result<(), Box<dyn std::any::Any + Send>>, expected_pani
 }
 
 #[allow(dead_code)]
+#[cfg(not(target_os = "windows"))]
 fn test_nul_in_arg_unchecked() {
     let result = std::panic::catch_unwind(|| {
         let mut command = Command::new("test_nul_in_arg_unchecked.exe");
@@ -1528,6 +1538,7 @@ fn test_nul_in_arg_unchecked() {
 }
 
 #[allow(dead_code)]
+#[cfg(not(target_os = "windows"))]
 fn test_nul_in_arg() {
     //via .arg()
     let result = std::panic::catch_unwind(|| {
@@ -1558,6 +1569,7 @@ fn test_nul_in_arg() {
 }
 
 #[allow(dead_code)]
+#[cfg(not(target_os = "windows"))]
 fn test_get_what_will_run() {
     let expected_prog = "test_get_what_will_run.exe";
     let mut command = Command::new(expected_prog);

From 6550ad1f89f7905f15dbb371fceaf10c1e8dcc51 Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Wed, 22 May 2024 07:48:05 +0200
Subject: [PATCH 53/54] remove code that was testing build.rs

as suggested in: https://github.com/jeaye/ncurses-rs/pull/218#issuecomment-2123881995

Before this removal, this command was testing _some_ build.rs functionality:
$ cargo build --features=test_build_rs_of_ncurses_rs
---
 Cargo.toml |   4 -
 build.rs   | 337 -----------------------------------------------------
 2 files changed, 341 deletions(-)

diff --git a/Cargo.toml b/Cargo.toml
index 994e33b5..229ebd9b 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -47,9 +47,5 @@ wide_chtype = []
 mouse_v1 = []
 extended_colors = ["wide"]
 
-#Internal features used in 'build.rs' only:
-test_build_rs_of_ncurses_rs = [] #<- not picked up by --all-features
-dummy_feature_to_detect_that_--all-features_arg_was_used= []
-
 [lib]
 name = "ncurses"
diff --git a/build.rs b/build.rs
index 915cebad..dcf672e4 100644
--- a/build.rs
+++ b/build.rs
@@ -1,13 +1,3 @@
-// To test some of build.rs' code correctness run:
-// cargo build --features=test_build_rs_of_ncurses_rs
-// when doing that, the following cfg_attr ensures there are no warnings about unused stuff.
-#![cfg_attr(
-    all(
-        feature = "test_build_rs_of_ncurses_rs",
-        not(feature = "dummy_feature_to_detect_that_--all-features_arg_was_used")
-    ),
-    allow(dead_code)
-)]
 #![allow(clippy::uninlined_format_args)] // or is it more readable inlined?
 
 #[cfg(target_os = "windows")]
@@ -19,14 +9,11 @@ extern crate pkg_config;
 use pkg_config::Library;
 use std::env;
 use std::ffi::OsStr;
-use std::ffi::OsString;
 use std::fmt;
 use std::fs::File;
 use std::io::Write as required_for_write_all_function; //in File
 #[cfg(not(target_os = "windows"))]
 use std::os::unix::ffi::OsStrExt;
-#[cfg(not(target_os = "windows"))]
-use std::os::unix::ffi::OsStringExt;
 use std::path::Path;
 use std::process::Command;
 use std::process::ExitStatus;
@@ -162,11 +149,6 @@ fn cargo_warn_unformatted(warn_msg: &str) {
 }
 // -----------------------------------------------------------------
 // This is the normal build.rs main(),
-// it's only disabled when you used: `cargo build --feature=test_build_rs_of_ncurses_rs`
-#[cfg(any(
-    not(feature = "test_build_rs_of_ncurses_rs"),
-    feature = "dummy_feature_to_detect_that_--all-features_arg_was_used"
-))]
 fn main() {
     watch_env_var("PKG_CONFIG_PATH");
 
@@ -898,8 +880,6 @@ trait MyCompilerCommand {
     //fn success_or_else<F: FnOnce(ExitStatus) -> ExitStatus>(&mut self, op: F) -> ExitStatus;
     fn just_status_or_panic(&mut self, what_kind_of_command_is_it: &str) -> ExitStatus;
     fn status_or_panic(&mut self, what_kind_of_command_is_it: &str) -> ExitStatus;
-    fn status_or_panic_but_no_check_args(&mut self, what_kind_of_command_is_it: &str)
-        -> ExitStatus;
     fn show_what_will_run(&mut self) -> &mut Self;
     fn get_program_or_panic(&self) -> &str;
     fn get_what_will_run(&self) -> (String, MyArgs, Option<&Path>, MyEnvVars);
@@ -1119,19 +1099,6 @@ impl MyCompilerCommand for std::process::Command {
             .just_status_or_panic(what_kind_of_command_is_it)
     }
 
-    /// Used only for build.rs tests:
-    /// this should be exactly like `status_or_panic()` except it won't check that args
-    /// aren't nul-containing and thus won't panic before the original `status()` gets run, thus
-    /// allowing it to panic on nul.
-    /// (not meant to be used outside)
-    fn status_or_panic_but_no_check_args(
-        &mut self,
-        what_kind_of_command_is_it: &str,
-    ) -> ExitStatus {
-        self.show_what_will_run()
-            .just_status_or_panic(what_kind_of_command_is_it)
-    }
-
     /// (not meant to be used outside)
     //panic(  <- for search
     fn panic<T: std::fmt::Display>(&mut self, err: T, what_type_of_command: &str) -> ! {
@@ -1237,19 +1204,6 @@ impl<'a> FromIterator<&'a OsStr> for MyArgs<'a> {
     }
 }
 
-impl<'a> MyArgs<'a> {
-    //    // Implement a method to get the length of the arguments
-    //    // don't need this because impl Deref!
-    //    pub fn len(&self) -> usize {
-    //        self.0.len()
-    //        //self.len()//won't use deref, but will infinitely recurse (untested)
-    //        //(&*self).len() // same as self.0.len() (untested)
-    //    }
-    pub fn display(&self) -> String {
-        format!("{}", self)
-    }
-}
-
 //so we don't have to use self.0
 impl<'a> std::ops::Deref for MyArgs<'a> {
     type Target = Vec<&'a OsStr>;
@@ -1318,294 +1272,3 @@ fn get_cd_and_env_for_print(cur_dir: Option<&Path>, env_vars: &MyEnvVars) -> (St
     (cur_dir_for_print, formatted_env_vars_for_print)
 }
 
-/// This is used to test build.rs, run with: cargo build --features=test_build_rs_of_ncurses_rs
-/// This won't happen if you use --all-features
-#[cfg(not(target_os = "windows"))]
-#[cfg(all(
-    feature = "test_build_rs_of_ncurses_rs",
-    not(feature = "dummy_feature_to_detect_that_--all-features_arg_was_used")
-))]
-fn main() {
-    test_assert_works();
-    test_match_with_placeholders();
-    test_invalid_utf8_in_program();
-    test_nul_in_arg_unchecked();
-    test_nul_in_arg();
-    test_no_panic_in_command();
-    test_panic_for_not_found_command();
-    test_panic_for_command_non_zero_exit();
-    test_get_what_will_run();
-    test_assert_no_nul_in_args();
-
-    eprintln!("\n-------------------------------------
-              \n!!! All build.rs tests have passed successfully! Ignore the above seemingly erroneous output, it was part of the successful testing !!!\nYou're seeing this because you tried to build with --features=test_build_rs_of_ncurses_rs");
-
-    // This stops the build from continuing which will fail in other places due to build.rs not
-    // doing its job, since we've only just tested build.rs not used it to generate stuff.
-    std::process::exit(5);
-}
-//The test functions are left outside of 'test_build_rs_of_ncurses_rs' feature gate
-//so that they're tested to still compile ok.
-
-#[allow(dead_code)]
-fn test_assert_works() {
-    let result = std::panic::catch_unwind(|| {
-        #[allow(clippy::assertions_on_constants)]
-        {
-            assert!(false, "!! just tested if asserts are enabled !!");
-        }
-    });
-    #[allow(clippy::manual_assert)]
-    if result.is_ok() {
-        panic!("Assertions are disabled in build.rs, should not happen!");
-    }
-}
-
-#[allow(dead_code)]
-fn test_no_panic_in_command() {
-    let expected_ec = 42;
-    let cmd = if cfg!(windows) { "cmd" } else { "sh" };
-    let args_ok = &["-c", "exit 0"];
-    let args_fail = &["-c", &format!("exit {}", expected_ec)];
-    let result = std::panic::catch_unwind(|| {
-        let mut command = Command::new(cmd);
-        command.args(args_ok);
-        //execute: sh -c 'exit 0'`
-        command.status_or_panic("test1");
-    });
-    let fail_msg = format!(
-        "!!! This should not have panicked! Unless you don't have '{}' command, in PATH={:?} !!!",
-        cmd,
-        std::env::var("PATH")
-    );
-    assert!(result.is_ok(), "{}", fail_msg);
-
-    // executed bin exits with exit code 0, or it would panic ie. fail the test
-    let result = std::panic::catch_unwind(|| {
-        let mut command = Command::new(cmd);
-        command.args(args_ok);
-        //execute: sh -c 'exit 0'`
-        command.success_or_panic("test2");
-    });
-    assert!(result.is_ok(), "{}", fail_msg);
-
-    // executed bin exits with specific exit code 2
-    let result = std::panic::catch_unwind(|| {
-        let mut command = Command::new(cmd);
-        command.args(args_fail);
-        //execute: sh -c 'exit 42'`
-        let exit_status = command.status_or_panic("test3");
-        assert_eq!(
-            exit_status.code().expect("was command killed by a signal?"),
-            expected_ec,
-            "Command should've exited with exit code '{}'.",
-            expected_ec
-        );
-    });
-    assert!(result.is_ok(), "{}", fail_msg);
-}
-
-#[allow(dead_code)]
-fn test_panic_for_not_found_command() {
-    let result = std::panic::catch_unwind(|| {
-        let mut command = Command::new("some non-exitent command");
-        command.args([OsString::from("arg1")]);
-        command.status_or_panic("inexistent");
-    });
-    let expected_panic_msg=
-     "Failed to run inexistent command 'some non-exitent command' with '1' args: '\"arg1\"', in unspecified current dir(but the actual cwd is currently Ok({})), with no extra env.vars added or deleted(so all are inherited from parent process), reason: 'No such file or directory (os error 2)'";
-    expect_panic(result, expected_panic_msg);
-
-    let result = std::panic::catch_unwind(|| {
-        let mut command = Command::new("some non-exitent command");
-        command.args([OsString::from("arg1")]);
-        command.success_or_panic("inexistent");
-    });
-    expect_panic(result, expected_panic_msg);
-}
-
-#[allow(dead_code)]
-fn test_panic_for_command_non_zero_exit() {
-    let cmd = if cfg!(windows) { "cmd" } else { "sh" };
-    let args_fail = &["-c", "exit 43"];
-    let result = std::panic::catch_unwind(|| {
-        let mut command = Command::new(cmd);
-        command.args(args_fail);
-        command.success_or_panic("shell-type");
-    });
-    let expected_panic_msg = "!!! Compiler failed with exit code 43. Is ncurses installed? pkg-config or pkgconf too? it's 'ncurses-devel' on Fedora; and 'libncurses-dev' on Ubuntu; run `nix-shell` first, on NixOS. Or maybe it failed for different reasons which are seen in the errored output above.";
-    expect_panic(result, expected_panic_msg);
-}
-
-#[allow(dead_code)]
-#[cfg(not(target_os = "windows"))]
-fn test_invalid_utf8_in_program() {
-    let result = std::panic::catch_unwind(|| {
-        let mut command = Command::new(OsString::from_vec(
-            b"test_invalid_utf8_\xFFin_program".to_vec(),
-        ));
-        command.args([
-            OsString::from("arg1"),
-            OsString::from_vec(b"my\xffarg3".to_vec()),
-        ]);
-        command.status_or_panic("test-type");
-    });
-    expect_panic(
-        result,
-        "Executable \"test_invalid_utf8_\\xFFin_program\" isn't valid rust string",
-    );
-}
-
-#[allow(dead_code)]
-fn test_match_with_placeholders() {
-    let str1 = "abc";
-    let str2 = "abc";
-    let str3 = "a{}bc";
-    let str4 = "a{}c";
-    assert!(match_with_placeholders(str1, str2));
-    assert!(match_with_placeholders(str1, str3));
-    assert!(match_with_placeholders(str1, str4));
-    let str5 = "";
-    let str6 = "{}";
-    let str7 = "{}{}{}";
-    let str8 = "{}a{}{}{}b{}{}c{}{}";
-    assert!(match_with_placeholders(str5, str5));
-    assert!(match_with_placeholders(str5, str6));
-    assert!(match_with_placeholders(str5, str7));
-    assert!(match_with_placeholders(str1, str8));
-
-    let p_msg = "some random thing";
-    let r: Result<(), Box<dyn std::any::Any + Send>> = Err(Box::new(p_msg.to_string()));
-    expect_panic(r, "some {} thing");
-}
-
-fn match_with_placeholders(pristine_str: &str, placeholdery_str: &str) -> bool {
-    // Split placeholdery_str into substrings based on {}
-    let placeholders: Vec<&str> = placeholdery_str.split("{}").collect();
-
-    // Check if pristine_str contains all the substrings in order
-    let mut index = 0;
-    for &placeholder in &placeholders {
-        match pristine_str[index..].find(placeholder) {
-            Some(pos) => index += pos + placeholder.len(),
-            None => {
-                return false;
-            }
-        }
-    }
-    true
-}
-
-/// Panics if the 'result' has a different panic message than the expected one.
-/// The {} in the expected message string can match anything, including empty string.
-fn expect_panic(result: Result<(), Box<dyn std::any::Any + Send>>, expected_panic_message: &str) {
-    if result.is_err() {
-        if let Some(err) = result.unwrap_err().downcast_ref::<String>() {
-            // Uncomment this to can copy/paste it for asserts:
-            //println!("!!!!!!!!!! Panic message: {:?}", err);
-
-            #[allow(clippy::manual_assert)]
-            if !match_with_placeholders(err, expected_panic_message) {
-                panic!(
-                "!!! Got different panic message than expected !!!\n\nExpected: '{}'\n\n     Got: '{}'\n",
-                expected_panic_message, err
-                );
-            }
-        }
-    } else {
-        panic!(
-            "No panic was thrown! But was expecting this panic: '{}'",
-            expected_panic_message
-        );
-    };
-}
-
-#[allow(dead_code)]
-#[cfg(not(target_os = "windows"))]
-fn test_nul_in_arg_unchecked() {
-    let result = std::panic::catch_unwind(|| {
-        let mut command = Command::new("test_nul_in_arg_unchecked.exe");
-        command.args([
-            OsString::from("arg1"),
-            OsString::from("a\0rg2"),
-            OsString::from_vec(b"my\xffarg3".to_vec()),
-        ]);
-        command.status_or_panic_but_no_check_args("funky");
-    });
-    expect_panic(result,
-         "Failed to run funky command 'test_nul_in_arg_unchecked.exe' with '3' args: '\"arg1\" \"<string-with-nul>\" \"my\\xFFarg3\"', in unspecified current dir(but the actual cwd is currently Ok({}), with no extra env.vars added or deleted(so all are inherited from parent process), reason: 'nul byte found in provided data'"
-        );
-}
-
-#[allow(dead_code)]
-#[cfg(not(target_os = "windows"))]
-fn test_nul_in_arg() {
-    //via .arg()
-    let result = std::panic::catch_unwind(|| {
-        let mut command = Command::new("test_nul_in_arg.exe");
-        command.arg_checked(OsString::from("arg1"));
-        command.arg_checked(
-            // would panic here
-            OsString::from("a\0rg2"),
-        );
-        command.arg_checked(OsString::from_vec(b"my\xffarg3".to_vec()));
-        command.status_or_panic("test-type");
-    });
-    let expected_panic_msg=
-         "Found arg '\"a\\0rg2\"' that has at least one \\0 aka nul in it! This would've been silently replaced with '<string-with-nul>' and error later if at all.";
-    expect_panic(result, expected_panic_msg);
-    //via .args()
-    let result = std::panic::catch_unwind(|| {
-        let mut command = Command::new("test_nul_in_args.exe");
-        command.args_checked([
-            // would panic here
-            OsString::from("arg1"),
-            OsString::from("a\0rg2"),
-            OsString::from_vec(b"my\xffarg3".to_vec()),
-        ]);
-        command.status_or_panic("test-type");
-    });
-    expect_panic(result, expected_panic_msg);
-}
-
-#[allow(dead_code)]
-#[cfg(not(target_os = "windows"))]
-fn test_get_what_will_run() {
-    let expected_prog = "test_get_what_will_run.exe";
-    let mut command = Command::new(expected_prog);
-    command.arg_checked(OsString::from("arg1"));
-    command.args_checked([
-        // would panic here
-        OsString::from_vec(b"my\xffarg3".to_vec()),
-        OsString::from("arg4"),
-    ]);
-    command.arg_checked(OsString::from_vec(b"my\xffarg3".to_vec()));
-    let (prog, args, _cur_dir, _envs) = command.get_what_will_run();
-    let expected_hma = 4;
-    let expected_fa = "\"arg1\" \"my\\xFFarg3\" \"arg4\" \"my\\xFFarg3\"";
-    assert_eq!(prog, expected_prog);
-    assert_eq!(args.len(), expected_hma);
-    assert_eq!(args.display(), expected_fa);
-}
-
-#[allow(dead_code)]
-fn test_assert_no_nul_in_args() {
-    let expected_prog = "test_get_what_will_run.exe";
-    let result = std::panic::catch_unwind(|| {
-        let mut command = Command::new(expected_prog);
-        command.arg("a\0here");
-        command.assert_no_nul_in_args();
-    });
-    expect_panic(
-        result,
-        r"Found arg number '1' that has \0 aka NUL in it! It got replaced with '<string-with-nul>'.",
-    );
-
-    let result = std::panic::catch_unwind(|| {
-        let mut command = Command::new(expected_prog);
-        command.arg("no nul in this arg here");
-        command.assert_no_nul_in_args();
-    });
-    assert!(result.is_ok(), "!!! This should not have panicked !!!");
-}
-//TODO: test more functionality.

From 4cb88d6234989f38121e42c7dd8223fc060b193a Mon Sep 17 00:00:00 2001
From: correabuscar <correabuscar+githubcommits@gmail.com>
Date: Wed, 29 May 2024 18:40:38 +0200
Subject: [PATCH 54/54] build.rs: imp. function to show weird paths as hex

* previously char range 0x00 to 0x1F weren't hexified
* even if valid utf-8, still show \0 as \x00
(even though in our use case \0 wouldn't be seen due to being converted
by Command::arg/args earlier to "<string-with-nul>")

* passes the tests that were there thus far but got removed by prev. commit
---
 build.rs | 22 +++++++++++++++++++---
 1 file changed, 19 insertions(+), 3 deletions(-)

diff --git a/build.rs b/build.rs
index dcf672e4..78a65343 100644
--- a/build.rs
+++ b/build.rs
@@ -1162,8 +1162,22 @@ struct MyArgs<'a>(Vec<&'a OsStr>);
 
 fn humanly_visible_os_chars(f: &mut fmt::Formatter<'_>, arg: &OsStr) -> fmt::Result {
     if let Some(arg_str) = arg.to_str() {
-        // If the argument is valid UTF-8, simply display it
-        write!(f, "\"{}\"", arg_str)?;
+        // If the argument is valid UTF-8,
+        if arg_str.contains('\0') {
+            write!(f, "\"")?;
+            // has \0 in it, show them as \x00 but keep the rest as they are such as 
+            for c in arg_str.chars() {
+                if c == '\0' {
+                    write!(f,"\\x00")?
+                } else {
+                    write!(f,"{}",c)?
+                }
+            }
+            write!(f, "\"")?;
+        } else {
+            // has no \0 in it
+            write!(f, "\"{}\"", arg_str)?;
+        }
     } else {
         //None aka not fully utf8 arg
         //then we show it as ascii + hex
@@ -1171,7 +1185,9 @@ fn humanly_visible_os_chars(f: &mut fmt::Formatter<'_>, arg: &OsStr) -> fmt::Res
         #[cfg(not(target_os = "windows"))]
         for byte in arg.as_bytes() {
             match std::char::from_u32(u32::from(*byte)) {
-                Some(c) if c.is_ascii() => write!(f, "{}", c)?,
+                //chars in range 0x20..0x7E (presumably printable) are shown as they are
+                Some(c) if (*byte >= 0x20) && (*byte <= 0x7E) => write!(f, "{}", c)?,
+                //anything else including \0 and  become hex, eg.  is \xE2\x99\xA5
                 _ => {
                     write!(f, "\\x{:02X}", byte)?;
                 }
