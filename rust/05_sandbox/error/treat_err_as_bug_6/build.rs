// To test some of build.rs' code correctness run:
// cargo build --features=test_build_rs_of_ncurses_rs
// when doing that, the following cfg_attr ensures there are no warnings about unused stuff.
#![cfg_attr(
    all(
        feature = "test_build_rs_of_ncurses_rs",
        not(feature = "dummy_feature_to_detect_that_--all-features_arg_was_used")
    ),
    allow(dead_code)
)]
#![allow(clippy::uninlined_format_args)] // or is it more readable inlined?

extern crate cc;
extern crate pkg_config;

use pkg_config::Library;
use std::env;
use std::ffi::OsStr;
use std::ffi::OsString;
use std::fmt::Write as required_for_writeln_macro;
use std::fs::File;
use std::io::Write as required_for_write_all_function; //in File
use std::os::unix::ffi::OsStrExt;
use std::os::unix::ffi::OsStringExt;
use std::path::Path;
use std::process::Command;
use std::process::ExitStatus;

//Decide whether or not to delete .c and bin files generated by build.rs once they're not needed.
//Defaulting to 'false' because it's a job for 'cargo clean' and
//it might help with debugging build issues if we keep them around.
//even if this were true, we're already keeping 'libwrap.a', so FIXME: if this is set true.
const DELETE_GENERATEDS: bool = false;

// Optional environment variables:

// The below doc comment doesn't apply for these 2 env.vars:
const ENV_VAR_NAME_FOR_LIB: &str = "NCURSES_RS_RUSTC_LINK_LIB";
const ENV_VAR_NAME_FOR_NCURSES_RS_RUSTC_FLAGS: &str = "NCURSES_RS_RUSTC_FLAGS";

/// Assuming we want env.var "NCURSES_RS_CFLAGS" here,
/// and target==host and is "x86_64-unknown-linux-gnu"
/// then calls to Build::try_flags_from_environment() below in code,
/// will try the following env.vars in this order:
/// 1. "NCURSES_RS_CFLAGS_x86_64-unknown-linux-gnu" (notice dashes)
/// 2. "NCURSES_RS_CFLAGS_x86_64_unknown_linux_gnu" (notice underscores)
/// 3. "HOST_NCURSES_RS_CFLAGS" or "TARGET_NCURSES_RS_CFLAGS" (if target!=host)
/// 4. "NCURSES_RS_CFLAGS" (our original wanted)
/// and the first one that exists is used instead.
/// see: https://docs.rs/cc/1.0.92/src/cc/lib.rs.html#3571-3580
/// All of the _tried_ ones are emitted as: cargo:rerun-if-env-changed=
/// which means, if NCURSES_RS_CFLAGS_x86_64_unknown_linux_gnu is set then NCURSES_RS_CFLAGS won't
/// be emitted which makes sense as this one overrides the rest anyway.
const ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS: &str = "NCURSES_RS_CFLAGS";

const IS_WIDE: bool = cfg!(feature = "wide");
const IS_MACOS: bool = cfg!(target_os = "macos");
// Why also not on macos? see: https://github.com/jeaye/ncurses-rs/issues/151
const IS_WIDE_AND_NOT_ON_MACOS: bool = IS_WIDE && !IS_MACOS;

// Will search for these lib names and if not found via pkg-config
// then use the fallback name and still try linking with it
// because in most cases it will work anyway.
const NCURSES_LIB_NAME_FALLBACK: &str = if IS_WIDE_AND_NOT_ON_MACOS {
    "ncursesw"
} else {
    "ncurses"
};
const NCURSES_LIB_NAMES: &[&str] = if IS_WIDE_AND_NOT_ON_MACOS {
    &["ncursesw5", NCURSES_LIB_NAME_FALLBACK]
} else {
    &["ncurses5", NCURSES_LIB_NAME_FALLBACK]
};

const MENU_LIB_NAME_FALLBACK: &str = if IS_WIDE_AND_NOT_ON_MACOS {
    "menuw"
} else {
    "menu"
};
const MENU_LIB_NAMES: &[&str] = if IS_WIDE_AND_NOT_ON_MACOS {
    &["menuw5", MENU_LIB_NAME_FALLBACK]
} else {
    &["menu5", MENU_LIB_NAME_FALLBACK]
};

const PANEL_LIB_NAME_FALLBACK: &str = if IS_WIDE_AND_NOT_ON_MACOS {
    "panelw"
} else {
    "panel"
};
const PANEL_LIB_NAMES: &[&str] = if IS_WIDE_AND_NOT_ON_MACOS {
    &["panelw5", PANEL_LIB_NAME_FALLBACK]
} else {
    &["panel5", PANEL_LIB_NAME_FALLBACK]
};

const TINFO_LIB_NAMES: &[&str] = if IS_WIDE_AND_NOT_ON_MACOS {
    //elements order here matters, because:
    //Fedora has ncursesw+tinfo(without w) for wide!
    //and -ltinfow fails to link on NixOS and Fedora! so -ltinfo must be used even tho wide.
    //(presumably because tinfo doesn't depend on wideness?)
    //NixOS has only ncursesw(tinfo is presumably inside it) but -ltinfo still works for it(it's a
    //symlink to ncursesw lib)
    //Gentoo has ncursesw+tinfow
    //
    //These are tried in order and first that links is selected:
    &["tinfow5", "tinfow", "tinfo"]
    //doneFIXME: here ^, user can have in env. this TINFOW_NO_PKG_CONFIG=1 (but not also TINFO_NO_PKG_CONFIG=1) which would cause seg fault on Gentoo because tinfo will be found&linked(instead of tinfow) with one or more of menuw,panelw,ncursesw eg. when doing example ex_5 (ie. menuw,ncursesw,tinfo(no w)); but on Fedora this ncursesw+tinfo(no w) makes sense(because tinfo(no w) has both inside it, somehow, i guess), so we can't really guard against this (well maybe with target_os but what if they change in the future...) instead maybe print a warning if w and non-w are mixed(but only for tinfo is needed), even though it will be a false warning on Fedora, well maybe it won't be if we also check if env. var is set TINFOW_NO_PKG_CONFIG.
} else {
    //no reason to ever fallback to tinfow here when not-wide!
    //Fedora/Gentoo has ncurses+tinfo
    //NixOS has only ncursesw(but works for non-wide), -ltinfo symlinks to ncursesw .so file)
    //so 'tinfo' is safe fallback here.
    &["tinfo5", "tinfo"]
};
//TODO: why are we trying the v5 of the lib first instead of v6 (which is the second/last in list),
//was v5 newer than the next in list? is it so on other systems?
//like: was it ever ncurses5 newer than ncurses ?
//Since we're trying v5 and it finds it, it will use it and stop looking, even though the next one
//might be v6
//This is the commit that added this v5 then v6 way: https://github.com/jeaye/ncurses-rs/commit/daddcbb557169cfac03af9667ef7aefed19f9409

/// finds and emits cargo:rustc-link-lib=
fn find_library(names: &[&str]) -> Option<Library> {
    for name in names {
        //cargo_warn!("Trying lib '{}'",name);
        if let Ok(lib) = pkg_config::probe_library(name) {
            //cargo_warn!("Found lib '{}' '{:?}'",name, lib);
            return Some(lib);
        }
    }
    None
}

/// Emits the passed string(s) prefixed by 'cargo:warning=' on stdout,
/// which cargo will transform into a warning.
/// It acts like println!() macro, so you can call it the same way to do formatting!
/// Will replace newlines in the warning message with spaces,
/// otherwise the text after would not have been seen in the warning.
macro_rules! cargo_warn {
    ($($arg:tt)*) => {
        cargo_warn_unformatted(format!("{}", format_args!($($arg)*)));
    };
}

/// Pass the string to be emitted as a cargo warning.
/// Presumably you've already used format!() on it.
/// Will replace newlines in the warning message with spaces,
/// otherwise the text after would not have been seen in the warning.
fn cargo_warn_unformatted(warn_msg: String) {
    // Replace '\r' with nothing
    // Replace '\n' with space
    let warn_msg = warn_msg.replace('\r', "").replace('\n', " ");
    println!("cargo:warning={}", warn_msg);
}
// -----------------------------------------------------------------
// This is the normal build.rs main(),
// it's only disabled when you used: `cargo build --feature=test_build_rs_of_ncurses_rs`
#[cfg(any(
    not(feature = "test_build_rs_of_ncurses_rs"),
    feature = "dummy_feature_to_detect_that_--all-features_arg_was_used"
))]
fn main() {
    watch_env_var("PKG_CONFIG_PATH");

    let ncurses_lib = find_library(NCURSES_LIB_NAMES);
    // Gets the name of ncurses lib found by pkg-config, if it found any!
    // else (warns and)returns the default one like 'ncurses' or 'ncursesw'
    // and emits cargo:rustc-link-lib= for it unless already done.
    let lib_name = get_ncurses_lib_name(&ncurses_lib);
    //XXX: cargo seems to use --as-needed (arg for 'ld' linker) which isn't easy to figure out(had
    //to replace /usr/bin/ld temporarily, it won't work with just setting PATH because cc calls
    //sibbling ld disregarding PATH), but this means the order in which
    //we try to find the libs here matters(in theory): now it's ncurses,menu,panel,tinfo
    //Not entirely sure here if this will break things in practice(our case), as we previously used:
    //menu,panel,tinfo,ncurses order
    // https://wiki.gentoo.org/wiki/Project:Quality_Assurance/As-needed#Importance_of_linking_order
    // So in theory(untested), if a bin linked with cargo and only used symbols from menu not from ncurses,
    // and since menu wanted symbols from ncurses (like it does on OpenBSD), due to
    // -Wl,--as-needed, ncurses lib won't be linked in final bin(because bin doesn't use symbols
    // from it) thus cause the bin to fail with unresolved symbols at runtime.
    // However, in practice, we're "lucky" that anything(presumably), any bin we make that uses out
    // ncurses rust crate, will also use ncurses lib thus force it to be linked,
    // thus menu or panel libs that require it will always have it.

    //TODO: dedup, unmessify
    //TODO: dedup warning msgs and see when to still emit them.
    if cfg!(feature = "menu") {
        if find_library(MENU_LIB_NAMES).is_none() {
            let fallback_lib_name = MENU_LIB_NAME_FALLBACK;
            //doneFIXME: on openbsd(at least), the 'menu' linking via try_link() (ie. just -lmenu)
            //fails because it depends on ncurses also being linked in (via -lncurses)
            //because 'menu' lib doesn't have ncurses as a dynamic lib need, as it does on other OS-es like Gentoo
            //which you can see via readelf -d /usr/lib/libmenu.so.7.0 it's missing a line like:
            //(NEEDED)             Shared library: [libncurses.so.6]
            //which exists on Gentoo/NixOS for example.
            //so we must link with ncurses lib on try_link() to avoid unresolved symbols
            //from 'menu' lib (which,again, needs ncurses, but doesn't say(inside it) that it does)
            //which also means we must know if we have to use ncurses lib override before even trying
            //to link menu,panel,tinfo, and thus need to pass the ncurses lib name to try_link() as third arg.
            if let Some(needed_ncurses) = try_link(fallback_lib_name, &ncurses_lib, &lib_name) {
                let extra: String = if needed_ncurses {
                    format!(", but needs '{}' to link without undefined symbols(known to be true on OpenBSD)", lib_name)
                } else {
                    "".to_string()
                };
                cargo_warn!("Using lib fallback '{}' which links successfully{}. The need for fallback suggests that you might be missing `pkg-config`/`pkgconf`.", fallback_lib_name, extra);
            } else {
                let feature_name = "menu";
                cargo_warn!("Possibly missing lib for the '{}' feature, and couldn't find its fallback lib name '{}' but we're gonna use it anyway thus compilation is likely to fail below because of this. You might need installed ncurses and pkg-config/pkgconf to fix this.", feature_name, fallback_lib_name);
            }
            //We still try linking with it anyway, in case our try_link() code is somehow wrong,
            //like it doesn't include some link searchdir paths that are somehow included
            //otherwise. Or, as it used to happen before i fixed it: it fails to link because
            //libmenu has undefined symbols if not also linked with libncurses which is what
            //happens on openbsd; fixed now by always linking with libncurses via try_link() above
            println!("cargo:rustc-link-lib={}", fallback_lib_name);
        }
    }

    if cfg!(feature = "panel") {
        if find_library(PANEL_LIB_NAMES).is_none() {
            let fallback_lib_name = PANEL_LIB_NAME_FALLBACK;
            if let Some(needed_ncurses) = try_link(fallback_lib_name, &ncurses_lib, &lib_name) {
                let extra: String = if needed_ncurses {
                    format!(", but needs '{}' to link without undefined symbols(known to be true on OpenBSD)", lib_name)
                } else {
                    "".to_string()
                };
                cargo_warn!("Using lib fallback '{}' which links successfully{}. The need for fallback suggests that you might be missing `pkg-config`/`pkgconf`.", fallback_lib_name, extra);
            } else {
                let feature_name = "panel";
                cargo_warn!("Possibly missing lib for the '{}' feature, and couldn't find its fallback lib name '{}' but we're gonna use it anyway thus compilation is likely to fail below because of this. You might need installed ncurses and pkg-config/pkgconf to fix this.", feature_name, fallback_lib_name);
            }
            //We still try linking with it anyway, in case our try_link() code is somehow wrong,
            //like it doesn't include some link searchdir paths that are somehow included
            //otherwise.
            println!("cargo:rustc-link-lib={}", fallback_lib_name);
        }
    }

    //This comment block is about libtinfo.
    //If pkg-config can't find it, use fallback: 'tinfo' or 'tinfow'
    //if cargo can't find it it will ignore it gracefully - NO IT WON'T!
    //if it can find it, it will link it.
    //It's needed for ex_5 to can link  when pkg-config is missing,
    //otherwise you get this: undefined reference to symbol 'noraw'
    //Thus w/o this block, the following command would be needed to run ex_5
    //$ NCURSES_RS_RUSTC_FLAGS="-ltinfo" cargo run --features=menu --example ex_5
    //To emulate this even if you have pkg-config you can tell it to not do its job
    // by setting these env. vars before the above command:
    // $ NCURSES_NO_PKG_CONFIG=1 NCURSESW_NO_PKG_CONFIG=1 NCURSES5_NO_PKG_CONFIG=1 NCURSESW5_NO_PKG_CONFIG=1 the_rest_of_the_command_here
    // Fedora and Gentoo are two that have both ncurses(w) and tinfo(w), ie. split,
    // however Gentoo has ncurses+tinfo and ncursesw+tinfow,
    // but Fedora has ncurses+tinfo and ncursesw+tinfo (see 'tinfo' is same! no w)
    // NixOS has only ncursesw (tinfo is presumably inside?) but -lncurses -lncursesw -ltinfo work!
    // but -ltinfow doesn't work! on NixOS and Fedora!
    // On Gentoo -ltinfow works too!
    // so when pkg-config is missing, how do we know which tinfo to tell cargo to link, if any!
    // doneFIXME: ^ I guess we gonna have to compile own .c to link with tinfo to see if it fails or
    // works!
    let tinfo_name = if let Some(found) = find_library(TINFO_LIB_NAMES) {
        let libs = found.libs;
        assert_eq!(
            libs.len(),
            1,
            "Unexpected pkg-config query for tinfo lib returned more than one lib: '{:?}'",
            libs
        );
        libs.first()
            .unwrap_or_else(|| {
                panic!(
                    "Unexpected panic on trying to get the first found tinfo lib string from: '{:?}'.",
                    libs
                )
            })
            .clone()
    } else {
        //None found; but at least on NixOS it works without any tinfo(it's inside ncursesw lib and tinfo/ncurses all symlink to that same ncursesw.so, except tinfow which doesn't exist but pkg-config points it to -lncursesw), so no need to warn that we didn't find any tinfo.
        //Pick the tinfo lib to link with, as fallback,
        //the first one that links successfully!
        //The order in the list matters!
        TINFO_LIB_NAMES
            .iter()
            .find(|&each| {
                let ret: bool = if let Some(needed_ncurses)=try_link(each, &ncurses_lib, &lib_name) {
                    let extra:String=if needed_ncurses {
                        format!(", but needs '{}' to link without undefined symbols", lib_name)
                    } else {
                        "".to_string()
                    };
                    cargo_warn!("Using lib fallback '{}' which links successfully{}. The need for fallback suggests that you might be missing `pkg-config`/`pkgconf`.", each, extra);
                    println!("cargo:rustc-link-lib={}", each);
                    true
                } else { false };
                ret
            })
            .unwrap_or_else(|| &"")
            .to_string()
    };
    if IS_WIDE_AND_NOT_ON_MACOS
        && tinfo_name == "tinfo"
        && std::env::var("TINFOW_NO_PKG_CONFIG").is_ok()
    {
        cargo_warn!("Looks like you're using wide(and are not on macos) and you've set TINFOW_NO_PKG_CONFIG but have NOT set TINFO_NO_PKG_CONFIG too, so you're linking tinfo(no w) with other wide libs like ncursesw, which will cause '{}' eg. for example ex_5 when trying to run it. This is a warning not a panic because we assume you know what you're doing, and besides this works on Fedora (even if that env. var isn't set)!","Segmentation fault (core dumped)");
    }
    //TODO: test on macos-es. When not using the brew ncurses, it won't have A_ITALIC and BUTTON5_*
    //thus cursive will fail compilation. donedifferentlyTODO: detect this and issue cargo:warning from here.

    watch_env_var(ENV_VAR_NAME_FOR_NCURSES_RS_RUSTC_FLAGS);
    if let Ok(x) = std::env::var(ENV_VAR_NAME_FOR_NCURSES_RS_RUSTC_FLAGS) {
        println!("cargo:rustc-flags={}", x);
    }

    check_chtype_size(&ncurses_lib);

    //The code in src/genconstants.c uses initscr() of ncurses (see: $ man 3x initscr)
    //which depends on TERM env.var and will fail if TERM is wrong, say 'TERM=foo',
    //with: "Error opening terminal: foo." and exit code 1
    //therefore rebuild if TERM is changed without needing a 'cargo clean' first:
    watch_env_var("TERM");
    gen_rs(
        "src/genconstants.c",
        "genconstants",
        "raw_constants.rs",
        &ncurses_lib,
        &lib_name,
    );

    gen_rs(
        "src/menu/genconstants.c",
        "genmenuconstants",
        "menu_constants.rs",
        &ncurses_lib,
        &lib_name,
    );

    build_wrap(&ncurses_lib);
}
// -----------------------------------------------------------------

//TODO: look into how to make doc tests and if they'd work with build.rs
/// Creates file with the specified contents.
/// Any existing file with that name is lost.
/// Panics if file_name isn't prefixed by the value of OUT_DIR (at runtime) for extra safety.
fn overwrite_file_contents(file_name: &str, contents: &[u8]) {
    //Note: asserts in build.rs appear to be enabled even for cargo build --release, and can't be disabled(which is good, we want them on, always)
    assert!(
        file_name.starts_with(&get_out_dir()),
        "The file name you wanted to create '{}' should be created in OUT_DIR only",
        file_name
    );
    //FIXME: Maybe don't require utf-8 valid paths? by requiring &str here,
    //the caller would do PathBuf::display() which replaces '\xFF' with the placeholder char
    //which is the replacement character \u{FFFD}
    //Many other programs break at compile time if path contains non-utf8 chars, before we even get here!
    let mut file = File::create(file_name)
        .unwrap_or_else(|err| panic!("Couldn't create file '{}', reason: '{}'", file_name, err));

    file.write_all(contents).unwrap_or_else(|err| {
        panic!(
            "Couldn't write contents to file '{}', reason: '{}'",
            file_name, err
        )
    });
    drop(file); //explicit file close, not needed since it's in a function now!
}

fn get_out_dir() -> &'static str {
    use std::sync::OnceLock;
    static LOCK: OnceLock<String> = OnceLock::new();

    //OUT_DIR is set by cargo during build
    const ENV_NAME_OF_OUT_DIR: &str = "OUT_DIR";
    LOCK.get_or_init(|| {
        env::var(ENV_NAME_OF_OUT_DIR).unwrap_or_else(|err| {
            panic!(
                "Cannot get env.var. '{}', reason: '{}'. Use `cargo build` instead of running this build script binary directly!",
                ENV_NAME_OF_OUT_DIR, err
            )
        })
    })
    //^ Rust automatically coerces the &String reference to a &str reference, making the function return type &'static str valid without any additional explicit conversion. This behavior is possible due to Deref coercion.
}

/// Tries to see if linker can find/link with the named library, to create a binary.
/// Uses ncurses lib searchdirs(if any found by pkg-config) to find that lib.
/// This is mainly used when pkg-config is missing.
/// Should still work if pkg-config exists though(except it will be missing the found link searchdirs and thus might fail? TODO: test this on NixOS, with NCURSES(W)_NO_PKG_CONFIG=1 env.var, for something like menu(w) or panel(w) )
/// Returns Some(nn) if linking succeeded, None otherwise, nn is a bool saying if ncurses was needed to can link.
/// Will try to link twice if linking with only that lib fails, the second try adds ncurses lib to
/// linking command, because the lib might depend on it even though it doesn't say(inside it) that
/// it does (this is what happens on OpenBSD).
fn try_link(
    lib_name: &str,
    ncurses_lib: &Option<Library>,
    ncurses_lib_name_to_use: &str,
) -> Option<bool> {
    let out_dir = get_out_dir();
    assert!(
        !ncurses_lib_name_to_use.is_empty(),
        "You passed empty ncurses lib name string."
    );

    //We won't execute it though, so doesn't matter if it's .exe for Windows
    let out_bin_fname = format!("try_link_with_{}", lib_name);

    //we'll generate this .c file with our contents
    let out_src_full = Path::new(&out_dir)
        .join(format!("{}.c", out_bin_fname))
        .display()
        .to_string();

    let source_code = b"int main(void) { return 0; }";
    overwrite_file_contents(&out_src_full, source_code);
    //TODO: remove commented out code everywhere in build.rs

    let build = cc::Build::new();
    let mut linker_searchdir_args: Vec<String> = Vec::new();
    //Add linker paths from ncurses lib, if any found! ie. -L
    //(this likely will be empty if pkg-config doesn't exist)
    //Include paths(for headers) don't matter! ie. -I
    //Presumably the other libs(menu,panel,tinfo) are in the same dir(s) as the ncurses lib,
    //because they're part of ncurses even though they're split on some distros/OSs.
    if let Some(lib) = ncurses_lib {
        for link_path in &lib.link_paths {
            linker_searchdir_args.push("-L".to_string());
            linker_searchdir_args.push(link_path.display().to_string());
        }
    }

    let mut command = get_the_compiler_command_from_build(build);

    let out_bin_full = Path::new(&out_dir)
        .join(out_bin_fname)
        .display()
        .to_string();
    //Create a bin(not a lib) from a .c file
    //though it wouldn't matter here if it's bin or lib, I'm
    //not sure how to find its exact output name after, to delete it.
    //Adding the relevant args for the libs that we depend upon such as ncurses
    //
    //First we try to link just the requested lib, eg. 'menu' or 'panel' or 'tinfo'
    //if this fails, then we try adding 'ncurses' to libs to link, thus
    //on OpenBSD for example, where libmenu doesn't say it depends on the 'ncurses' lib
    //it can link successfully because we manually link with it, thus linker won't fail with unresolved symbols.
    command
        .arg("-o")
        .arg_checked(&out_bin_full)
        .arg_checked(&out_src_full)
        .args_checked(["-l", lib_name]) //this might require the ncurses lib below(on openbsd for sure!)
        .args_checked(linker_searchdir_args);
    //this copy will link only the lib, without ncurses
    let mut command_copy: Command = Command::new(command.get_program()); //FIXME:command.make_a_partial_copy();//woulda been too easy if had .clone()
    command_copy.args_checked(command.get_args()); //FIXME: temp

    //we add ncurses to linked libs, but we only call this if the first try(ie. that copy) fails.
    command.args_checked(["-l", ncurses_lib_name_to_use]);
    let exit_status = command_copy.status_or_panic(); //runs compiler
    let mut ret: bool = exit_status.success();
    let mut requires_ncurses_lib: bool = false;
    if !ret {
        //first try failed, try second with -lncurses(w) added.
        let exit_status = command.status_or_panic(); //runs compiler
        ret = exit_status.success();
        if ret {
            //cargo_warn!("");
            requires_ncurses_lib = true;
        }
    }

    if DELETE_GENERATEDS {
        if ret {
            //delete temporary bin that we successfully generated
            std::fs::remove_file(&out_bin_full).unwrap_or_else(|err| {
                panic!(
                    "Cannot delete generated bin file '{}', reason: '{}'",
                    out_bin_full, err
                )
            });
        }
        //delete the .c that we generated
        std::fs::remove_file(&out_src_full).unwrap_or_else(|err| {
            panic!(
                "Cannot delete generated C file '{}', reason: '{}'",
                out_src_full, err
            )
        });
    }

    return if ret {
        Some(requires_ncurses_lib)
    } else {
        None
    };
}

//TODO: change this to apply to anything that's emitted for cargo to consume, except warnings, and
//make it HashMap with a counter.
/// Emits "cargo:rerun-if-env-changed=ENV_VAR" on stdout
/// only once for each ENV_VAR
/// regardless of how many times it gets called.
fn watch_env_var(env_var: &'static str) {
    assert!(!env_var.is_empty(), "Passed empty env.var. to watch for.");
    use std::collections::HashSet;
    use std::sync::OnceLock;
    use std::sync::{Arc, RwLock};
    // static gets inited only once before main() and is scoped only to this function
    static SHARED_DATA: OnceLock<Arc<RwLock<HashSet<&'static str>>>> = OnceLock::new();
    //the inner value (hashset) is inited only once on first call of this function
    let hs = SHARED_DATA.get_or_init(|| Arc::new(RwLock::new(HashSet::new())));
    // Acquire a write lock to atomically check and insert if necessary
    if let Ok(mut guard) = hs.write() {
        // Critical section where the lock is held
        if !guard.contains(env_var) {
            println!("cargo:rerun-if-env-changed={}", env_var);
            guard.insert(env_var);
        }
    } //lock released here

    //TODO: can use HashMap(since HashSet I hear is just a HashMap underneath) and keep a counter as val
    //this way we'd know how many times an env.var. tried to be emitted, but for what reason we'd
    //wanna know though...
}

/// set some sensible defaults
fn new_build(lib: &Option<Library>) -> cc::Build {
    //XXX: Note: env.var. "CC" can override the compiler used and will cause rebuild if changed.
    let mut build = cc::Build::new();
    if let Some(lib) = lib {
        //header file paths eg. for ncurses.h
        build.includes(&lib.include_paths);
        //for path in lib.include_paths.iter() {
        //    build.include(path);
        //}
    }
    build.opt_level(1); //else is 0, causes warning on NixOS: _FORTIFY_SOURCE requires compiling with optimization (-O)

    //XXX:Don't have to emit cargo:rerun-if-env-changed= here because try_flags_from_environment()
    //below does it for us, however it does it on every call! (unless Build::emit_rerun_if_env_changed(false))
    //but if an overriding variant of it is defined like NCURSES_RS_CFLAGS_x86_64_unknown_linux_gnu
    //then this weaker one won't be emitted because the override will be the only one in effect.
    //We could forcefully emit anyway, but no point, it will be ignored and just rebuild for no reason.
    //watch_env_var(ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS);

    //See comment above the const var def. to understand which env.vars are tried here:
    let _ = build.try_flags_from_environment(ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS);

    //these two are already in from the default Build
    //build.flag_if_supported("-Wall");
    //build.flag_if_supported("-Wextra");
    build.flag_if_supported("-Wpedantic");
    //build.flag_if_supported("-Wstrict-prototypes");//maybe fix me: triggers warnings in wrap.c
    build.flag_if_supported("-Weverything"); //only clang

    return build; // explicit return makes it more obvious that the ";" is missing so it's a return!
}

fn build_wrap(ncurses_lib: &Option<Library>) {
    // build.file(source_file), below, doesn't emit this:
    println!("cargo:rerun-if-changed=src/wrap.c");
    let mut build = new_build(ncurses_lib);

    // The following creates `libwrap.a` on linux, a static lib
    build.file("src/wrap.c").compile("wrap");
    //the resulting lib will be kept until deleted by 'cargo clean'
}

fn get_the_compiler_command_from_build(build: cc::Build) -> std::process::Command {
    //'cc::Build' can do only lib outputs but we want a binary
    //so we get the command (and args) thus far set and add our own args.
    //Presumably all args will be kept, as per: https://docs.rs/cc/1.0.92/cc/struct.Build.html#method.get_compiler
    //(though at least the setting for build.file(source_c_file) won't be,
    // but we don't use that way and instead set it later as an arg to compiler)
    let compiler = build
        .try_get_compiler()
        .expect("Failed Build::try_get_compiler");
    let command = compiler.to_command();
    return command;
}

/// Compiles an existing .c file, runs its bin to generate a .rs file from its output.
/// Uses ncurses include paths and links with ncurses lib(s)
// Note: won't link with tinfo unless pkg-config returned it.
// ie. if `pkg-config ncurses --libs` shows: -lncurses -ltinfo
// So even though we used a fallback tinfo in main, for cargo, it won't be used here. FIXME: if tinfo is needed here ever! (it's currently not, btw)
fn gen_rs(
    source_c_file: &str,
    out_bin_fname: &str,
    gen_rust_file: &str,
    ncurses_lib: &Option<Library>,
    lib_name: &str,
) {
    //TODO: see if build.file() already emits this!
    println!("cargo:rerun-if-changed={}", source_c_file);
    let out_dir = get_out_dir();
    #[cfg(windows)]
    let out_bin_fname = format!("{}.exe", out_bin_fname); //shadowed
    let bin_full = Path::new(&out_dir)
        .join(out_bin_fname)
        .display()
        .to_string();

    let build = new_build(ncurses_lib);
    let mut linker_searchdir_args: Vec<String> = Vec::new();
    if let Some(lib) = ncurses_lib {
        for link_path in &lib.link_paths {
            linker_searchdir_args.push("-L".to_string());
            linker_searchdir_args.push(link_path.display().to_string());
        }
    }

    let mut command = get_the_compiler_command_from_build(build);

    //create a bin(not a lib) from a .c file
    //adding the relevant args for the libs that we depend upon such as ncurses
    command
        .arg("-o")
        .arg_checked(&bin_full)
        .arg_checked(source_c_file)
        .args_checked(["-l", lib_name])
        .args_checked(linker_searchdir_args);
    command.success_or_panic(); //runs compiler

    //Execute the compiled binary, panicking if non-zero exit code, else compilation will fail
    //later with things like: "error[E0432]: unresolved import `constants::TRUE`" in the case of
    //generating raw_constants.rs which would be empty due to 'genconstants' having failed with exit
    //code 1 because env.var. TERM=a_terminal_not_in_term_database
    let output: std::process::Output = Command::new(&bin_full).output_success_or_panic();

    //Write the output from executing the binary into a new rust source file .rs
    //That .rs file is later used outside of this build.rs, in the normal build
    let gen_rust_file_full_path = Path::new(&out_dir)
        .join(gen_rust_file)
        .display()
        .to_string();
    overwrite_file_contents(&gen_rust_file_full_path, &output.stdout);
    //we ignore stderr.
    //we don't delete this file because it's used to compile the rest of the crate.
}

fn check_chtype_size(ncurses_lib: &Option<Library>) {
    let out_dir = get_out_dir();
    //FIXME: see if .display() is a good idea, maybe can avoid it.
    let src_full = Path::new(&out_dir)
        .join("chtype_size.c")
        .display()
        .to_string();
    let bin_name = if cfg!(windows) {
        "chtype_size.exe"
    } else {
        "chtype_size"
    };
    let bin_full = Path::new(&out_dir).join(bin_name).display().to_string();

    let contents = br#"// autogenerated by build.rs
#include <assert.h>
#include <limits.h>
#include <stdio.h>

#include <ncurses.h>

int main(void)
{
    if (sizeof(chtype)*CHAR_BIT == 64) {
        puts("cargo:rustc-cfg=feature=\"wide_chtype\"");
    } else {
        /* We only support 32-bit and 64-bit chtype. */
        assert(sizeof(chtype)*CHAR_BIT == 32 && "unsupported size for chtype");
    }

#if defined(NCURSES_MOUSE_VERSION) && NCURSES_MOUSE_VERSION == 1
    puts("cargo:rustc-cfg=feature=\"mouse_v1\"");
#endif
    return 0;
}
"#;
    overwrite_file_contents(&src_full, contents);

    let build = new_build(ncurses_lib);

    let mut command = get_the_compiler_command_from_build(build);

    command
        .arg("-o")
        .arg_checked(&bin_full)
        .arg_checked(&src_full);
    command.success_or_panic(); //runs compiler

    let features = Command::new(&bin_full).output_success_or_panic();

    //for cargo to consume
    print!("{}", String::from_utf8_lossy(&features.stdout));

    if DELETE_GENERATEDS {
        std::fs::remove_file(&src_full).unwrap_or_else(|err| {
            panic!(
                "Cannot delete generated C file '{}', reason: '{}'",
                src_full, err
            )
        });
        std::fs::remove_file(&bin_full).unwrap_or_else(|err| {
            panic!(
                "cannot delete compiled bin file '{}', reason: '{}'",
                bin_full, err
            )
        });
    }
}

//call this only once, to avoid re-printing "cargo:rustc-link-lib=" // FIXME
fn get_ncurses_lib_name(ncurses_lib: &Option<Library>) -> String {
    //Was it found(and thus printed) by pkg_config::probe_library() ?
    let mut already_printed: bool = false;
    let lib_name: String;
    watch_env_var(ENV_VAR_NAME_FOR_LIB);
    match std::env::var(ENV_VAR_NAME_FOR_LIB) {
        Ok(value) => lib_name = value,
        Err(_) => {
            if let Some(ref lib) = ncurses_lib {
                // if here, `pkg-config`(shell command) via pkg_config crate,
                // has found the ncurses lib (eg. via the `ncurses.pc` file)
                // You can get something like this ["ncurses", "tinfo"] as the lib.libs vector
                // but we shouldn't assume "ncurses" is the first ie. lib.libs[0]
                // and the exact name of it can be ncurses,ncursesw,ncurses5,ncursesw5 ...
                // so find whichever it is and return that:
                let substring_to_find = "curses";
                if let Some(found) = lib.libs.iter().find(|&s| s.contains(substring_to_find)) {
                    //If we're here, the function calls to pkg_config::probe_library()
                    //from above ie. through find_library(), have already printed these:
                    //   cargo:rustc-link-lib=ncurses
                    //   cargo:rustc-link-lib=tinfo
                    //so there's no need to re-print the ncurses line as it would be the same.
                    already_printed = true;
                    lib_name = found.clone();
                } else {
                    // Construct the repeated pkg-config command string
                    let repeated_pkg_config_command: String = NCURSES_LIB_NAMES
                        .iter()
                        .map(|ncurses_lib_name| format!("pkg-config --libs {}", ncurses_lib_name))
                        .collect::<Vec<_>>()
                        .join("` or `");

                    panic!(
                    "pkg_config(crate) reported that it found the ncurses lib(s) but the substring '{}' was not among them, ie. in the output of the shell command(s) eg. `{}`\n
                    Try setting NCURSES_NO_PKG_CONFIG=1 and/or NCURSESW_NO_PKG_CONFIG=1 to disable pkg-config and thus allow for the fallback to lib name 'ncurses' respectively 'ncursesw' to be tried. Or fix ncurses.pc or ncursesw.pc file.",
                    substring_to_find,
                    repeated_pkg_config_command
                    );
                }
            } else {
                //pkg-config didn't find the lib, fallback to 'ncurses' or 'ncursesw'
                let what_lib = NCURSES_LIB_NAME_FALLBACK.to_string();
                // On FreeBSD it works without pkgconf and ncurses(6.4) installed but it will fail
                // to link ex_5 with 'menu' lib, unless `NCURSES_RS_RUSTC_FLAGS="-lmenu" is set.
                // this is why we now use fallbacks for 'menu' and 'panel` above too(not just for 'ncurses' lib)
                // that is, when pkgconf or pkg-config are missing, yet the libs are there.
                // Print the warning message, but use old style warning with one ":" not two "::",
                // because old cargos(pre 23 Dec 2023) will simply ignore it and show no warning if it's "::"
                cargo_warn!("Using (untested)fallback lib name '{}' but if compilation fails below(like when linking ex_5 with 'menu' feature), that is why. It's likely you have not installed one of ['pkg-config' or 'pkgconf'], and/or 'ncurses' (it's package 'ncurses-devel' on Fedora). This seems to work fine on FreeBSD 14 regardless, however to not see this warning and to ensure 100% compatibility(on any OS) be sure to install, on FreeBSD, at least `pkgconf` if not both ie. `# pkg install ncurses pkgconf`.", what_lib);
                //fallback lib name: 'ncurses' or 'ncursesw'
                //if this fails later, there's the warning above to get an idea as to why.
                lib_name = what_lib;
            }
        }
    };
    if !already_printed {
        //TODO: try_link() ? then refactor the warning messages. Well, now that try_link already links ncurses lib, this isn't needed? or if it is, don't specify -l twice for it inside try_link
        println!("cargo:rustc-link-lib={}", lib_name);
    }
    lib_name
}

//trait MyOutput {}
//
//impl MyOutput for std::process::Output {}

trait MyExitStatus {
    fn success_or_panic(self) -> ExitStatus;
}

impl MyExitStatus for std::process::ExitStatus {
    fn success_or_panic(self) -> ExitStatus {
        if self.success() {
            self
        } else {
            let how: String;
            if let Some(code) = self.code() {
                how = format!(" with exit code {}.", code);
            } else {
                how = ", was it terminated by a signal?!".to_string();
            }
            panic!(
                "!!! Compiler failed{} Is ncurses installed? \
        pkg-config or pkgconf too? \
        it's 'ncurses-devel' on Fedora; \
        run `nix-shell` first, on NixOS. \
        Or maybe it failed for different reasons which are seen in the errored output above.",
                how
            )
        }
    }
}

// Define an extension trait for Command
trait MyCompilerCommand {
    fn output_or_panic(&mut self) -> std::process::Output;
    fn output_success_or_panic(&mut self) -> std::process::Output;
    fn success_or_panic(&mut self) -> ExitStatus;
    //fn success_or_else<F: FnOnce(ExitStatus) -> ExitStatus>(&mut self, op: F) -> ExitStatus;
    fn just_status_or_panic(&mut self) -> ExitStatus;
    fn status_or_panic(&mut self) -> ExitStatus;
    fn status_or_panic_but_no_check_args(&mut self) -> ExitStatus;
    fn show_what_will_run(&mut self) -> &mut Self;
    fn get_program_or_panic(&self) -> &str;
    fn get_what_will_run(&self) -> (String, usize, String, Option<&Path>, String);
    fn assert_no_nul_in_args(&mut self) -> &mut Self;
    /// Panics if arg has \0 in it.
    fn args_checked<I, S>(&mut self, args: I) -> &mut Command
    where
        I: IntoIterator<Item = S>,
        S: AsRef<OsStr>;
    /// Panics if arg has \0 aka NUL in it,
    /// otherwise the original Command::arg would've set it to "<string-with-nul>"
    /// Doesn't do any other checks, passes it to Command::arg()
    fn arg_checked<S: AsRef<OsStr>>(&mut self, arg: S) -> &mut Command;
    fn panic<T: std::fmt::Display>(&mut self, err: T, what_type_of_command: &str) -> !;
    fn make_a_partial_copy(&self) -> Self;
}

fn has_null_byte<S: AsRef<OsStr>>(arg: S) -> bool {
    let os_str = arg.as_ref();
    for &byte in os_str.as_bytes() {
        if byte == 0 {
            return true;
        }
    }
    false
}

/// Args with \0 in them, passed to std::process::Command::arg() or ::args()
/// get replaced(by those calls)entirely with this: "<string-with-nul>"
const REPLACEMENT_FOR_ARG_THAT_HAS_NUL: &str = "<string-with-nul>";
// Implement the extension trait for Command, so you can use methods on a Command instance even
// though it's a type that's not defined here but in std::process
impl MyCompilerCommand for std::process::Command {
    /// Executes Command::output() and gives you Output struct or panics
    /// but the exit code may not have been 0
    fn output_or_panic(&mut self) -> std::process::Output {
        self.output().unwrap_or_else(|err| {
            self.panic(err, "generated bin"); //TODO: let caller provide this
        })
    }

    /// Executes Command::output() and gives you Output struct or panics
    /// also panics if exit code was not 0 and shows you stdout/stderr if so.
    fn output_success_or_panic(&mut self) -> std::process::Output {
        let output = self.output_or_panic();
        // test this with: `$ TERM=foo cargo build`
        let show_stdout_stderr = || {
            //XXX: presumably eprintln! and std::io::stderr().write_all().unwrap() write to same stderr
            //stream and both would panic if some error would happen when writing to it!
            eprintln!("But here's its stdout&stderr:");
            eprintln!("|||stdout start|||");
            //Preserve stdout/stderr bytes, instead of lossily convert them to utf-8 before showing them.
            //show stdout of executed binary, on stderr
            std::io::stderr().write_all(&output.stdout).unwrap();
            eprintln!("\n|||stdout end||| |||stderr start|||");
            //show stderr of executed binary, on stderr
            std::io::stderr().write_all(&output.stderr).unwrap();
            eprintln!("\n|||stderr end|||");
        };
        let prog = self.get_program_or_panic();
        let and_panic = || -> ! {
            panic!(
                "due to the above-reported error while executing '{}'.",
                prog
            );
        };

        let exit_code = output.status.code().unwrap_or_else(|| {
            //we get here if it segfaults(signal 11), so if exited due to signal
            //but unsure if we get here for any other reasons!
            //To test this branch uncomment a segfault line early in src/genconstants.c then `cargo build`

            let basename=Path::new(prog).file_name().unwrap_or_else(|| {
                eprintln!("Couldn't get basename for '{}'", prog);
                OsStr::new("") //refusing to panic over this
            });
            let basename=basename.to_str().unwrap_or_else(|| {
                eprintln!("Couldn't convert OsStr '{:?}' to &str", basename);
                "" //refusing to panic over this
            });
            eprintln!(
                "!!! Execution of '{}' failed, likely killed by signal! Maybe check 'dmesg' for the word \"segfault\" or \"{}\". We can't know here, which signal happened.",
                prog, basename
                );
            show_stdout_stderr();
            and_panic();
        });
        if 0 != exit_code {
            eprintln!(
                "!!! Execution of '{}' failed with exit code '{}'",
                prog, exit_code
            );
            show_stdout_stderr();
            eprintln!(
                //FIXME: this msg can't be part of the (future)extension trait impl, it's for src/genconstants.c only.
                "!! Maybe you need to try a different value for the TERM environment variable !!"
            );
            and_panic();
        } else {
            return output;
        }
    }

    /// Executes Command::status().success() and panics if it any fail
    /// This means exit code 0 is ensured.
    /// Note: You can't use an arg value "<string-with-nul>", or this will panic.
    fn success_or_panic(&mut self) -> ExitStatus {
        let exit_status: ExitStatus = self.status_or_panic().success_or_panic();
        exit_status
    }

    //XXX: can't override arg/args because they're not part of a Trait in Command
    //so would've to wrap Command in my own struct for that. This would've ensured
    //that any added args were auto-checked.
    /// panics if any args have \0 aka nul in it, else Command will panic later, on execution.
    fn args_checked<I, S>(&mut self, args: I) -> &mut Command
    where
        I: IntoIterator<Item = S>,
        S: AsRef<OsStr>,
    {
        for arg in args {
            self.arg_checked(arg.as_ref());
        }
        self
    }

    /// panics if arg has \0 aka nul in it, else Command will panic later, on execution.
    fn arg_checked<S: AsRef<OsStr>>(&mut self, arg: S) -> &mut Command {
        if has_null_byte(&arg) {
            //If the arg has NUL ie. \0  in it then arg got replaced already
            //with "<string-with-nul>", internally, by std::process::Command::arg() .
            //The found arg here will be shown with \0 in this Debug way.
            panic!(
                "Found arg '{:?}' that has at least one \\0 aka nul in it! \
                   This would've been replaced with '{}'.",
                arg.as_ref(),
                REPLACEMENT_FOR_ARG_THAT_HAS_NUL
            );
        }
        self.arg(arg)
    }

    /// Beware if user set the arg on purpose to the value of REPLACEMENT_FOR_ARG_THAT_HAS_NUL
    /// which is "<string-with-nul>" then this will panic, it's a false positive.
    fn assert_no_nul_in_args(&mut self) -> &mut Self {
        let args = self.get_args();
        for (count, arg) in args.enumerate() {
            if let Some(fully_utf8_arg) = arg.to_str() {
                //If the arg had NUL ie. \0  in it then arg got replaced already
                //with "<string-with-nul>", internally, by std::process::Command::arg() .
                if fully_utf8_arg == REPLACEMENT_FOR_ARG_THAT_HAS_NUL {
                    panic!(
                        "Found arg number '{}' that has \\0 aka NUL in it! \
                           It got replaced with '{}'.",
                        count + 1,
                        REPLACEMENT_FOR_ARG_THAT_HAS_NUL
                    );
                }
            }
        }
        self
    }

    fn get_program_or_panic(&self) -> &str {
        let program = self.get_program();
        let p_prog = program
            .to_str()
            .unwrap_or_else(|| panic!("Compiler executable {:?} isn't valid rust string", program));
        //TODO: "Compiler" is too specific here, could be we're running just a bin we created!
        p_prog
    }

    fn get_what_will_run(&self) -> (String, usize, String, Option<&Path>, String) {
        let p_prog = self.get_program_or_panic();
        let args = self.get_args();
        let how_many_args: usize = args.len();
        let formatted_args: String = args
            .map(|arg| {
                //If the arg had NUL ie. \0  in it then arg got replaced already
                //with "<string-with-nul>", internally, by std::process::Command::arg()
                //if it was added via Command::arg() or Command::args().
                //To prevent that use Command::arg_checked() and ::args_checked()
                if let Some(fully_utf8_arg) = arg.to_str() {
                    fully_utf8_arg.to_string()
                } else {
                    //None aka not fully utf8 arg
                    //then we show it as ascii + hex
                    let mut broken_arg = String::new();
                    //use std::fmt::Write; // can't globally import this ^, conflicts with std::io::Write
                    for byte in arg.as_bytes() {
                        match std::char::from_u32(*byte as u32) {
                            Some(c) if c.is_ascii() => broken_arg.push(c),
                            _ => {
                                write!(&mut broken_arg, "\\x{:02X}", byte).expect("Failed to write")
                            }
                        }
                    }
                    broken_arg
                }
            })
            .collect::<Vec<String>>()
            .join("\" \"");
        //TODO: maybe a better way to get the args as a Vec<String> and impl Display ? but not
        //for the generic Vec<String> i think. Then, we won't have to return how_many_args!

        let cur_dir = self.get_current_dir();
        let env_vars: Vec<(&OsStr, Option<&OsStr>)> = self.get_envs().collect();
        let mut formatted_env_vars = String::new(); //empty string if no env vars set
        if !formatted_env_vars.is_empty() {
            for (key, value) in env_vars {
                match value {
                    Some(value) => formatted_env_vars.push_str(&format!(
                        "(set) {}={}\n",
                        key.to_string_lossy(),
                        value.to_string_lossy()
                    )),
                    None => {
                        formatted_env_vars.push_str(&format!("(del) {}\n", key.to_string_lossy()))
                    } // Key was removed
                }
            }
        };
        //FIXME: make this a struct so the order doesn't get confused in callers.
        //return this tuple
        (
            p_prog.to_string(),
            how_many_args,
            format!("\"{}\"", formatted_args),
            cur_dir,
            formatted_env_vars,
        )
    }

    /// just like Command::status() but panics if it can't execute it,
    /// ie. if status() would've returned an Err
    /// returns ExitStatus whether it be 0 or !=0
    /// Doesn't show you what will be executed and doesn't check args.
    /// (not meant to be used outside)
    fn just_status_or_panic(&mut self) -> ExitStatus {
        // Call the original status() method and handle the potential error
        self.status().unwrap_or_else(|err| {
            self.panic(err, "compilation"); //TODO: let caller provide this?!
        })
    }

    /// Shows command that will execute and checks args, only after this
    /// it's gonna be trying to do .status()
    /// Panics if status would've returned an Err
    fn status_or_panic(&mut self) -> ExitStatus {
        self.show_what_will_run()
            .assert_no_nul_in_args()
            .just_status_or_panic()
    }

    /// Used only for build.rs tests:
    /// this should be exactly like status_or_panic() except it won't check that args
    /// aren't nul-containing and thus won't panic before the original status() gets run, thus
    /// allowing it to panic on nul.
    /// (not meant to be used outside)
    fn status_or_panic_but_no_check_args(&mut self) -> ExitStatus {
        self.show_what_will_run().just_status_or_panic()
    }

    /// (not meant to be used outside)
    fn panic<T: std::fmt::Display>(&mut self, err: T, what_type_of_command: &str) -> ! {
        let (p_prog, how_many_args, formatted_args, _cur_dir, _envs) = self.get_what_will_run();
        let extra_space = if what_type_of_command.is_empty() {
            ""
        } else {
            " "
        };
        panic!(
            "Failed to run {}{}command '{}' with '{}' args: '{}', reason: '{}'",
            what_type_of_command, extra_space, p_prog, how_many_args, formatted_args, err
        )
    }

    /// shows on stderr, which command will be executed.
    fn show_what_will_run(&mut self) -> &mut Self {
        let (exe_name, how_many_args, formatted_args, cur_dir, formatted_env_vars) =
            self.get_what_will_run();
        let cur_dir: String = if let Some(dir) = cur_dir {
            format!(", in current dir: '{}'", dir.display())
        } else {
            ", in unspecified current dir".to_string()
        };
        let formatted_env_vars: String = if formatted_env_vars.is_empty() {
            ", with no extra env.vars added or deleted".to_string()
        } else {
            format!(", with env.vars: '{}'", formatted_env_vars)
        };
        eprintln!(
            "!! Next, attempting to run command '{}' with '{}' args: '{}'{}{}.",
            exe_name, how_many_args, formatted_args, cur_dir, formatted_env_vars
        );
        self
    }

    fn make_a_partial_copy(&self) -> Self {
        let prog=self.get_program();
        let mut r#new=Command::new(prog);
        r#new.args_checked(self.get_args());
        r#new.envs(self.get_envs().collect());
        r#new.current_dir(self.get_current_dir());

        r#new
    }
}

/// This is used to test build.rs, run with: cargo build --features=test_build_rs_of_ncurses_rs
/// This won't happen if you use --all-features
#[cfg(all(
    feature = "test_build_rs_of_ncurses_rs",
    not(feature = "dummy_feature_to_detect_that_--all-features_arg_was_used")
))]
fn main() {
    test_assert_works();
    test_invalid_utf8_in_program();
    test_nul_in_arg_unchecked();
    test_nul_in_arg();
    test_no_panic_in_command();
    test_panic_for_not_found_command();
    test_panic_for_command_non_zero_exit();
    test_get_what_will_run();
    test_assert_no_nul_in_args();

    eprintln!("\n-------------------------------------
              \n!!! All build.rs tests have passed successfully! Ignore the above seemingly erroneous output, it was part of the successful testing !!!\nYou're seeing this because you tried to build with --features=test_build_rs_of_ncurses_rs");

    // This stops the build from continuing which will fail in other places due to build.rs not
    // doing its job, since we've only just tested build.rs not used it to generate stuff.
    std::process::exit(5);
}
//The test functions are left outside of 'test_build_rs_of_ncurses_rs' feature gate
//so that they're tested to still compile ok.

#[allow(dead_code)]
fn test_assert_works() {
    let result = std::panic::catch_unwind(|| {
        #[allow(clippy::assertions_on_constants)]
        {
            assert!(false, "!! just tested if asserts are enabled !!");
        }
    });
    #[allow(clippy::manual_assert)]
    if result.is_ok() {
        panic!("Assertions are disabled in build.rs, should not happen!");
    }
}

#[allow(dead_code)]
fn test_no_panic_in_command() {
    let expected_ec = 42;
    let cmd = if cfg!(windows) { "cmd" } else { "sh" };
    let args_ok = &["-c", "exit 0"];
    let args_fail = &["-c", &format!("exit {}", expected_ec)];
    let result = std::panic::catch_unwind(|| {
        let mut command = Command::new(cmd);
        command.args(args_ok);
        //execute: sh -c 'exit 0'`
        command.status_or_panic();
    });
    let fail_msg = format!(
        "!!! This should not have panicked! Unless you don't have '{}' command, in PATH={:?} !!!",
        cmd,
        std::env::var("PATH")
    );
    assert!(result.is_ok(), "{}", fail_msg);

    // executed bin exits with exit code 0, or it would panic ie. fail the test
    let result = std::panic::catch_unwind(|| {
        let mut command = Command::new(cmd);
        command.args(args_ok);
        //execute: sh -c 'exit 0'`
        command.success_or_panic();
    });
    assert!(result.is_ok(), "{}", fail_msg);

    // executed bin exits with specific exit code 2
    let result = std::panic::catch_unwind(|| {
        let mut command = Command::new(cmd);
        command.args(args_fail);
        //execute: sh -c 'exit 42'`
        let exit_status = command.status_or_panic();
        assert_eq!(
            exit_status.code().expect("was command killed by a signal?"),
            expected_ec,
            "Command should've exited with exit code '{}'.",
            expected_ec
        );
    });
    assert!(result.is_ok(), "{}", fail_msg);
}

#[allow(dead_code)]
fn test_panic_for_not_found_command() {
    let result = std::panic::catch_unwind(|| {
        let mut command = Command::new("some non-exitent command");
        command.args([OsString::from("ar♥g1")]);
        command.status_or_panic();
    });
    let expected_panic_msg=
     "Failed to run compilation command 'some non-exitent command' with '1' args: '\"ar♥g1\"', reason: 'No such file or directory (os error 2)'";
    expect_panic(result, expected_panic_msg);

    let result = std::panic::catch_unwind(|| {
        let mut command = Command::new("some non-exitent command");
        command.args([OsString::from("ar♥g1")]);
        command.success_or_panic();
    });
    expect_panic(result, expected_panic_msg);
}

#[allow(dead_code)]
fn test_panic_for_command_non_zero_exit() {
    let cmd = if cfg!(windows) { "cmd" } else { "sh" };
    let args_fail = &["-c", &format!("exit 43")];
    let result = std::panic::catch_unwind(|| {
        let mut command = Command::new(cmd);
        command.args(args_fail);
        command.success_or_panic();
    });
    let expected_panic_msg = "!!! Compiler failed with exit code 43. Is ncurses installed? pkg-config or pkgconf too? it's 'ncurses-devel' on Fedora; run `nix-shell` first, on NixOS. Or maybe it failed for different reasons which are seen in the errored output above.";
    expect_panic(result, expected_panic_msg);
}

#[allow(dead_code)]
fn test_invalid_utf8_in_program() {
    let result = std::panic::catch_unwind(|| {
        let mut command = Command::new(OsString::from_vec(
            b"test_invalid_utf8_\xFFin_program".to_vec(),
        ));
        command.args([
            OsString::from("ar♥g1"),
            OsString::from_vec(b"my\xffarg3".to_vec()),
        ]);
        command.status_or_panic();
    });
    expect_panic(
        result,
        "Compiler executable \"test_invalid_utf8_\\xFFin_program\" isn't valid rust string",
    );
}

fn expect_panic(result: Result<(), Box<dyn std::any::Any + Send>>, expected_panic_message: &str) {
    if result.is_err() {
        if let Some(err) = result.unwrap_err().downcast_ref::<String>() {
            // Uncomment this to can copy/paste it for asserts:
            //println!("!!!!!!!!!! Panic message: {:?}", err);
            assert_eq!(
                err, expected_panic_message,
                "!!! Got different panic message than expected !!!"
            );
        }
    } else {
        panic!(
            "No panic was thrown! But was expecting this panic: '{}'",
            expected_panic_message
        );
    };
}

#[allow(dead_code)]
fn test_nul_in_arg_unchecked() {
    let result = std::panic::catch_unwind(|| {
        let mut command = Command::new("test_nul_in_arg_unchecked.exe");
        command.args([
            OsString::from("ar♥g1"),
            OsString::from("a\0rg2"),
            OsString::from_vec(b"my\xffarg3".to_vec()),
        ]);
        command.status_or_panic_but_no_check_args();
    });
    expect_panic(result,
         "Failed to run compilation command 'test_nul_in_arg_unchecked.exe' with '3' args: '\"ar♥g1\" \"<string-with-nul>\" \"my\\xFFarg3\"', reason: 'nul byte found in provided data'"
        );
}

#[allow(dead_code)]
fn test_nul_in_arg() {
    //via .arg()
    let result = std::panic::catch_unwind(|| {
        let mut command = Command::new("test_nul_in_arg.exe");
        command.arg_checked(OsString::from("ar♥g1"));
        command.arg_checked(
            // would panic here
            OsString::from("a\0rg2"),
        );
        command.arg_checked(OsString::from_vec(b"my\xffarg3".to_vec()));
        command.status_or_panic();
    });
    let expected_panic_msg=
         "Found arg '\"a\\0rg2\"' that has at least one \\0 aka nul in it! This would've been replaced with '<string-with-nul>'.";
    expect_panic(result, expected_panic_msg);
    //via .args()
    let result = std::panic::catch_unwind(|| {
        let mut command = Command::new("test_nul_in_args.exe");
        command.args_checked([
            // would panic here
            OsString::from("ar♥g1"),
            OsString::from("a\0rg2"),
            OsString::from_vec(b"my\xffarg3".to_vec()),
        ]);
        command.status_or_panic();
    });
    expect_panic(result, expected_panic_msg);
}

#[allow(dead_code)]
fn test_get_what_will_run() {
    let expected_prog = "test_get_what_will_run.exe";
    let mut command = Command::new(expected_prog);
    command.arg_checked(OsString::from("ar♥g1"));
    command.args_checked([
        // would panic here
        OsString::from_vec(b"my\xffarg3".to_vec()),
        OsString::from("arg4"),
    ]);
    command.arg_checked(OsString::from_vec(b"my\xffarg3".to_vec()));
    let (prog, how_many_args, formatted_args, _cur_dir, _envs) = command.get_what_will_run();
    let expected_hma = 4;
    let expected_fa = "\"ar♥g1\" \"my\\xFFarg3\" \"arg4\" \"my\\xFFarg3\"";
    assert_eq!(prog, expected_prog);
    assert_eq!(how_many_args, expected_hma);
    assert_eq!(formatted_args, expected_fa);
}

#[allow(dead_code)]
fn test_assert_no_nul_in_args() {
    let expected_prog = "test_get_what_will_run.exe";
    let result = std::panic::catch_unwind(|| {
        let mut command = Command::new(expected_prog);
        command.arg("a\0here");
        command.assert_no_nul_in_args();
    });
    expect_panic(
        result,
        r##"Found arg number '1' that has \0 aka NUL in it! It got replaced with '<string-with-nul>'."##,
    );

    let result = std::panic::catch_unwind(|| {
        let mut command = Command::new(expected_prog);
        command.arg("no nul in this arg here");
        command.assert_no_nul_in_args();
    });
    assert!(result.is_ok(), "!!! This should not have panicked !!!");
}
