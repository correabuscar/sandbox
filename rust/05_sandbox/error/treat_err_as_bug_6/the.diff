diff --git a/.gitignore b/.gitignore
index d133873..c53cd36 100644
--- a/.gitignore
+++ b/.gitignore
@@ -3,3 +3,4 @@ bin
 Cargo.lock
 .*
 *.swp
+rustc-ice-*.txt
diff --git a/Cargo.toml b/Cargo.toml
index a2b2d6f..96a1d79 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -12,7 +12,7 @@ license = "MIT"
 build = "build.rs"
 
 [build-dependencies]
-cc = "1.0.18"
+cc = "1.0.92"
 pkg-config = "0.3"
 
 [dependencies]
@@ -30,5 +30,9 @@ wide_chtype = []
 mouse_v1 = []
 extended_colors = ["wide"]
 
+#Internal features used in 'build.rs' only:
+test_build_rs_of_ncurses_rs = []
+dummy_feature_to_detect_that_--all-features_arg_was_used= []
+
 [lib]
 name = "ncurses"
diff --git a/build.rs b/build.rs
index 1489d53..63cb70e 100644
--- a/build.rs
+++ b/build.rs
@@ -1,132 +1,659 @@
+// To test some of build.rs' code correctness run:
+// cargo build --features=test_build_rs_of_ncurses_rs
+// when doing that, the following cfg_attr ensures there are no warnings about unused stuff.
+#![cfg_attr(
+    all(
+        feature = "test_build_rs_of_ncurses_rs",
+        not(feature = "dummy_feature_to_detect_that_--all-features_arg_was_used")
+    ),
+    allow(dead_code)
+)]
+#![allow(clippy::uninlined_format_args)] // or is it more readable inlined?
+
 extern crate cc;
 extern crate pkg_config;
 
 use pkg_config::Library;
 use std::env;
+use std::ffi::OsStr;
+use std::ffi::OsString;
+use std::fmt::Write as required_for_writeln_macro;
 use std::fs::File;
-use std::io::Write;
+use std::io::Write as required_for_write_all_function; //in File
+use std::os::unix::ffi::OsStrExt;
+use std::os::unix::ffi::OsStringExt;
 use std::path::Path;
 use std::process::Command;
+use std::process::ExitStatus;
+
+//Decide whether or not to delete .c and bin files generated by build.rs once they're not needed.
+//Defaulting to 'false' because it's a job for 'cargo clean' and
+//it might help with debugging build issues if we keep them around.
+//even if this were true, we're already keeping 'libwrap.a', so FIXME: if this is set true.
+const DELETE_GENERATEDS: bool = false;
+
+// Optional environment variables:
+
+// The below doc comment doesn't apply for these 2 env.vars:
+const ENV_VAR_NAME_FOR_LIB: &str = "NCURSES_RS_RUSTC_LINK_LIB";
+const ENV_VAR_NAME_FOR_NCURSES_RS_RUSTC_FLAGS: &str = "NCURSES_RS_RUSTC_FLAGS";
+
+/// Assuming we want env.var "NCURSES_RS_CFLAGS" here,
+/// and target==host and is "x86_64-unknown-linux-gnu"
+/// then calls to Build::try_flags_from_environment() below in code,
+/// will try the following env.vars in this order:
+/// 1. "NCURSES_RS_CFLAGS_x86_64-unknown-linux-gnu" (notice dashes)
+/// 2. "NCURSES_RS_CFLAGS_x86_64_unknown_linux_gnu" (notice underscores)
+/// 3. "HOST_NCURSES_RS_CFLAGS" or "TARGET_NCURSES_RS_CFLAGS" (if target!=host)
+/// 4. "NCURSES_RS_CFLAGS" (our original wanted)
+/// and the first one that exists is used instead.
+/// see: https://docs.rs/cc/1.0.92/src/cc/lib.rs.html#3571-3580
+/// All of the _tried_ ones are emitted as: cargo:rerun-if-env-changed=
+/// which means, if NCURSES_RS_CFLAGS_x86_64_unknown_linux_gnu is set then NCURSES_RS_CFLAGS won't
+/// be emitted which makes sense as this one overrides the rest anyway.
+const ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS: &str = "NCURSES_RS_CFLAGS";
+
+const IS_WIDE: bool = cfg!(feature = "wide");
+const IS_MACOS: bool = cfg!(target_os = "macos");
+// Why also not on macos? see: https://github.com/jeaye/ncurses-rs/issues/151
+const IS_WIDE_AND_NOT_ON_MACOS: bool = IS_WIDE && !IS_MACOS;
 
+// Will search for these lib names and if not found via pkg-config
+// then use the fallback name and still try linking with it
+// because in most cases it will work anyway.
+const NCURSES_LIB_NAME_FALLBACK: &str = if IS_WIDE_AND_NOT_ON_MACOS {
+    "ncursesw"
+} else {
+    "ncurses"
+};
+const NCURSES_LIB_NAMES: &[&str] = if IS_WIDE_AND_NOT_ON_MACOS {
+    &["ncursesw5", NCURSES_LIB_NAME_FALLBACK]
+} else {
+    &["ncurses5", NCURSES_LIB_NAME_FALLBACK]
+};
+
+const MENU_LIB_NAME_FALLBACK: &str = if IS_WIDE_AND_NOT_ON_MACOS {
+    "menuw"
+} else {
+    "menu"
+};
+const MENU_LIB_NAMES: &[&str] = if IS_WIDE_AND_NOT_ON_MACOS {
+    &["menuw5", MENU_LIB_NAME_FALLBACK]
+} else {
+    &["menu5", MENU_LIB_NAME_FALLBACK]
+};
+
+const PANEL_LIB_NAME_FALLBACK: &str = if IS_WIDE_AND_NOT_ON_MACOS {
+    "panelw"
+} else {
+    "panel"
+};
+const PANEL_LIB_NAMES: &[&str] = if IS_WIDE_AND_NOT_ON_MACOS {
+    &["panelw5", PANEL_LIB_NAME_FALLBACK]
+} else {
+    &["panel5", PANEL_LIB_NAME_FALLBACK]
+};
+
+const TINFO_LIB_NAMES: &[&str] = if IS_WIDE_AND_NOT_ON_MACOS {
+    //elements order here matters, because:
+    //Fedora has ncursesw+tinfo(without w) for wide!
+    //and -ltinfow fails to link on NixOS and Fedora! so -ltinfo must be used even tho wide.
+    //(presumably because tinfo doesn't depend on wideness?)
+    //NixOS has only ncursesw(tinfo is presumably inside it) but -ltinfo still works for it(it's a
+    //symlink to ncursesw lib)
+    //Gentoo has ncursesw+tinfow
+    //
+    //These are tried in order and first that links is selected:
+    &["tinfow5", "tinfow", "tinfo"]
+    //doneFIXME: here ^, user can have in env. this TINFOW_NO_PKG_CONFIG=1 (but not also TINFO_NO_PKG_CONFIG=1) which would cause seg fault on Gentoo because tinfo will be found&linked(instead of tinfow) with one or more of menuw,panelw,ncursesw eg. when doing example ex_5 (ie. menuw,ncursesw,tinfo(no w)); but on Fedora this ncursesw+tinfo(no w) makes sense(because tinfo(no w) has both inside it, somehow, i guess), so we can't really guard against this (well maybe with target_os but what if they change in the future...) instead maybe print a warning if w and non-w are mixed(but only for tinfo is needed), even though it will be a false warning on Fedora, well maybe it won't be if we also check if env. var is set TINFOW_NO_PKG_CONFIG.
+} else {
+    //no reason to ever fallback to tinfow here when not-wide!
+    //Fedora/Gentoo has ncurses+tinfo
+    //NixOS has only ncursesw(but works for non-wide), -ltinfo symlinks to ncursesw .so file)
+    //so 'tinfo' is safe fallback here.
+    &["tinfo5", "tinfo"]
+};
+//TODO: why are we trying the v5 of the lib first instead of v6 (which is the second/last in list),
+//was v5 newer than the next in list? is it so on other systems?
+//like: was it ever ncurses5 newer than ncurses ?
+//Since we're trying v5 and it finds it, it will use it and stop looking, even though the next one
+//might be v6
+//This is the commit that added this v5 then v6 way: https://github.com/jeaye/ncurses-rs/commit/daddcbb557169cfac03af9667ef7aefed19f9409
+
+/// finds and emits cargo:rustc-link-lib=
 fn find_library(names: &[&str]) -> Option<Library> {
     for name in names {
+        //cargo_warn!("Trying lib '{}'",name);
         if let Ok(lib) = pkg_config::probe_library(name) {
+            //cargo_warn!("Found lib '{}' '{:?}'",name, lib);
             return Some(lib);
         }
     }
     None
 }
 
-fn main() {
-    println!("cargo:rerun-if-env-changed=PKG_CONFIG_PATH");
+/// Emits the passed string(s) prefixed by 'cargo:warning=' on stdout,
+/// which cargo will transform into a warning.
+/// It acts like println!() macro, so you can call it the same way to do formatting!
+/// Will replace newlines in the warning message with spaces,
+/// otherwise the text after would not have been seen in the warning.
+macro_rules! cargo_warn {
+    ($($arg:tt)*) => {
+        cargo_warn_unformatted(format!("{}", format_args!($($arg)*)));
+    };
+}
 
-    let wide = cfg!(all(feature = "wide", not(target_os = "macos")));
+/// Pass the string to be emitted as a cargo warning.
+/// Presumably you've already used format!() on it.
+/// Will replace newlines in the warning message with spaces,
+/// otherwise the text after would not have been seen in the warning.
+fn cargo_warn_unformatted(warn_msg: String) {
+    // Replace '\r' with nothing
+    // Replace '\n' with space
+    let warn_msg = warn_msg.replace('\r', "").replace('\n', " ");
+    println!("cargo:warning={}", warn_msg);
+}
+// -----------------------------------------------------------------
+// This is the normal build.rs main(),
+// it's only disabled when you used: `cargo build --feature=test_build_rs_of_ncurses_rs`
+#[cfg(any(
+    not(feature = "test_build_rs_of_ncurses_rs"),
+    feature = "dummy_feature_to_detect_that_--all-features_arg_was_used"
+))]
+fn main() {
+    watch_env_var("PKG_CONFIG_PATH");
 
-    let ncurses_lib_names = if wide {
-        &["ncursesw5", "ncursesw"]
-    } else {
-        &["ncurses5", "ncurses"]
-    };
-    let ncurses_lib = find_library(ncurses_lib_names);
+    let ncurses_lib = find_library(NCURSES_LIB_NAMES);
+    // Gets the name of ncurses lib found by pkg-config, if it found any!
+    // else (warns and)returns the default one like 'ncurses' or 'ncursesw'
+    // and emits cargo:rustc-link-lib= for it unless already done.
+    let lib_name = get_ncurses_lib_name(&ncurses_lib);
+    //XXX: cargo seems to use --as-needed (arg for 'ld' linker) which isn't easy to figure out(had
+    //to replace /usr/bin/ld temporarily, it won't work with just setting PATH because cc calls
+    //sibbling ld disregarding PATH), but this means the order in which
+    //we try to find the libs here matters(in theory): now it's ncurses,menu,panel,tinfo
+    //Not entirely sure here if this will break things in practice(our case), as we previously used:
+    //menu,panel,tinfo,ncurses order
+    // https://wiki.gentoo.org/wiki/Project:Quality_Assurance/As-needed#Importance_of_linking_order
+    // So in theory(untested), if a bin linked with cargo and only used symbols from menu not from ncurses,
+    // and since menu wanted symbols from ncurses (like it does on OpenBSD), due to
+    // -Wl,--as-needed, ncurses lib won't be linked in final bin(because bin doesn't use symbols
+    // from it) thus cause the bin to fail with unresolved symbols at runtime.
+    // However, in practice, we're "lucky" that anything(presumably), any bin we make that uses out
+    // ncurses rust crate, will also use ncurses lib thus force it to be linked,
+    // thus menu or panel libs that require it will always have it.
 
+    //TODO: dedup, unmessify
+    //TODO: dedup warning msgs and see when to still emit them.
     if cfg!(feature = "menu") {
-        if wide {
-            find_library(&["menuw5", "menuw"]);
-        } else {
-            find_library(&["menu5", "menu"]);
+        if find_library(MENU_LIB_NAMES).is_none() {
+            let fallback_lib_name = MENU_LIB_NAME_FALLBACK;
+            //doneFIXME: on openbsd(at least), the 'menu' linking via try_link() (ie. just -lmenu)
+            //fails because it depends on ncurses also being linked in (via -lncurses)
+            //because 'menu' lib doesn't have ncurses as a dynamic lib need, as it does on other OS-es like Gentoo
+            //which you can see via readelf -d /usr/lib/libmenu.so.7.0 it's missing a line like:
+            //(NEEDED)             Shared library: [libncurses.so.6]
+            //which exists on Gentoo/NixOS for example.
+            //so we must link with ncurses lib on try_link() to avoid unresolved symbols
+            //from 'menu' lib (which,again, needs ncurses, but doesn't say(inside it) that it does)
+            //which also means we must know if we have to use ncurses lib override before even trying
+            //to link menu,panel,tinfo, and thus need to pass the ncurses lib name to try_link() as third arg.
+            if let Some(needed_ncurses) = try_link(fallback_lib_name, &ncurses_lib, &lib_name) {
+                let extra: String = if needed_ncurses {
+                    format!(", but needs '{}' to link without undefined symbols(known to be true on OpenBSD)", lib_name)
+                } else {
+                    "".to_string()
+                };
+                cargo_warn!("Using lib fallback '{}' which links successfully{}. The need for fallback suggests that you might be missing `pkg-config`/`pkgconf`.", fallback_lib_name, extra);
+            } else {
+                let feature_name = "menu";
+                cargo_warn!("Possibly missing lib for the '{}' feature, and couldn't find its fallback lib name '{}' but we're gonna use it anyway thus compilation is likely to fail below because of this. You might need installed ncurses and pkg-config/pkgconf to fix this.", feature_name, fallback_lib_name);
+            }
+            //We still try linking with it anyway, in case our try_link() code is somehow wrong,
+            //like it doesn't include some link searchdir paths that are somehow included
+            //otherwise. Or, as it used to happen before i fixed it: it fails to link because
+            //libmenu has undefined symbols if not also linked with libncurses which is what
+            //happens on openbsd; fixed now by always linking with libncurses via try_link() above
+            println!("cargo:rustc-link-lib={}", fallback_lib_name);
         }
     }
 
     if cfg!(feature = "panel") {
-        if wide {
-            find_library(&["panelw5", "panelw"]);
-        } else {
-            find_library(&["panel5", "panel"]);
+        if find_library(PANEL_LIB_NAMES).is_none() {
+            let fallback_lib_name = PANEL_LIB_NAME_FALLBACK;
+            if let Some(needed_ncurses) = try_link(fallback_lib_name, &ncurses_lib, &lib_name) {
+                let extra: String = if needed_ncurses {
+                    format!(", but needs '{}' to link without undefined symbols(known to be true on OpenBSD)", lib_name)
+                } else {
+                    "".to_string()
+                };
+                cargo_warn!("Using lib fallback '{}' which links successfully{}. The need for fallback suggests that you might be missing `pkg-config`/`pkgconf`.", fallback_lib_name, extra);
+            } else {
+                let feature_name = "panel";
+                cargo_warn!("Possibly missing lib for the '{}' feature, and couldn't find its fallback lib name '{}' but we're gonna use it anyway thus compilation is likely to fail below because of this. You might need installed ncurses and pkg-config/pkgconf to fix this.", feature_name, fallback_lib_name);
+            }
+            //We still try linking with it anyway, in case our try_link() code is somehow wrong,
+            //like it doesn't include some link searchdir paths that are somehow included
+            //otherwise.
+            println!("cargo:rustc-link-lib={}", fallback_lib_name);
         }
     }
 
-    match std::env::var("NCURSES_RS_RUSTC_LINK_LIB") {
-        Ok(x) => println!("cargo:rustc-link-lib={}", x),
-        _ => if ncurses_lib.is_none() {
-            println!("cargo:rustc-link-lib={}", ncurses_lib_names.last().unwrap())
-        }
+    //This comment block is about libtinfo.
+    //If pkg-config can't find it, use fallback: 'tinfo' or 'tinfow'
+    //if cargo can't find it it will ignore it gracefully - NO IT WON'T!
+    //if it can find it, it will link it.
+    //It's needed for ex_5 to can link  when pkg-config is missing,
+    //otherwise you get this: undefined reference to symbol 'noraw'
+    //Thus w/o this block, the following command would be needed to run ex_5
+    //$ NCURSES_RS_RUSTC_FLAGS="-ltinfo" cargo run --features=menu --example ex_5
+    //To emulate this even if you have pkg-config you can tell it to not do its job
+    // by setting these env. vars before the above command:
+    // $ NCURSES_NO_PKG_CONFIG=1 NCURSESW_NO_PKG_CONFIG=1 NCURSES5_NO_PKG_CONFIG=1 NCURSESW5_NO_PKG_CONFIG=1 the_rest_of_the_command_here
+    // Fedora and Gentoo are two that have both ncurses(w) and tinfo(w), ie. split,
+    // however Gentoo has ncurses+tinfo and ncursesw+tinfow,
+    // but Fedora has ncurses+tinfo and ncursesw+tinfo (see 'tinfo' is same! no w)
+    // NixOS has only ncursesw (tinfo is presumably inside?) but -lncurses -lncursesw -ltinfo work!
+    // but -ltinfow doesn't work! on NixOS and Fedora!
+    // On Gentoo -ltinfow works too!
+    // so when pkg-config is missing, how do we know which tinfo to tell cargo to link, if any!
+    // doneFIXME: ^ I guess we gonna have to compile own .c to link with tinfo to see if it fails or
+    // works!
+    let tinfo_name = if let Some(found) = find_library(TINFO_LIB_NAMES) {
+        let libs = found.libs;
+        assert_eq!(
+            libs.len(),
+            1,
+            "Unexpected pkg-config query for tinfo lib returned more than one lib: '{:?}'",
+            libs
+        );
+        libs.first()
+            .unwrap_or_else(|| {
+                panic!(
+                    "Unexpected panic on trying to get the first found tinfo lib string from: '{:?}'.",
+                    libs
+                )
+            })
+            .clone()
+    } else {
+        //None found; but at least on NixOS it works without any tinfo(it's inside ncursesw lib and tinfo/ncurses all symlink to that same ncursesw.so, except tinfow which doesn't exist but pkg-config points it to -lncursesw), so no need to warn that we didn't find any tinfo.
+        //Pick the tinfo lib to link with, as fallback,
+        //the first one that links successfully!
+        //The order in the list matters!
+        TINFO_LIB_NAMES
+            .iter()
+            .find(|&each| {
+                let ret: bool = if let Some(needed_ncurses)=try_link(each, &ncurses_lib, &lib_name) {
+                    let extra:String=if needed_ncurses {
+                        format!(", but needs '{}' to link without undefined symbols", lib_name)
+                    } else {
+                        "".to_string()
+                    };
+                    cargo_warn!("Using lib fallback '{}' which links successfully{}. The need for fallback suggests that you might be missing `pkg-config`/`pkgconf`.", each, extra);
+                    println!("cargo:rustc-link-lib={}", each);
+                    true
+                } else { false };
+                ret
+            })
+            .unwrap_or_else(|| &"")
+            .to_string()
+    };
+    if IS_WIDE_AND_NOT_ON_MACOS
+        && tinfo_name == "tinfo"
+        && std::env::var("TINFOW_NO_PKG_CONFIG").is_ok()
+    {
+        cargo_warn!("Looks like you're using wide(and are not on macos) and you've set TINFOW_NO_PKG_CONFIG but have NOT set TINFO_NO_PKG_CONFIG too, so you're linking tinfo(no w) with other wide libs like ncursesw, which will cause '{}' eg. for example ex_5 when trying to run it. This is a warning not a panic because we assume you know what you're doing, and besides this works on Fedora (even if that env. var isn't set)!","Segmentation fault (core dumped)");
     }
+    //TODO: test on macos-es. When not using the brew ncurses, it won't have A_ITALIC and BUTTON5_*
+    //thus cursive will fail compilation. donedifferentlyTODO: detect this and issue cargo:warning from here.
 
-    if let Ok(x) = std::env::var("NCURSES_RS_RUSTC_FLAGS") {
+    watch_env_var(ENV_VAR_NAME_FOR_NCURSES_RS_RUSTC_FLAGS);
+    if let Ok(x) = std::env::var(ENV_VAR_NAME_FOR_NCURSES_RS_RUSTC_FLAGS) {
         println!("cargo:rustc-flags={}", x);
     }
 
     check_chtype_size(&ncurses_lib);
 
-    gen_constants();
-    gen_menu_constants();
-    build_wrap();
+    //The code in src/genconstants.c uses initscr() of ncurses (see: $ man 3x initscr)
+    //which depends on TERM env.var and will fail if TERM is wrong, say 'TERM=foo',
+    //with: "Error opening terminal: foo." and exit code 1
+    //therefore rebuild if TERM is changed without needing a 'cargo clean' first:
+    watch_env_var("TERM");
+    gen_rs(
+        "src/genconstants.c",
+        "genconstants",
+        "raw_constants.rs",
+        &ncurses_lib,
+        &lib_name,
+    );
+
+    gen_rs(
+        "src/menu/genconstants.c",
+        "genmenuconstants",
+        "menu_constants.rs",
+        &ncurses_lib,
+        &lib_name,
+    );
+
+    build_wrap(&ncurses_lib);
 }
+// -----------------------------------------------------------------
 
-fn build_wrap() {
-    println!("cargo:rerun-if-changed=src/wrap.c");
-    cc::Build::new()
-        .file("src/wrap.c")
-        .compile("wrap");
+//TODO: look into how to make doc tests and if they'd work with build.rs
+/// Creates file with the specified contents.
+/// Any existing file with that name is lost.
+/// Panics if file_name isn't prefixed by the value of OUT_DIR (at runtime) for extra safety.
+fn overwrite_file_contents(file_name: &str, contents: &[u8]) {
+    //Note: asserts in build.rs appear to be enabled even for cargo build --release, and can't be disabled(which is good, we want them on, always)
+    assert!(
+        file_name.starts_with(&get_out_dir()),
+        "The file name you wanted to create '{}' should be created in OUT_DIR only",
+        file_name
+    );
+    //FIXME: Maybe don't require utf-8 valid paths? by requiring &str here,
+    //the caller would do PathBuf::display() which replaces '\xFF' with the placeholder char
+    //which is the replacement character \u{FFFD}
+    //Many other programs break at compile time if path contains non-utf8 chars, before we even get here!
+    let mut file = File::create(file_name)
+        .unwrap_or_else(|err| panic!("Couldn't create file '{}', reason: '{}'", file_name, err));
+
+    file.write_all(contents).unwrap_or_else(|err| {
+        panic!(
+            "Couldn't write contents to file '{}', reason: '{}'",
+            file_name, err
+        )
+    });
+    drop(file); //explicit file close, not needed since it's in a function now!
 }
 
-fn gen_constants() {
-    println!("cargo:rerun-if-changed=src/genconstants.c");
-    let out_dir = env::var("OUT_DIR").expect("cannot get OUT_DIR");
-    let bin = format!("{}", Path::new(&out_dir).join(if cfg!(windows) { "genconstants.exe" } else { "genconstants" }).display());
-    let src = format!("{}", Path::new(&out_dir).join("raw_constants.rs").display());
+fn get_out_dir() -> &'static str {
+    use std::sync::OnceLock;
+    static LOCK: OnceLock<String> = OnceLock::new();
+
+    //OUT_DIR is set by cargo during build
+    const ENV_NAME_OF_OUT_DIR: &str = "OUT_DIR";
+    LOCK.get_or_init(|| {
+        env::var(ENV_NAME_OF_OUT_DIR).unwrap_or_else(|err| {
+            panic!(
+                "Cannot get env.var. '{}', reason: '{}'. Use `cargo build` instead of running this build script binary directly!",
+                ENV_NAME_OF_OUT_DIR, err
+            )
+        })
+    })
+    //^ Rust automatically coerces the &String reference to a &str reference, making the function return type &'static str valid without any additional explicit conversion. This behavior is possible due to Deref coercion.
+}
+
+/// Tries to see if linker can find/link with the named library, to create a binary.
+/// Uses ncurses lib searchdirs(if any found by pkg-config) to find that lib.
+/// This is mainly used when pkg-config is missing.
+/// Should still work if pkg-config exists though(except it will be missing the found link searchdirs and thus might fail? TODO: test this on NixOS, with NCURSES(W)_NO_PKG_CONFIG=1 env.var, for something like menu(w) or panel(w) )
+/// Returns Some(nn) if linking succeeded, None otherwise, nn is a bool saying if ncurses was needed to can link.
+/// Will try to link twice if linking with only that lib fails, the second try adds ncurses lib to
+/// linking command, because the lib might depend on it even though it doesn't say(inside it) that
+/// it does (this is what happens on OpenBSD).
+fn try_link(
+    lib_name: &str,
+    ncurses_lib: &Option<Library>,
+    ncurses_lib_name_to_use: &str,
+) -> Option<bool> {
+    let out_dir = get_out_dir();
+    assert!(
+        !ncurses_lib_name_to_use.is_empty(),
+        "You passed empty ncurses lib name string."
+    );
+
+    //We won't execute it though, so doesn't matter if it's .exe for Windows
+    let out_bin_fname = format!("try_link_with_{}", lib_name);
+
+    //we'll generate this .c file with our contents
+    let out_src_full = Path::new(&out_dir)
+        .join(format!("{}.c", out_bin_fname))
+        .display()
+        .to_string();
+
+    let source_code = b"int main(void) { return 0; }";
+    overwrite_file_contents(&out_src_full, source_code);
+    //TODO: remove commented out code everywhere in build.rs
 
     let build = cc::Build::new();
-    let compiler = build.try_get_compiler().expect("Failed Build::try_get_compiler");
-    let mut command = compiler.to_command();
+    let mut linker_searchdir_args: Vec<String> = Vec::new();
+    //Add linker paths from ncurses lib, if any found! ie. -L
+    //(this likely will be empty if pkg-config doesn't exist)
+    //Include paths(for headers) don't matter! ie. -I
+    //Presumably the other libs(menu,panel,tinfo) are in the same dir(s) as the ncurses lib,
+    //because they're part of ncurses even though they're split on some distros/OSs.
+    if let Some(lib) = ncurses_lib {
+        for link_path in &lib.link_paths {
+            linker_searchdir_args.push("-L".to_string());
+            linker_searchdir_args.push(link_path.display().to_string());
+        }
+    }
 
-    if let Ok(x) = std::env::var("NCURSES_RS_CFLAGS") {
-        command.args(x.split(" "));
-    }    
+    let mut command = get_the_compiler_command_from_build(build);
 
-    command.arg("-o").arg(&bin).arg("src/genconstants.c").arg("-lcurses");
-    assert!(command.status().expect("compilation failed").success());
+    let out_bin_full = Path::new(&out_dir)
+        .join(out_bin_fname)
+        .display()
+        .to_string();
+    //Create a bin(not a lib) from a .c file
+    //though it wouldn't matter here if it's bin or lib, I'm
+    //not sure how to find its exact output name after, to delete it.
+    //Adding the relevant args for the libs that we depend upon such as ncurses
+    //
+    //First we try to link just the requested lib, eg. 'menu' or 'panel' or 'tinfo'
+    //if this fails, then we try adding 'ncurses' to libs to link, thus
+    //on OpenBSD for example, where libmenu doesn't say it depends on the 'ncurses' lib
+    //it can link successfully because we manually link with it, thus linker won't fail with unresolved symbols.
+    command
+        .arg("-o")
+        .arg_checked(&out_bin_full)
+        .arg_checked(&out_src_full)
+        .args_checked(["-l", lib_name]) //this might require the ncurses lib below(on openbsd for sure!)
+        .args_checked(linker_searchdir_args);
+    //this copy will link only the lib, without ncurses
+    let mut command_copy: Command = Command::new(command.get_program()); //FIXME:command.make_a_partial_copy();//woulda been too easy if had .clone()
+    command_copy.args_checked(command.get_args()); //FIXME: temp
+
+    //we add ncurses to linked libs, but we only call this if the first try(ie. that copy) fails.
+    command.args_checked(["-l", ncurses_lib_name_to_use]);
+    let exit_status = command_copy.status_or_panic(); //runs compiler
+    let mut ret: bool = exit_status.success();
+    let mut requires_ncurses_lib: bool = false;
+    if !ret {
+        //first try failed, try second with -lncurses(w) added.
+        let exit_status = command.status_or_panic(); //runs compiler
+        ret = exit_status.success();
+        if ret {
+            //cargo_warn!("");
+            requires_ncurses_lib = true;
+        }
+    }
 
-    let consts = Command::new(&bin).output()
-        .expect(&format!("{} failed", bin));
+    if DELETE_GENERATEDS {
+        if ret {
+            //delete temporary bin that we successfully generated
+            std::fs::remove_file(&out_bin_full).unwrap_or_else(|err| {
+                panic!(
+                    "Cannot delete generated bin file '{}', reason: '{}'",
+                    out_bin_full, err
+                )
+            });
+        }
+        //delete the .c that we generated
+        std::fs::remove_file(&out_src_full).unwrap_or_else(|err| {
+            panic!(
+                "Cannot delete generated C file '{}', reason: '{}'",
+                out_src_full, err
+            )
+        });
+    }
 
-    let mut file = File::create(&src).unwrap();
-    
-    file.write_all(&consts.stdout).unwrap();
+    return if ret {
+        Some(requires_ncurses_lib)
+    } else {
+        None
+    };
 }
 
-fn gen_menu_constants() {
-    println!("cargo:rerun-if-changed=src/menu/genconstants.c");
-    let out_dir = env::var("OUT_DIR").expect("cannot get OUT_DIR");
-    let bin = format!("{}", Path::new(&out_dir).join(if cfg!(windows) { "genmenuconstants.exe" } else { "genmenuconstants" }).display());
-    let src = format!("{}", Path::new(&out_dir).join("menu_constants.rs").display());
+//TODO: change this to apply to anything that's emitted for cargo to consume, except warnings, and
+//make it HashMap with a counter.
+/// Emits "cargo:rerun-if-env-changed=ENV_VAR" on stdout
+/// only once for each ENV_VAR
+/// regardless of how many times it gets called.
+fn watch_env_var(env_var: &'static str) {
+    assert!(!env_var.is_empty(), "Passed empty env.var. to watch for.");
+    use std::collections::HashSet;
+    use std::sync::OnceLock;
+    use std::sync::{Arc, RwLock};
+    // static gets inited only once before main() and is scoped only to this function
+    static SHARED_DATA: OnceLock<Arc<RwLock<HashSet<&'static str>>>> = OnceLock::new();
+    //the inner value (hashset) is inited only once on first call of this function
+    let hs = SHARED_DATA.get_or_init(|| Arc::new(RwLock::new(HashSet::new())));
+    // Acquire a write lock to atomically check and insert if necessary
+    if let Ok(mut guard) = hs.write() {
+        // Critical section where the lock is held
+        if !guard.contains(env_var) {
+            println!("cargo:rerun-if-env-changed={}", env_var);
+            guard.insert(env_var);
+        }
+    } //lock released here
 
-    let build = cc::Build::new();
-    let compiler = build.try_get_compiler().expect("Failed Build::try_get_compiler");
-    let mut command = compiler.to_command();
+    //TODO: can use HashMap(since HashSet I hear is just a HashMap underneath) and keep a counter as val
+    //this way we'd know how many times an env.var. tried to be emitted, but for what reason we'd
+    //wanna know though...
+}
+
+/// set some sensible defaults
+fn new_build(lib: &Option<Library>) -> cc::Build {
+    //XXX: Note: env.var. "CC" can override the compiler used and will cause rebuild if changed.
+    let mut build = cc::Build::new();
+    if let Some(lib) = lib {
+        //header file paths eg. for ncurses.h
+        build.includes(&lib.include_paths);
+        //for path in lib.include_paths.iter() {
+        //    build.include(path);
+        //}
+    }
+    build.opt_level(1); //else is 0, causes warning on NixOS: _FORTIFY_SOURCE requires compiling with optimization (-O)
 
-    if let Ok(x) = std::env::var("NCURSES_RS_CFLAGS") {
-        command.args(x.split(" "));
-    }    
+    //XXX:Don't have to emit cargo:rerun-if-env-changed= here because try_flags_from_environment()
+    //below does it for us, however it does it on every call! (unless Build::emit_rerun_if_env_changed(false))
+    //but if an overriding variant of it is defined like NCURSES_RS_CFLAGS_x86_64_unknown_linux_gnu
+    //then this weaker one won't be emitted because the override will be the only one in effect.
+    //We could forcefully emit anyway, but no point, it will be ignored and just rebuild for no reason.
+    //watch_env_var(ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS);
 
-    command.arg("-o").arg(&bin).arg("src/menu/genconstants.c").arg("-lcurses");
-    assert!(command.status().expect("compilation failed").success());
+    //See comment above the const var def. to understand which env.vars are tried here:
+    let _ = build.try_flags_from_environment(ENV_VAR_NAME_FOR_NCURSES_RS_CFLAGS);
 
-    let consts = Command::new(&bin).output()
-        .expect(&format!("{} failed", bin));
+    //these two are already in from the default Build
+    //build.flag_if_supported("-Wall");
+    //build.flag_if_supported("-Wextra");
+    build.flag_if_supported("-Wpedantic");
+    //build.flag_if_supported("-Wstrict-prototypes");//maybe fix me: triggers warnings in wrap.c
+    build.flag_if_supported("-Weverything"); //only clang
 
-    let mut file = File::create(&src).unwrap();
-    
-    file.write_all(&consts.stdout).unwrap();
+    return build; // explicit return makes it more obvious that the ";" is missing so it's a return!
+}
+
+fn build_wrap(ncurses_lib: &Option<Library>) {
+    // build.file(source_file), below, doesn't emit this:
+    println!("cargo:rerun-if-changed=src/wrap.c");
+    let mut build = new_build(ncurses_lib);
+
+    // The following creates `libwrap.a` on linux, a static lib
+    build.file("src/wrap.c").compile("wrap");
+    //the resulting lib will be kept until deleted by 'cargo clean'
+}
+
+fn get_the_compiler_command_from_build(build: cc::Build) -> std::process::Command {
+    //'cc::Build' can do only lib outputs but we want a binary
+    //so we get the command (and args) thus far set and add our own args.
+    //Presumably all args will be kept, as per: https://docs.rs/cc/1.0.92/cc/struct.Build.html#method.get_compiler
+    //(though at least the setting for build.file(source_c_file) won't be,
+    // but we don't use that way and instead set it later as an arg to compiler)
+    let compiler = build
+        .try_get_compiler()
+        .expect("Failed Build::try_get_compiler");
+    let command = compiler.to_command();
+    return command;
+}
+
+/// Compiles an existing .c file, runs its bin to generate a .rs file from its output.
+/// Uses ncurses include paths and links with ncurses lib(s)
+// Note: won't link with tinfo unless pkg-config returned it.
+// ie. if `pkg-config ncurses --libs` shows: -lncurses -ltinfo
+// So even though we used a fallback tinfo in main, for cargo, it won't be used here. FIXME: if tinfo is needed here ever! (it's currently not, btw)
+fn gen_rs(
+    source_c_file: &str,
+    out_bin_fname: &str,
+    gen_rust_file: &str,
+    ncurses_lib: &Option<Library>,
+    lib_name: &str,
+) {
+    //TODO: see if build.file() already emits this!
+    println!("cargo:rerun-if-changed={}", source_c_file);
+    let out_dir = get_out_dir();
+    #[cfg(windows)]
+    let out_bin_fname = format!("{}.exe", out_bin_fname); //shadowed
+    let bin_full = Path::new(&out_dir)
+        .join(out_bin_fname)
+        .display()
+        .to_string();
+
+    let build = new_build(ncurses_lib);
+    let mut linker_searchdir_args: Vec<String> = Vec::new();
+    if let Some(lib) = ncurses_lib {
+        for link_path in &lib.link_paths {
+            linker_searchdir_args.push("-L".to_string());
+            linker_searchdir_args.push(link_path.display().to_string());
+        }
+    }
+
+    let mut command = get_the_compiler_command_from_build(build);
+
+    //create a bin(not a lib) from a .c file
+    //adding the relevant args for the libs that we depend upon such as ncurses
+    command
+        .arg("-o")
+        .arg_checked(&bin_full)
+        .arg_checked(source_c_file)
+        .args_checked(["-l", lib_name])
+        .args_checked(linker_searchdir_args);
+    command.success_or_panic(); //runs compiler
+
+    //Execute the compiled binary, panicking if non-zero exit code, else compilation will fail
+    //later with things like: "error[E0432]: unresolved import `constants::TRUE`" in the case of
+    //generating raw_constants.rs which would be empty due to 'genconstants' having failed with exit
+    //code 1 because env.var. TERM=a_terminal_not_in_term_database
+    let output: std::process::Output = Command::new(&bin_full).output_success_or_panic();
+
+    //Write the output from executing the binary into a new rust source file .rs
+    //That .rs file is later used outside of this build.rs, in the normal build
+    let gen_rust_file_full_path = Path::new(&out_dir)
+        .join(gen_rust_file)
+        .display()
+        .to_string();
+    overwrite_file_contents(&gen_rust_file_full_path, &output.stdout);
+    //we ignore stderr.
+    //we don't delete this file because it's used to compile the rest of the crate.
 }
 
 fn check_chtype_size(ncurses_lib: &Option<Library>) {
-    let out_dir = env::var("OUT_DIR").expect("cannot get OUT_DIR");
-    let src = format!("{}", Path::new(&out_dir).join("chtype_size.c").display());
-    let bin = format!("{}", Path::new(&out_dir).join(if cfg!(windows) { "chtype_size.exe" } else { "chtype_size" }).display());
+    let out_dir = get_out_dir();
+    //FIXME: see if .display() is a good idea, maybe can avoid it.
+    let src_full = Path::new(&out_dir)
+        .join("chtype_size.c")
+        .display()
+        .to_string();
+    let bin_name = if cfg!(windows) {
+        "chtype_size.exe"
+    } else {
+        "chtype_size"
+    };
+    let bin_full = Path::new(&out_dir).join(bin_name).display().to_string();
 
-    let mut fp = File::create(&src).expect(&format!("cannot create {}", src));
-    fp.write_all(b"
+    let contents = br#"// autogenerated by build.rs
 #include <assert.h>
 #include <limits.h>
 #include <stdio.h>
@@ -136,38 +663,698 @@ fn check_chtype_size(ncurses_lib: &Option<Library>) {
 int main(void)
 {
     if (sizeof(chtype)*CHAR_BIT == 64) {
-        puts(\"cargo:rustc-cfg=feature=\\\"wide_chtype\\\"\");
+        puts("cargo:rustc-cfg=feature=\"wide_chtype\"");
     } else {
         /* We only support 32-bit and 64-bit chtype. */
-        assert(sizeof(chtype)*CHAR_BIT == 32 && \"unsupported size for chtype\");
+        assert(sizeof(chtype)*CHAR_BIT == 32 && "unsupported size for chtype");
     }
 
 #if defined(NCURSES_MOUSE_VERSION) && NCURSES_MOUSE_VERSION == 1
-	puts(\"cargo:rustc-cfg=feature=\\\"mouse_v1\\\"\");
+    puts("cargo:rustc-cfg=feature=\"mouse_v1\"");
 #endif
     return 0;
 }
-    ").expect(&format!("cannot write into {}", src));
+"#;
+    overwrite_file_contents(&src_full, contents);
 
-    let mut build = cc::Build::new();
-    if let Some(lib) = ncurses_lib {
-        for path in lib.include_paths.iter() {
-            build.include(path);
+    let build = new_build(ncurses_lib);
+
+    let mut command = get_the_compiler_command_from_build(build);
+
+    command
+        .arg("-o")
+        .arg_checked(&bin_full)
+        .arg_checked(&src_full);
+    command.success_or_panic(); //runs compiler
+
+    let features = Command::new(&bin_full).output_success_or_panic();
+
+    //for cargo to consume
+    print!("{}", String::from_utf8_lossy(&features.stdout));
+
+    if DELETE_GENERATEDS {
+        std::fs::remove_file(&src_full).unwrap_or_else(|err| {
+            panic!(
+                "Cannot delete generated C file '{}', reason: '{}'",
+                src_full, err
+            )
+        });
+        std::fs::remove_file(&bin_full).unwrap_or_else(|err| {
+            panic!(
+                "cannot delete compiled bin file '{}', reason: '{}'",
+                bin_full, err
+            )
+        });
+    }
+}
+
+//call this only once, to avoid re-printing "cargo:rustc-link-lib=" // FIXME
+fn get_ncurses_lib_name(ncurses_lib: &Option<Library>) -> String {
+    //Was it found(and thus printed) by pkg_config::probe_library() ?
+    let mut already_printed: bool = false;
+    let lib_name: String;
+    watch_env_var(ENV_VAR_NAME_FOR_LIB);
+    match std::env::var(ENV_VAR_NAME_FOR_LIB) {
+        Ok(value) => lib_name = value,
+        Err(_) => {
+            if let Some(ref lib) = ncurses_lib {
+                // if here, `pkg-config`(shell command) via pkg_config crate,
+                // has found the ncurses lib (eg. via the `ncurses.pc` file)
+                // You can get something like this ["ncurses", "tinfo"] as the lib.libs vector
+                // but we shouldn't assume "ncurses" is the first ie. lib.libs[0]
+                // and the exact name of it can be ncurses,ncursesw,ncurses5,ncursesw5 ...
+                // so find whichever it is and return that:
+                let substring_to_find = "curses";
+                if let Some(found) = lib.libs.iter().find(|&s| s.contains(substring_to_find)) {
+                    //If we're here, the function calls to pkg_config::probe_library()
+                    //from above ie. through find_library(), have already printed these:
+                    //   cargo:rustc-link-lib=ncurses
+                    //   cargo:rustc-link-lib=tinfo
+                    //so there's no need to re-print the ncurses line as it would be the same.
+                    already_printed = true;
+                    lib_name = found.clone();
+                } else {
+                    // Construct the repeated pkg-config command string
+                    let repeated_pkg_config_command: String = NCURSES_LIB_NAMES
+                        .iter()
+                        .map(|ncurses_lib_name| format!("pkg-config --libs {}", ncurses_lib_name))
+                        .collect::<Vec<_>>()
+                        .join("` or `");
+
+                    panic!(
+                    "pkg_config(crate) reported that it found the ncurses lib(s) but the substring '{}' was not among them, ie. in the output of the shell command(s) eg. `{}`\n
+                    Try setting NCURSES_NO_PKG_CONFIG=1 and/or NCURSESW_NO_PKG_CONFIG=1 to disable pkg-config and thus allow for the fallback to lib name 'ncurses' respectively 'ncursesw' to be tried. Or fix ncurses.pc or ncursesw.pc file.",
+                    substring_to_find,
+                    repeated_pkg_config_command
+                    );
+                }
+            } else {
+                //pkg-config didn't find the lib, fallback to 'ncurses' or 'ncursesw'
+                let what_lib = NCURSES_LIB_NAME_FALLBACK.to_string();
+                // On FreeBSD it works without pkgconf and ncurses(6.4) installed but it will fail
+                // to link ex_5 with 'menu' lib, unless `NCURSES_RS_RUSTC_FLAGS="-lmenu" is set.
+                // this is why we now use fallbacks for 'menu' and 'panel` above too(not just for 'ncurses' lib)
+                // that is, when pkgconf or pkg-config are missing, yet the libs are there.
+                // Print the warning message, but use old style warning with one ":" not two "::",
+                // because old cargos(pre 23 Dec 2023) will simply ignore it and show no warning if it's "::"
+                cargo_warn!("Using (untested)fallback lib name '{}' but if compilation fails below(like when linking ex_5 with 'menu' feature), that is why. It's likely you have not installed one of ['pkg-config' or 'pkgconf'], and/or 'ncurses' (it's package 'ncurses-devel' on Fedora). This seems to work fine on FreeBSD 14 regardless, however to not see this warning and to ensure 100% compatibility(on any OS) be sure to install, on FreeBSD, at least `pkgconf` if not both ie. `# pkg install ncurses pkgconf`.", what_lib);
+                //fallback lib name: 'ncurses' or 'ncursesw'
+                //if this fails later, there's the warning above to get an idea as to why.
+                lib_name = what_lib;
+            }
         }
+    };
+    if !already_printed {
+        //TODO: try_link() ? then refactor the warning messages. Well, now that try_link already links ncurses lib, this isn't needed? or if it is, don't specify -l twice for it inside try_link
+        println!("cargo:rustc-link-lib={}", lib_name);
     }
-    let compiler = build.try_get_compiler().expect("Failed Build::try_get_compiler");
-    let mut command = compiler.to_command();
+    lib_name
+}
+
+//trait MyOutput {}
+//
+//impl MyOutput for std::process::Output {}
+
+trait MyExitStatus {
+    fn success_or_panic(self) -> ExitStatus;
+}
 
-    if let Ok(x) = std::env::var("NCURSES_RS_CFLAGS") {
-        command.args(x.split(" "));
+impl MyExitStatus for std::process::ExitStatus {
+    fn success_or_panic(self) -> ExitStatus {
+        if self.success() {
+            self
+        } else {
+            let how: String;
+            if let Some(code) = self.code() {
+                how = format!(" with exit code {}.", code);
+            } else {
+                how = ", was it terminated by a signal?!".to_string();
+            }
+            panic!(
+                "!!! Compiler failed{} Is ncurses installed? \
+        pkg-config or pkgconf too? \
+        it's 'ncurses-devel' on Fedora; \
+        run `nix-shell` first, on NixOS. \
+        Or maybe it failed for different reasons which are seen in the errored output above.",
+                how
+            )
+        }
     }
+}
 
-    command.arg("-o").arg(&bin).arg(&src);
-    assert!(command.status().expect("compilation failed").success());
-    let features = Command::new(&bin).output()
-        .expect(&format!("{} failed", bin));
-    print!("{}", String::from_utf8_lossy(&features.stdout));
+// Define an extension trait for Command
+trait MyCompilerCommand {
+    fn output_or_panic(&mut self) -> std::process::Output;
+    fn output_success_or_panic(&mut self) -> std::process::Output;
+    fn success_or_panic(&mut self) -> ExitStatus;
+    //fn success_or_else<F: FnOnce(ExitStatus) -> ExitStatus>(&mut self, op: F) -> ExitStatus;
+    fn just_status_or_panic(&mut self) -> ExitStatus;
+    fn status_or_panic(&mut self) -> ExitStatus;
+    fn status_or_panic_but_no_check_args(&mut self) -> ExitStatus;
+    fn show_what_will_run(&mut self) -> &mut Self;
+    fn get_program_or_panic(&self) -> &str;
+    fn get_what_will_run(&self) -> (String, usize, String, Option<&Path>, String);
+    fn assert_no_nul_in_args(&mut self) -> &mut Self;
+    /// Panics if arg has \0 in it.
+    fn args_checked<I, S>(&mut self, args: I) -> &mut Command
+    where
+        I: IntoIterator<Item = S>,
+        S: AsRef<OsStr>;
+    /// Panics if arg has \0 aka NUL in it,
+    /// otherwise the original Command::arg would've set it to "<string-with-nul>"
+    /// Doesn't do any other checks, passes it to Command::arg()
+    fn arg_checked<S: AsRef<OsStr>>(&mut self, arg: S) -> &mut Command;
+    fn panic<T: std::fmt::Display>(&mut self, err: T, what_type_of_command: &str) -> !;
+    fn make_a_partial_copy(&self) -> Self;
+}
+
+fn has_null_byte<S: AsRef<OsStr>>(arg: S) -> bool {
+    let os_str = arg.as_ref();
+    for &byte in os_str.as_bytes() {
+        if byte == 0 {
+            return true;
+        }
+    }
+    false
+}
+
+/// Args with \0 in them, passed to std::process::Command::arg() or ::args()
+/// get replaced(by those calls)entirely with this: "<string-with-nul>"
+const REPLACEMENT_FOR_ARG_THAT_HAS_NUL: &str = "<string-with-nul>";
+// Implement the extension trait for Command, so you can use methods on a Command instance even
+// though it's a type that's not defined here but in std::process
+impl MyCompilerCommand for std::process::Command {
+    /// Executes Command::output() and gives you Output struct or panics
+    /// but the exit code may not have been 0
+    fn output_or_panic(&mut self) -> std::process::Output {
+        self.output().unwrap_or_else(|err| {
+            self.panic(err, "generated bin"); //TODO: let caller provide this
+        })
+    }
+
+    /// Executes Command::output() and gives you Output struct or panics
+    /// also panics if exit code was not 0 and shows you stdout/stderr if so.
+    fn output_success_or_panic(&mut self) -> std::process::Output {
+        let output = self.output_or_panic();
+        // test this with: `$ TERM=foo cargo build`
+        let show_stdout_stderr = || {
+            //XXX: presumably eprintln! and std::io::stderr().write_all().unwrap() write to same stderr
+            //stream and both would panic if some error would happen when writing to it!
+            eprintln!("But here's its stdout&stderr:");
+            eprintln!("|||stdout start|||");
+            //Preserve stdout/stderr bytes, instead of lossily convert them to utf-8 before showing them.
+            //show stdout of executed binary, on stderr
+            std::io::stderr().write_all(&output.stdout).unwrap();
+            eprintln!("\n|||stdout end||| |||stderr start|||");
+            //show stderr of executed binary, on stderr
+            std::io::stderr().write_all(&output.stderr).unwrap();
+            eprintln!("\n|||stderr end|||");
+        };
+        let prog = self.get_program_or_panic();
+        let and_panic = || -> ! {
+            panic!(
+                "due to the above-reported error while executing '{}'.",
+                prog
+            );
+        };
+
+        let exit_code = output.status.code().unwrap_or_else(|| {
+            //we get here if it segfaults(signal 11), so if exited due to signal
+            //but unsure if we get here for any other reasons!
+            //To test this branch uncomment a segfault line early in src/genconstants.c then `cargo build`
+
+            let basename=Path::new(prog).file_name().unwrap_or_else(|| {
+                eprintln!("Couldn't get basename for '{}'", prog);
+                OsStr::new("") //refusing to panic over this
+            });
+            let basename=basename.to_str().unwrap_or_else(|| {
+                eprintln!("Couldn't convert OsStr '{:?}' to &str", basename);
+                "" //refusing to panic over this
+            });
+            eprintln!(
+                "!!! Execution of '{}' failed, likely killed by signal! Maybe check 'dmesg' for the word \"segfault\" or \"{}\". We can't know here, which signal happened.",
+                prog, basename
+                );
+            show_stdout_stderr();
+            and_panic();
+        });
+        if 0 != exit_code {
+            eprintln!(
+                "!!! Execution of '{}' failed with exit code '{}'",
+                prog, exit_code
+            );
+            show_stdout_stderr();
+            eprintln!(
+                //FIXME: this msg can't be part of the (future)extension trait impl, it's for src/genconstants.c only.
+                "!! Maybe you need to try a different value for the TERM environment variable !!"
+            );
+            and_panic();
+        } else {
+            return output;
+        }
+    }
+
+    /// Executes Command::status().success() and panics if it any fail
+    /// This means exit code 0 is ensured.
+    /// Note: You can't use an arg value "<string-with-nul>", or this will panic.
+    fn success_or_panic(&mut self) -> ExitStatus {
+        let exit_status: ExitStatus = self.status_or_panic().success_or_panic();
+        exit_status
+    }
+
+    //XXX: can't override arg/args because they're not part of a Trait in Command
+    //so would've to wrap Command in my own struct for that. This would've ensured
+    //that any added args were auto-checked.
+    /// panics if any args have \0 aka nul in it, else Command will panic later, on execution.
+    fn args_checked<I, S>(&mut self, args: I) -> &mut Command
+    where
+        I: IntoIterator<Item = S>,
+        S: AsRef<OsStr>,
+    {
+        for arg in args {
+            self.arg_checked(arg.as_ref());
+        }
+        self
+    }
+
+    /// panics if arg has \0 aka nul in it, else Command will panic later, on execution.
+    fn arg_checked<S: AsRef<OsStr>>(&mut self, arg: S) -> &mut Command {
+        if has_null_byte(&arg) {
+            //If the arg has NUL ie. \0  in it then arg got replaced already
+            //with "<string-with-nul>", internally, by std::process::Command::arg() .
+            //The found arg here will be shown with \0 in this Debug way.
+            panic!(
+                "Found arg '{:?}' that has at least one \\0 aka nul in it! \
+                   This would've been replaced with '{}'.",
+                arg.as_ref(),
+                REPLACEMENT_FOR_ARG_THAT_HAS_NUL
+            );
+        }
+        self.arg(arg)
+    }
+
+    /// Beware if user set the arg on purpose to the value of REPLACEMENT_FOR_ARG_THAT_HAS_NUL
+    /// which is "<string-with-nul>" then this will panic, it's a false positive.
+    fn assert_no_nul_in_args(&mut self) -> &mut Self {
+        let args = self.get_args();
+        for (count, arg) in args.enumerate() {
+            if let Some(fully_utf8_arg) = arg.to_str() {
+                //If the arg had NUL ie. \0  in it then arg got replaced already
+                //with "<string-with-nul>", internally, by std::process::Command::arg() .
+                if fully_utf8_arg == REPLACEMENT_FOR_ARG_THAT_HAS_NUL {
+                    panic!(
+                        "Found arg number '{}' that has \\0 aka NUL in it! \
+                           It got replaced with '{}'.",
+                        count + 1,
+                        REPLACEMENT_FOR_ARG_THAT_HAS_NUL
+                    );
+                }
+            }
+        }
+        self
+    }
+
+    fn get_program_or_panic(&self) -> &str {
+        let program = self.get_program();
+        let p_prog = program
+            .to_str()
+            .unwrap_or_else(|| panic!("Compiler executable {:?} isn't valid rust string", program));
+        //TODO: "Compiler" is too specific here, could be we're running just a bin we created!
+        p_prog
+    }
+
+    fn get_what_will_run(&self) -> (String, usize, String, Option<&Path>, String) {
+        let p_prog = self.get_program_or_panic();
+        let args = self.get_args();
+        let how_many_args: usize = args.len();
+        let formatted_args: String = args
+            .map(|arg| {
+                //If the arg had NUL ie. \0  in it then arg got replaced already
+                //with "<string-with-nul>", internally, by std::process::Command::arg()
+                //if it was added via Command::arg() or Command::args().
+                //To prevent that use Command::arg_checked() and ::args_checked()
+                if let Some(fully_utf8_arg) = arg.to_str() {
+                    fully_utf8_arg.to_string()
+                } else {
+                    //None aka not fully utf8 arg
+                    //then we show it as ascii + hex
+                    let mut broken_arg = String::new();
+                    //use std::fmt::Write; // can't globally import this ^, conflicts with std::io::Write
+                    for byte in arg.as_bytes() {
+                        match std::char::from_u32(*byte as u32) {
+                            Some(c) if c.is_ascii() => broken_arg.push(c),
+                            _ => {
+                                write!(&mut broken_arg, "\\x{:02X}", byte).expect("Failed to write")
+                            }
+                        }
+                    }
+                    broken_arg
+                }
+            })
+            .collect::<Vec<String>>()
+            .join("\" \"");
+        //TODO: maybe a better way to get the args as a Vec<String> and impl Display ? but not
+        //for the generic Vec<String> i think. Then, we won't have to return how_many_args!
+
+        let cur_dir = self.get_current_dir();
+        let env_vars: Vec<(&OsStr, Option<&OsStr>)> = self.get_envs().collect();
+        let mut formatted_env_vars = String::new(); //empty string if no env vars set
+        if !formatted_env_vars.is_empty() {
+            for (key, value) in env_vars {
+                match value {
+                    Some(value) => formatted_env_vars.push_str(&format!(
+                        "(set) {}={}\n",
+                        key.to_string_lossy(),
+                        value.to_string_lossy()
+                    )),
+                    None => {
+                        formatted_env_vars.push_str(&format!("(del) {}\n", key.to_string_lossy()))
+                    } // Key was removed
+                }
+            }
+        };
+        //FIXME: make this a struct so the order doesn't get confused in callers.
+        //return this tuple
+        (
+            p_prog.to_string(),
+            how_many_args,
+            format!("\"{}\"", formatted_args),
+            cur_dir,
+            formatted_env_vars,
+        )
+    }
+
+    /// just like Command::status() but panics if it can't execute it,
+    /// ie. if status() would've returned an Err
+    /// returns ExitStatus whether it be 0 or !=0
+    /// Doesn't show you what will be executed and doesn't check args.
+    /// (not meant to be used outside)
+    fn just_status_or_panic(&mut self) -> ExitStatus {
+        // Call the original status() method and handle the potential error
+        self.status().unwrap_or_else(|err| {
+            self.panic(err, "compilation"); //TODO: let caller provide this?!
+        })
+    }
+
+    /// Shows command that will execute and checks args, only after this
+    /// it's gonna be trying to do .status()
+    /// Panics if status would've returned an Err
+    fn status_or_panic(&mut self) -> ExitStatus {
+        self.show_what_will_run()
+            .assert_no_nul_in_args()
+            .just_status_or_panic()
+    }
+
+    /// Used only for build.rs tests:
+    /// this should be exactly like status_or_panic() except it won't check that args
+    /// aren't nul-containing and thus won't panic before the original status() gets run, thus
+    /// allowing it to panic on nul.
+    /// (not meant to be used outside)
+    fn status_or_panic_but_no_check_args(&mut self) -> ExitStatus {
+        self.show_what_will_run().just_status_or_panic()
+    }
+
+    /// (not meant to be used outside)
+    fn panic<T: std::fmt::Display>(&mut self, err: T, what_type_of_command: &str) -> ! {
+        let (p_prog, how_many_args, formatted_args, _cur_dir, _envs) = self.get_what_will_run();
+        let extra_space = if what_type_of_command.is_empty() {
+            ""
+        } else {
+            " "
+        };
+        panic!(
+            "Failed to run {}{}command '{}' with '{}' args: '{}', reason: '{}'",
+            what_type_of_command, extra_space, p_prog, how_many_args, formatted_args, err
+        )
+    }
+
+    /// shows on stderr, which command will be executed.
+    fn show_what_will_run(&mut self) -> &mut Self {
+        let (exe_name, how_many_args, formatted_args, cur_dir, formatted_env_vars) =
+            self.get_what_will_run();
+        let cur_dir: String = if let Some(dir) = cur_dir {
+            format!(", in current dir: '{}'", dir.display())
+        } else {
+            ", in unspecified current dir".to_string()
+        };
+        let formatted_env_vars: String = if formatted_env_vars.is_empty() {
+            ", with no extra env.vars added or deleted".to_string()
+        } else {
+            format!(", with env.vars: '{}'", formatted_env_vars)
+        };
+        eprintln!(
+            "!! Next, attempting to run command '{}' with '{}' args: '{}'{}{}.",
+            exe_name, how_many_args, formatted_args, cur_dir, formatted_env_vars
+        );
+        self
+    }
+
+    fn make_a_partial_copy(&self) -> Self {
+        let prog=self.get_program();
+        let mut r#new=Command::new(prog);
+        r#new.args_checked(self.get_args());
+        r#new.envs(self.get_envs().collect());
+        r#new.current_dir(self.get_current_dir());
+
+        r#new
+    }
+}
+
+/// This is used to test build.rs, run with: cargo build --features=test_build_rs_of_ncurses_rs
+/// This won't happen if you use --all-features
+#[cfg(all(
+    feature = "test_build_rs_of_ncurses_rs",
+    not(feature = "dummy_feature_to_detect_that_--all-features_arg_was_used")
+))]
+fn main() {
+    test_assert_works();
+    test_invalid_utf8_in_program();
+    test_nul_in_arg_unchecked();
+    test_nul_in_arg();
+    test_no_panic_in_command();
+    test_panic_for_not_found_command();
+    test_panic_for_command_non_zero_exit();
+    test_get_what_will_run();
+    test_assert_no_nul_in_args();
+
+    eprintln!("\n-------------------------------------
+              \n!!! All build.rs tests have passed successfully! Ignore the above seemingly erroneous output, it was part of the successful testing !!!\nYou're seeing this because you tried to build with --features=test_build_rs_of_ncurses_rs");
+
+    // This stops the build from continuing which will fail in other places due to build.rs not
+    // doing its job, since we've only just tested build.rs not used it to generate stuff.
+    std::process::exit(5);
+}
+//The test functions are left outside of 'test_build_rs_of_ncurses_rs' feature gate
+//so that they're tested to still compile ok.
+
+#[allow(dead_code)]
+fn test_assert_works() {
+    let result = std::panic::catch_unwind(|| {
+        #[allow(clippy::assertions_on_constants)]
+        {
+            assert!(false, "!! just tested if asserts are enabled !!");
+        }
+    });
+    #[allow(clippy::manual_assert)]
+    if result.is_ok() {
+        panic!("Assertions are disabled in build.rs, should not happen!");
+    }
+}
+
+#[allow(dead_code)]
+fn test_no_panic_in_command() {
+    let expected_ec = 42;
+    let cmd = if cfg!(windows) { "cmd" } else { "sh" };
+    let args_ok = &["-c", "exit 0"];
+    let args_fail = &["-c", &format!("exit {}", expected_ec)];
+    let result = std::panic::catch_unwind(|| {
+        let mut command = Command::new(cmd);
+        command.args(args_ok);
+        //execute: sh -c 'exit 0'`
+        command.status_or_panic();
+    });
+    let fail_msg = format!(
+        "!!! This should not have panicked! Unless you don't have '{}' command, in PATH={:?} !!!",
+        cmd,
+        std::env::var("PATH")
+    );
+    assert!(result.is_ok(), "{}", fail_msg);
+
+    // executed bin exits with exit code 0, or it would panic ie. fail the test
+    let result = std::panic::catch_unwind(|| {
+        let mut command = Command::new(cmd);
+        command.args(args_ok);
+        //execute: sh -c 'exit 0'`
+        command.success_or_panic();
+    });
+    assert!(result.is_ok(), "{}", fail_msg);
+
+    // executed bin exits with specific exit code 2
+    let result = std::panic::catch_unwind(|| {
+        let mut command = Command::new(cmd);
+        command.args(args_fail);
+        //execute: sh -c 'exit 42'`
+        let exit_status = command.status_or_panic();
+        assert_eq!(
+            exit_status.code().expect("was command killed by a signal?"),
+            expected_ec,
+            "Command should've exited with exit code '{}'.",
+            expected_ec
+        );
+    });
+    assert!(result.is_ok(), "{}", fail_msg);
+}
+
+#[allow(dead_code)]
+fn test_panic_for_not_found_command() {
+    let result = std::panic::catch_unwind(|| {
+        let mut command = Command::new("some non-exitent command");
+        command.args([OsString::from("arg1")]);
+        command.status_or_panic();
+    });
+    let expected_panic_msg=
+     "Failed to run compilation command 'some non-exitent command' with '1' args: '\"arg1\"', reason: 'No such file or directory (os error 2)'";
+    expect_panic(result, expected_panic_msg);
+
+    let result = std::panic::catch_unwind(|| {
+        let mut command = Command::new("some non-exitent command");
+        command.args([OsString::from("arg1")]);
+        command.success_or_panic();
+    });
+    expect_panic(result, expected_panic_msg);
+}
+
+#[allow(dead_code)]
+fn test_panic_for_command_non_zero_exit() {
+    let cmd = if cfg!(windows) { "cmd" } else { "sh" };
+    let args_fail = &["-c", &format!("exit 43")];
+    let result = std::panic::catch_unwind(|| {
+        let mut command = Command::new(cmd);
+        command.args(args_fail);
+        command.success_or_panic();
+    });
+    let expected_panic_msg = "!!! Compiler failed with exit code 43. Is ncurses installed? pkg-config or pkgconf too? it's 'ncurses-devel' on Fedora; run `nix-shell` first, on NixOS. Or maybe it failed for different reasons which are seen in the errored output above.";
+    expect_panic(result, expected_panic_msg);
+}
+
+#[allow(dead_code)]
+fn test_invalid_utf8_in_program() {
+    let result = std::panic::catch_unwind(|| {
+        let mut command = Command::new(OsString::from_vec(
+            b"test_invalid_utf8_\xFFin_program".to_vec(),
+        ));
+        command.args([
+            OsString::from("arg1"),
+            OsString::from_vec(b"my\xffarg3".to_vec()),
+        ]);
+        command.status_or_panic();
+    });
+    expect_panic(
+        result,
+        "Compiler executable \"test_invalid_utf8_\\xFFin_program\" isn't valid rust string",
+    );
+}
+
+fn expect_panic(result: Result<(), Box<dyn std::any::Any + Send>>, expected_panic_message: &str) {
+    if result.is_err() {
+        if let Some(err) = result.unwrap_err().downcast_ref::<String>() {
+            // Uncomment this to can copy/paste it for asserts:
+            //println!("!!!!!!!!!! Panic message: {:?}", err);
+            assert_eq!(
+                err, expected_panic_message,
+                "!!! Got different panic message than expected !!!"
+            );
+        }
+    } else {
+        panic!(
+            "No panic was thrown! But was expecting this panic: '{}'",
+            expected_panic_message
+        );
+    };
+}
+
+#[allow(dead_code)]
+fn test_nul_in_arg_unchecked() {
+    let result = std::panic::catch_unwind(|| {
+        let mut command = Command::new("test_nul_in_arg_unchecked.exe");
+        command.args([
+            OsString::from("arg1"),
+            OsString::from("a\0rg2"),
+            OsString::from_vec(b"my\xffarg3".to_vec()),
+        ]);
+        command.status_or_panic_but_no_check_args();
+    });
+    expect_panic(result,
+         "Failed to run compilation command 'test_nul_in_arg_unchecked.exe' with '3' args: '\"arg1\" \"<string-with-nul>\" \"my\\xFFarg3\"', reason: 'nul byte found in provided data'"
+        );
+}
+
+#[allow(dead_code)]
+fn test_nul_in_arg() {
+    //via .arg()
+    let result = std::panic::catch_unwind(|| {
+        let mut command = Command::new("test_nul_in_arg.exe");
+        command.arg_checked(OsString::from("arg1"));
+        command.arg_checked(
+            // would panic here
+            OsString::from("a\0rg2"),
+        );
+        command.arg_checked(OsString::from_vec(b"my\xffarg3".to_vec()));
+        command.status_or_panic();
+    });
+    let expected_panic_msg=
+         "Found arg '\"a\\0rg2\"' that has at least one \\0 aka nul in it! This would've been replaced with '<string-with-nul>'.";
+    expect_panic(result, expected_panic_msg);
+    //via .args()
+    let result = std::panic::catch_unwind(|| {
+        let mut command = Command::new("test_nul_in_args.exe");
+        command.args_checked([
+            // would panic here
+            OsString::from("arg1"),
+            OsString::from("a\0rg2"),
+            OsString::from_vec(b"my\xffarg3".to_vec()),
+        ]);
+        command.status_or_panic();
+    });
+    expect_panic(result, expected_panic_msg);
+}
+
+#[allow(dead_code)]
+fn test_get_what_will_run() {
+    let expected_prog = "test_get_what_will_run.exe";
+    let mut command = Command::new(expected_prog);
+    command.arg_checked(OsString::from("arg1"));
+    command.args_checked([
+        // would panic here
+        OsString::from_vec(b"my\xffarg3".to_vec()),
+        OsString::from("arg4"),
+    ]);
+    command.arg_checked(OsString::from_vec(b"my\xffarg3".to_vec()));
+    let (prog, how_many_args, formatted_args, _cur_dir, _envs) = command.get_what_will_run();
+    let expected_hma = 4;
+    let expected_fa = "\"arg1\" \"my\\xFFarg3\" \"arg4\" \"my\\xFFarg3\"";
+    assert_eq!(prog, expected_prog);
+    assert_eq!(how_many_args, expected_hma);
+    assert_eq!(formatted_args, expected_fa);
+}
+
+#[allow(dead_code)]
+fn test_assert_no_nul_in_args() {
+    let expected_prog = "test_get_what_will_run.exe";
+    let result = std::panic::catch_unwind(|| {
+        let mut command = Command::new(expected_prog);
+        command.arg("a\0here");
+        command.assert_no_nul_in_args();
+    });
+    expect_panic(
+        result,
+        r##"Found arg number '1' that has \0 aka NUL in it! It got replaced with '<string-with-nul>'."##,
+    );
 
-    std::fs::remove_file(&src).expect(&format!("cannot delete {}", src));
-    std::fs::remove_file(&bin).expect(&format!("cannot delete {}", bin));
+    let result = std::panic::catch_unwind(|| {
+        let mut command = Command::new(expected_prog);
+        command.arg("no nul in this arg here");
+        command.assert_no_nul_in_args();
+    });
+    assert!(result.is_ok(), "!!! This should not have panicked !!!");
 }
diff --git a/examples/ex_5.rs b/examples/ex_5.rs
index 16658af..293245a 100644
--- a/examples/ex_5.rs
+++ b/examples/ex_5.rs
@@ -1,6 +1,7 @@
 #[allow(unused_imports)]
 extern crate ncurses;
 
+#[cfg(feature="menu")]
 use ncurses::*;
 
 #[cfg(feature="menu")]
@@ -38,8 +39,8 @@ fn main() {
 
   /* Print a border around the main window */
   box_(my_menu_win, 0, 0);
-  mvprintw(LINES() - 3, 0, "Press <ENTER> to see the option selected");
-  mvprintw(LINES() - 2, 0, "F1 to exit");
+  mvprintw(LINES() - 3, 0, "Press <ENTER> to see the option selected").unwrap();//safe
+  mvprintw(LINES() - 2, 0, "F1 to exit").unwrap(); //safe
   refresh();
 
   /* Post the menu */
@@ -60,7 +61,8 @@ fn main() {
       10 => {/* Enter */
         mv(20, 0);
         clrtoeol();
-        mvprintw(20, 0, &format!("Item selected is : {}", item_name(current_item(my_menu)))[..]);
+        mvprintw(20, 0, &format!("Item selected is : {}", item_name(current_item(my_menu)))[..]).unwrap();
+        //unwrap() here is safe unless the items have any \0 (nul) char in them, then it will panic!
         pos_menu_cursor(my_menu);
       },
       _ => {}
diff --git a/examples/ex_7.rs b/examples/ex_7.rs
index f1b802a..ec885f8 100644
--- a/examples/ex_7.rs
+++ b/examples/ex_7.rs
@@ -10,6 +10,7 @@
 
 extern crate ncurses;
 
+#[cfg(feature = "wide")]
 use std::char;
 use ncurses::*;
 
@@ -17,7 +18,7 @@ use ncurses::*;
 fn main()
 {
   let locale_conf = LcCategory::all;
-  setlocale(locale_conf, "en_US.UTF-8");
+  setlocale(locale_conf, "en_US.UTF-8").unwrap();//safe due to this &str having no \0 in it
 
   /* Setup ncurses. */
   initscr();
@@ -56,7 +57,7 @@ fn main()
 
     Some(WchResult::Char(c)) => {
       /* Enable attributes and output message. */
-      addstr("\nKey pressed: ");
+      addstr("\nKey pressed: ").unwrap();//safe, no \0 in this &str
       attron(A_BOLD | A_BLINK);
       addstr(format!("{}\n", char::from_u32(c as u32).expect("Invalid char")).as_ref()).unwrap();
       attroff(A_BOLD | A_BLINK);
diff --git a/shell.nix b/shell.nix
index 0442e4b..d47cc2f 100644
--- a/shell.nix
+++ b/shell.nix
@@ -5,9 +5,10 @@ pkgs.stdenv.mkDerivation
   name = "ncurses-rs";
   buildInputs = with pkgs;
   [
+    pkgs.pkg-config
     pkgs.cargo
     pkgs.rustup
     pkgs.rustfmt
-    pkgs.ncurses5
+    pkgs.ncurses
   ];
 }
diff --git a/src/genconstants.c b/src/genconstants.c
index f79e2d1..b7fe694 100644
--- a/src/genconstants.c
+++ b/src/genconstants.c
@@ -1,14 +1,65 @@
+#include <stdio.h> // for printf/fprintf but curses.h already includes this(everywhere?)
 #include <curses.h>
 
 #define PCONST(ty, NAME) printf("pub const " #NAME ": " #ty " = %lld;\n", (long long) (NAME))
 #define PCONSTU(ty, NAME) printf("pub const " #NAME ": " #ty " = %llu;\n", (unsigned long long) (NAME))
 
-int main() {
-        /* some values aren't set until after this is run */
-        printf("//");
+//XXX: If NAME isn't defined via #define or anything in the ncurses.h file, instead of not defining it at all in our ncurses crate, we define it as being of a specific type(seen below as long snakecase text) which when used by any other crates(like the 'cursive' crate) will compile error in a helpful manner(the type itself is the error message and gives an idea on how to fix it)
+
+// This long snakecase text below, is a type in rust which will be shown when a crate(like cursive) that uses our crate compiles on a system with old ncurses(like macos Mojave 10.14.6 with its native ncurses version instead of the homebrew ncurses version installed), whereby one or more macro definitions like A_ITALIC aren't defined in ncurses.h
+#define ERROR_MSG_TYPE "Your_ncurses_installation_is_too_old_and_it_does_not_have_this_underlined_identifier_defined_in_its_header_file_therefore_the_ncurses_crate_did_not_include_it_because_it_tries_to_be_compatible_however_this_crate_in_which_you_see_the_error_it_needs_the_identifier__If_you_are_on_MacOS_then_use_the_brew_version_of_ncurses_and_set_PKG_CONFIG_PATH_to_the_pkgconfig_dir_from_within_it"
+//using these two(alias,constructor) in .rs avoids duplication of the long-named type for every .c defined that we wanna handle
+#define ERROR_MSG_TYPE_ALIAS "TypeAliasForErrorMsgType"
+#define ERROR_MSG_TYPE_CONSTRUCTOR "ERROR_MSG_TYPE_CONSTRUCTOR"
+
+//Same deal as before except this(error) is for defined in ncurses.h file that are expected to be missing in latest ncurses version installed in the system...
+#define ERROR_MSG_TYPE_EXPECTED_MISS "The_ncurses_crate_did_not_define_this_underlined_identifier_because_your_ncurses_installation_is_up_to_date_and_expectedly_did_not_have_it__however_the_crate_where_you_see_this_error_requires_this_identifier__so_either_upgrade_or_fix_this_crate__or_downgrade_your_ncurses_installation_and_cargo_clean_before_retrying__or_alternatively_try_using_an_older_ncurses_crate_if_you_know_that_worked_before"
+#define ERROR_MSG_EXPECTED_MISS_TYPE_ALIAS "TypeAliasForErrorMsgWhenExpectedMissType"
+#define ERROR_MSG_EXPECTED_MISS_TYPE_CONSTRUCTOR "ERROR_MSG_EXPECTED_MISS_TYPE_CONSTRUCTOR"
+
+//Don't forget to call this in main(), one time.
+#define DEFINE_RS_TYPES \
+  do {\
+    printf("/// For MacOS: `brew install ncurses` then `export PKG_CONFIG_PATH=\"/usr/local/opt/ncurses/lib/pkgconfig\"`\n/// that will give you a compatible/newer ncurses installation.\n");\
+    printf("#[derive(Debug)] // derive to avoid a warning\n\
+pub struct "ERROR_MSG_TYPE";\n\n\
+type "ERROR_MSG_TYPE_ALIAS" = "ERROR_MSG_TYPE";\n\n\
+#[allow(dead_code)]\n\
+const "ERROR_MSG_TYPE_CONSTRUCTOR": "ERROR_MSG_TYPE_ALIAS" = "ERROR_MSG_TYPE";\n\n\n");\
+printf("///Typically, the crate that errors with the following, should be patched to not use the identifier that's tagged with this type, because the latest ncurses installation doesn't have that identifier definition(anymore).\n");\
+printf("#[derive(Debug)] // derive to avoid a warning\n\
+pub struct "ERROR_MSG_TYPE_EXPECTED_MISS";\n\n\
+type "ERROR_MSG_EXPECTED_MISS_TYPE_ALIAS" = "ERROR_MSG_TYPE_EXPECTED_MISS";\n\n\
+#[allow(dead_code)]\n\
+const "ERROR_MSG_EXPECTED_MISS_TYPE_CONSTRUCTOR": "ERROR_MSG_EXPECTED_MISS_TYPE_ALIAS" = "ERROR_MSG_TYPE_EXPECTED_MISS";\n\n\
+\n\n");\
+  } while(0)
+
+#define UNEXPECTED_MISS(NAME) \
+  do {\
+    fprintf(stderr,"Unexpected missing def: " #NAME "\n");\
+    printf("pub const " #NAME ": " ERROR_MSG_TYPE_ALIAS " = " ERROR_MSG_TYPE_CONSTRUCTOR ";\n");\
+  } while(0)
+
+#define EXPECT_MISS(NAME) \
+  do {\
+    fprintf(stderr,"Missing def(but it's expected to be missing): " #NAME "\n");\
+    printf("pub const " #NAME ": " ERROR_MSG_EXPECTED_MISS_TYPE_ALIAS " = " ERROR_MSG_EXPECTED_MISS_TYPE_CONSTRUCTOR ";\n");\
+  } while(0)
+
+//#warning "This warning is unseen during `cargo build` unless compilation fails somewhere at build.rs time"
+
+int main(void) {
+	printf("/* Commented out ncurses initialization chars: '");
+
+	//fflush(stdout);fflush(stderr);*((int *)0) = 42; //segfault(on purpose for manual testing purposes from build.rs) here before terminal gets messed up needing a `reset` shell command to restore! and after something's printed to stdout.
+
+	/* some values aren't set until after this is run */
 	initscr();
 	endwin();
-        printf("\n");
+	printf("' */\n");
+
+  DEFINE_RS_TYPES;
 
 	/* Success/Failure. */
 	PCONST(i32, ERR);
@@ -19,6 +70,8 @@ int main() {
 	/* Attributes. */
 #ifdef NCURSES_ATTR_SHIFT
 	PCONST(u32, NCURSES_ATTR_SHIFT);
+#else
+  UNEXPECTED_MISS(NCURSES_ATTR_SHIFT);
 #endif
 
 	/* Colors */
@@ -34,30 +87,44 @@ int main() {
 	/* Values for the _flags member */
 #ifdef _SUBWIN
 	PCONST(i32, _SUBWIN);
+#else
+  UNEXPECTED_MISS(_SUBWIN);
 #endif
 
 #ifdef _ENDLINE
 	PCONST(i32, _ENDLINE);
+#else
+  UNEXPECTED_MISS(_ENDLINE);
 #endif
 
 #ifdef _FULLWIN
 	PCONST(i32, _FULLWIN);
+#else
+  UNEXPECTED_MISS(_FULLWIN);
 #endif
 
 #ifdef _SCROLLWIN
 	PCONST(i32, _SCROLLWIN);
+#else
+  UNEXPECTED_MISS(_SCROLLWIN);
 #endif
 
 #ifdef _ISPAD
 	PCONST(i32, _ISPAD);
+#else
+  UNEXPECTED_MISS(_ISPAD);
 #endif
 
 #ifdef _HASMOVED
 	PCONST(i32, _HASMOVED);
+#else
+  UNEXPECTED_MISS(_HASMOVED);
 #endif
 
 #ifdef _WRAPPED
 	PCONST(i32, _WRAPPED);
+#else
+  UNEXPECTED_MISS(_WRAPPED);
 #endif
 
 	/*
@@ -66,6 +133,8 @@ int main() {
 	 */
 #ifdef _NOCHANGE
 	PCONST(i32, _NOCHANGE);
+#else
+  UNEXPECTED_MISS(_NOCHANGE);
 #endif
 
 	/*
@@ -74,6 +143,8 @@ int main() {
 	 */
 #ifdef _NEWINDEX
 	PCONST(i32, _NEWINDEX);
+#else
+  UNEXPECTED_MISS(_NEWINDEX);
 #endif
 
 	/* Keys */
@@ -107,20 +178,30 @@ int main() {
 	PCONST(i32, KEY_ENTER);
 	PCONST(i32, KEY_PRINT);
 	PCONST(i32, KEY_LL);
-#ifdef A1
-	PCONST(i32, A1);
+#ifdef KEY_A1
+	PCONST(i32, KEY_A1);
+#else
+  UNEXPECTED_MISS(KEY_A1);
 #endif
-#ifdef A3
-	PCONST(i32, A3);
+#ifdef KEY_A3
+	PCONST(i32, KEY_A3);
+#else
+  UNEXPECTED_MISS(KEY_A3);
 #endif
-#ifdef B2
-	PCONST(i32, B2);
+#ifdef KEY_B2
+	PCONST(i32, KEY_B2);
+#else
+  UNEXPECTED_MISS(KEY_B2);
 #endif
-#ifdef C1
-	PCONST(i32, C1);
+#ifdef KEY_C1
+	PCONST(i32, KEY_C1);
+#else
+  UNEXPECTED_MISS(KEY_C1);
 #endif
-#ifdef C3
-	PCONST(i32, C3);
+#ifdef KEY_C3
+	PCONST(i32, KEY_C3);
+#else
+  UNEXPECTED_MISS(KEY_C3);
 #endif
 	PCONST(i32, KEY_BTAB);
 	PCONST(i32, KEY_BEG);
@@ -180,46 +261,68 @@ int main() {
 	PCONST(i32, KEY_UNDO);
 	PCONST(i32, KEY_MOUSE);
 	PCONST(i32, KEY_RESIZE);
+
+//TODO: make this 5 line block a 1 line(macro-like) and have rust preprocess it into the 5 lines, so that eg. KEY_EVENT is used only once to avoid duplication and typo or copy/paste mistakes when repeating it.
 #ifdef KEY_EVENT
 	PCONST(i32, KEY_EVENT);
+#else
+  EXPECT_MISS(KEY_EVENT);
 #endif
 	PCONST(i32, KEY_MAX);
 
 #ifdef NCURSES_MOUSE_VERSION
 	PCONST(i32, NCURSES_MOUSE_VERSION);
+#else
+  UNEXPECTED_MISS(NCURSES_MOUSE_VERSION);
 #endif
 
 #ifdef MASK_SHIFT
 	PCONST(i32, MASK_SHIFT);
+#else
+  EXPECT_MISS(MASK_SHIFT);
 #endif
 
 #ifdef MODIFIER_SHIFT
 	PCONST(i32, MODIFIER_SHIFT);
+#else
+  EXPECT_MISS(MODIFIER_SHIFT);
 #endif
 
 	/* Mouse Support */
 #ifdef NCURSES_BUTTON_RELEASED
 	PCONST(i32, NCURSES_BUTTON_RELEASED);
+#else
+  UNEXPECTED_MISS(NCURSES_BUTTON_RELEASED);
 #endif
 
 #ifdef NCURSES_BUTTON_PRESSED
 	PCONST(i32, NCURSES_BUTTON_PRESSED);
+#else
+  UNEXPECTED_MISS(NCURSES_BUTTON_PRESSED);
 #endif
 
 #ifdef NCURSES_BUTTON_CLICKED
 	PCONST(i32, NCURSES_BUTTON_CLICKED);
+#else
+  UNEXPECTED_MISS(NCURSES_BUTTON_CLICKED);
 #endif
 
 #ifdef NCURSES_DOUBLE_CLICKED
 	PCONST(i32, NCURSES_DOUBLE_CLICKED);
+#else
+  UNEXPECTED_MISS(NCURSES_DOUBLE_CLICKED);
 #endif
 
 #ifdef NCURSES_TRIPLE_CLICKED
 	PCONST(i32, NCURSES_TRIPLE_CLICKED);
+#else
+  UNEXPECTED_MISS(NCURSES_TRIPLE_CLICKED);
 #endif
 
 #ifdef NCURSES_RESERVED_EVENT
 	PCONST(i32, NCURSES_RESERVED_EVENT);
+#else
+  UNEXPECTED_MISS(NCURSES_RESERVED_EVENT);
 #endif
 
 	/* event masks */
@@ -249,22 +352,32 @@ int main() {
 
 #ifdef BUTTON5_RELEASED
 	PCONST(i32, BUTTON5_RELEASED);
+#else
+  UNEXPECTED_MISS(BUTTON5_RELEASED);
 #endif
 
 #ifdef BUTTON5_PRESSED
 	PCONST(i32, BUTTON5_PRESSED);
+#else
+  UNEXPECTED_MISS(BUTTON5_PRESSED);
 #endif
 
 #ifdef BUTTON5_CLICKED
 	PCONST(i32, BUTTON5_CLICKED);
+#else
+  UNEXPECTED_MISS(BUTTON5_CLICKED);
 #endif
 
 #ifdef BUTTON5_DOUBLE_CLICKED
 	PCONST(i32, BUTTON5_DOUBLE_CLICKED);
+#else
+  UNEXPECTED_MISS(BUTTON5_DOUBLE_CLICKED);
 #endif
 
 #ifdef BUTTON5_TRIPLE_CLICKED
 	PCONST(i32, BUTTON5_TRIPLE_CLICKED);
+#else
+  UNEXPECTED_MISS(BUTTON5_TRIPLE_CLICKED);
 #endif
 
 	PCONST(i32, BUTTON_CTRL);
@@ -278,6 +391,11 @@ int main() {
 	PCONSTU(crate::ll::chtype, A_NORMAL);
 	PCONSTU(crate::ll::chtype, A_STANDOUT);
 	PCONSTU(crate::ll::chtype, A_UNDERLINE);
+#ifdef A_ITALIC
+	PCONSTU(crate::ll::chtype, A_ITALIC);
+#else
+  UNEXPECTED_MISS(A_ITALIC);
+#endif
 	PCONSTU(crate::ll::chtype, A_REVERSE);
 	PCONSTU(crate::ll::chtype, A_BLINK);
 	PCONSTU(crate::ll::chtype, A_DIM);
@@ -285,6 +403,8 @@ int main() {
 
 #ifdef A_BLANK
 	PCONSTU(crate::ll::chtype, A_BLANK);
+#else
+  EXPECT_MISS(A_BLANK);
 #endif
 
 	PCONSTU(crate::ll::chtype, A_INVIS);
@@ -293,4 +413,7 @@ int main() {
 	PCONSTU(crate::ll::chtype, A_ATTRIBUTES);
 	PCONSTU(crate::ll::chtype, A_CHARTEXT);
 	PCONSTU(crate::ll::chtype, A_COLOR);
+
+	//do last, flush just to be sure!
+	fflush(stdout);fflush(stderr);
 }
diff --git a/src/lib.rs b/src/lib.rs
index 06facde..a5576bd 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -17,7 +17,7 @@ extern crate libc;
 use std::mem;
 use std::{ char, ptr };
 use std::ffi::{CString, CStr};
-use self::ll::{FILE_p};
+use self::ll::FILE_p;
 pub use self::constants::*;
 pub use self::panel::wrapper::*;
 pub use self::menu::wrapper::*;
@@ -158,7 +158,12 @@ pub fn border(ls: chtype, rs: chtype, ts: chtype, bs: chtype, tl: chtype, tr: ch
 { unsafe { ll::border(ls, rs, ts, bs, tl, tr, bl, br) } }
 
 
-#[link_name="box"] pub fn box_(w: WINDOW, v: chtype, h: chtype) -> i32
+// this is 'box' in rust but must use r#box because 'box' is reserved keyword
+#[inline(always)]
+pub fn r#box(w: WINDOW, v: chtype, h: chtype) -> i32
+{ box_(w,v,h) }
+
+pub fn box_(w: WINDOW, v: chtype, h: chtype) -> i32
 { wborder(w, v, v, h, h, 0, 0, 0, 0) }
 
 
@@ -1096,7 +1101,6 @@ pub fn prefresh(pad: WINDOW, pmin_row: i32, pmin_col: i32, smin_row: i32, smin_c
 { unsafe { ll::prefresh(pad, pmin_row, pmin_col, smin_row, smin_col, smax_row, smax_col) } }
 
 
-#[deprecated(since = "5.98.0", note = "printw format support is disabled. Use addstr instead")]
 pub fn printw(s: &str) -> Result<i32, std::ffi::NulError>
 {
     // We don't actually need this function to support format strings,
@@ -1769,7 +1773,8 @@ pub fn setsyx(y: &mut i32, x: &mut i32)
   }
 }
 
-pub fn KEY_F(n: u8) -> i32
+#[inline]
+pub const fn KEY_F(n: u8) -> i32
 {
   assert!(n < 16);
   KEY_F0 + n as i32
diff --git a/src/ll.rs b/src/ll.rs
index d6916ec..24ef141 100644
--- a/src/ll.rs
+++ b/src/ll.rs
@@ -62,7 +62,10 @@ extern {
     pub fn bkgd(_:chtype) -> c_int;
     pub fn bkgdset(_:chtype);
     pub fn border(_:chtype,_:chtype,_:chtype,_:chtype,_:chtype,_:chtype,_:chtype,_:chtype) -> c_int;
+    #[link_name="box"] // points to 'box' of ncurses lib, but is 'box_' here in rust.
     pub fn box_(_:WINDOW, _:chtype, _:chtype) -> c_int;
+    //This is 'box' both in rust and in ncurses lib; but 'box' is reserved keyword, so use r#box
+    pub fn r#box(_:WINDOW, _:chtype, _:chtype) -> c_int;
     pub fn can_change_color() -> c_bool;
     pub fn cbreak() -> c_int;
     pub fn chgat(_:c_int, _:attr_t, _:c_short, _:void_p) -> c_int;
@@ -261,8 +264,8 @@ extern {
     //  fn vidputs(_:chtype, extern  fn f(c_int) -> c_int) -> c_int;
     //pub fn vidputs(_:chtype, f:*mut c_char) -> c_int;
     pub fn vline(_:chtype, _:c_int) -> c_int;
-    pub fn vwprintw(_:WINDOW, _:char_p, _:va_list) -> c_int;
-    pub fn vw_printw(_:WINDOW, _:char_p,_:va_list) -> c_int;
+    pub fn vwprintw(_:WINDOW, fmt:char_p, _:va_list) -> c_int;
+    pub fn vw_printw(_:WINDOW, fmt:char_p,_:va_list) -> c_int;
     //  fn vwscanw(_:WINDOW, _:char_p, _:va_list) -> c_int;
     //  fn vw_scanw(_:WINDOW, _:char_p, _:va_list) -> c_int;
     pub fn waddch(_:WINDOW, _:chtype) -> c_int;
@@ -423,7 +426,7 @@ extern {
     
 }
 
-/// Extended color support. Requires ncurses6.
+// XXX: Extended color support. Requires ncurses6.
 #[cfg(feature = "extended_colors")]
 extern {
     pub fn init_extended_color(_: c_int, _: c_int, _: c_int, _: c_int) -> c_int;
diff --git a/src/menu/wrapper.rs b/src/menu/wrapper.rs
index b5d72ec..54016c6 100644
--- a/src/menu/wrapper.rs
+++ b/src/menu/wrapper.rs
@@ -1,5 +1,6 @@
 #![allow(dead_code)]
 #![allow(unused_imports)]
+#![warn(temporary_cstring_as_ptr)] // false positives? https://github.com/rust-lang/rust/issues/78691
 
 use std::str;
 use std::ptr;
@@ -412,7 +413,8 @@ pub fn unpost_menu(menu: MENU) -> i32 {
 #[cfg(feature="menu")]
 pub fn menu_request_by_name<T: Into<Vec<u8>>>(name: T) -> i32 {
   unsafe {
-    super::ll::menu_request_by_name(CString::new(name).unwrap().as_ptr())
+    let cs=CString::new(name).unwrap();
+    super::ll::menu_request_by_name(cs.as_ptr())
   }
 }
 
